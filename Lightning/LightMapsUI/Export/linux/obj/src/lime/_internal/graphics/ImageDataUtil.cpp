// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeCFFI
#include <lime/_internal/backend/native/NativeCFFI.h>
#endif
#ifndef INCLUDED_lime__internal_graphics_ImageDataUtil
#include <lime/_internal/graphics/ImageDataUtil.h>
#endif
#ifndef INCLUDED_lime__internal_graphics__ImageDataUtil_ImageDataView
#include <lime/_internal/graphics/_ImageDataUtil/ImageDataView.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_ImageBuffer
#include <lime/graphics/ImageBuffer.h>
#endif
#ifndef INCLUDED_lime_math_Rectangle
#include <lime/math/Rectangle.h>
#endif
#ifndef INCLUDED_lime_math__RGBA_RGBA_Impl_
#include <lime/math/_RGBA/RGBA_Impl_.h>
#endif
#ifndef INCLUDED_lime_system_CFFI
#include <lime/system/CFFI.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_68d87270d4f7b5ed_508_fillRect,"lime._internal.graphics.ImageDataUtil","fillRect",0x041873c6,"lime._internal.graphics.ImageDataUtil.fillRect","lime/_internal/graphics/ImageDataUtil.hx",508,0x59dddace)
namespace lime{
namespace _internal{
namespace graphics{

void ImageDataUtil_obj::__construct() { }

Dynamic ImageDataUtil_obj::__CreateEmpty() { return new ImageDataUtil_obj; }

void *ImageDataUtil_obj::_hx_vtable = 0;

Dynamic ImageDataUtil_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ImageDataUtil_obj > _hx_result = new ImageDataUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ImageDataUtil_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x173c18b5;
}

void ImageDataUtil_obj::fillRect( ::lime::graphics::Image image, ::lime::math::Rectangle rect,int color,int format){
            	HX_GC_STACKFRAME(&_hx_pos_68d87270d4f7b5ed_508_fillRect)
HXLINE( 509)		int fillColor;
HXLINE( 511)		switch((int)(format)){
            			case (int)1: {
HXLINE( 514)				int argb = color;
HXDLIN( 514)				int rgba = 0;
HXDLIN( 514)				rgba = ((((((::hx::UShr(argb,16) & 255) & 255) << 24) | (((::hx::UShr(argb,8) & 255) & 255) << 16)) | (((argb & 255) & 255) << 8)) | ((::hx::UShr(argb,24) & 255) & 255));
HXDLIN( 514)				fillColor = rgba;
            			}
            			break;
            			case (int)2: {
HXLINE( 516)				int bgra = color;
HXDLIN( 516)				int rgba1 = 0;
HXDLIN( 516)				rgba1 = ((((((::hx::UShr(bgra,8) & 255) & 255) << 24) | (((::hx::UShr(bgra,16) & 255) & 255) << 16)) | (((::hx::UShr(bgra,24) & 255) & 255) << 8)) | ((bgra & 255) & 255));
HXDLIN( 516)				fillColor = rgba1;
            			}
            			break;
            			default:{
HXLINE( 518)				fillColor = color;
            			}
            		}
HXLINE( 521)		if (!(image->get_transparent())) {
HXLINE( 523)			fillColor = ((((((::hx::UShr(fillColor,24) & 255) & 255) << 24) | (((::hx::UShr(fillColor,16) & 255) & 255) << 16)) | (((::hx::UShr(fillColor,8) & 255) & 255) << 8)) | 255);
            		}
HXLINE( 526)		 ::lime::utils::ArrayBufferView data = image->buffer->data;
HXLINE( 527)		if (::hx::IsNull( data )) {
HXLINE( 527)			return;
            		}
HXLINE( 530)		if (::lime::_hx_system::CFFI_obj::enabled) {
HXLINE( 530)			::lime::_internal::backend::native::NativeCFFI_obj::lime_image_data_util_fill_rect(::hx::DynamicPtr(image),::hx::DynamicPtr(rect),((fillColor >> 16) & 65535),(fillColor & 65535));
            		}
            		else {
HXLINE( 535)			int format1 = image->buffer->format;
HXLINE( 536)			bool premultiplied = image->buffer->premultiplied;
HXLINE( 537)			if (premultiplied) {
HXLINE( 537)				if (((fillColor & 255) == 0)) {
HXLINE( 537)					if ((fillColor != 0)) {
HXLINE( 537)						fillColor = 0;
            					}
            				}
            				else {
HXLINE( 537)					if (((fillColor & 255) != 255)) {
HXLINE( 537)						 ::lime::utils::ArrayBufferView this1 = ::lime::math::_RGBA::RGBA_Impl__obj::_hx___alpha16;
HXDLIN( 537)						::lime::math::_RGBA::RGBA_Impl__obj::a16 = ( (int)( ::__hxcpp_memory_get_ui32(this1->buffer->b,(this1->byteOffset + ((fillColor & 255) * 4)))) );
HXDLIN( 537)						fillColor = ((((((((::hx::UShr(fillColor,24) & 255) * ::lime::math::_RGBA::RGBA_Impl__obj::a16) >> 16) & 255) << 24) | (((((::hx::UShr(fillColor,16) & 255) * ::lime::math::_RGBA::RGBA_Impl__obj::a16) >> 16) & 255) << 16)) | (((((::hx::UShr(fillColor,8) & 255) * ::lime::math::_RGBA::RGBA_Impl__obj::a16) >> 16) & 255) << 8)) | ((fillColor & 255) & 255));
            					}
            				}
            			}
HXLINE( 539)			 ::lime::_internal::graphics::_ImageDataUtil::ImageDataView dataView =  ::lime::_internal::graphics::_ImageDataUtil::ImageDataView_obj::__alloc( HX_CTX ,image,rect);
HXLINE( 540)			int row;
HXLINE( 542)			{
HXLINE( 542)				int _g = 0;
HXDLIN( 542)				int _g1 = dataView->height;
HXDLIN( 542)				while((_g < _g1)){
HXLINE( 542)					_g = (_g + 1);
HXDLIN( 542)					int y = (_g - 1);
HXLINE( 544)					row = (dataView->byteOffset + (dataView->stride * y));
HXLINE( 546)					{
HXLINE( 546)						int _g2 = 0;
HXDLIN( 546)						int _g3 = dataView->width;
HXDLIN( 546)						while((_g2 < _g3)){
HXLINE( 546)							_g2 = (_g2 + 1);
HXDLIN( 546)							int x = (_g2 - 1);
HXLINE( 548)							{
HXLINE( 548)								int offset = (row + (x * 4));
HXDLIN( 548)								switch((int)(format1)){
            									case (int)0: {
HXLINE( 548)										{
HXLINE( 548)											int val = (::hx::UShr(fillColor,24) & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + offset),val);
            										}
HXDLIN( 548)										{
HXLINE( 548)											int val1 = (::hx::UShr(fillColor,16) & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + (offset + 1)),val1);
            										}
HXDLIN( 548)										{
HXLINE( 548)											int val2 = (::hx::UShr(fillColor,8) & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + (offset + 2)),val2);
            										}
HXDLIN( 548)										{
HXLINE( 548)											int val3 = (fillColor & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + (offset + 3)),val3);
            										}
            									}
            									break;
            									case (int)1: {
HXLINE( 548)										{
HXLINE( 548)											int val4 = (fillColor & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + offset),val4);
            										}
HXDLIN( 548)										{
HXLINE( 548)											int val5 = (::hx::UShr(fillColor,24) & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + (offset + 1)),val5);
            										}
HXDLIN( 548)										{
HXLINE( 548)											int val6 = (::hx::UShr(fillColor,16) & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + (offset + 2)),val6);
            										}
HXDLIN( 548)										{
HXLINE( 548)											int val7 = (::hx::UShr(fillColor,8) & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + (offset + 3)),val7);
            										}
            									}
            									break;
            									case (int)2: {
HXLINE( 548)										{
HXLINE( 548)											int val8 = (::hx::UShr(fillColor,8) & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + offset),val8);
            										}
HXDLIN( 548)										{
HXLINE( 548)											int val9 = (::hx::UShr(fillColor,16) & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + (offset + 1)),val9);
            										}
HXDLIN( 548)										{
HXLINE( 548)											int val10 = (::hx::UShr(fillColor,24) & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + (offset + 2)),val10);
            										}
HXDLIN( 548)										{
HXLINE( 548)											int val11 = (fillColor & 255);
HXDLIN( 548)											 ::__hxcpp_memory_set_byte(data->buffer->b,(data->byteOffset + (offset + 3)),val11);
            										}
            									}
            									break;
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 553)		image->dirty = true;
HXLINE( 554)		image->version++;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(ImageDataUtil_obj,fillRect,(void))


ImageDataUtil_obj::ImageDataUtil_obj()
{
}

bool ImageDataUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"fillRect") ) { outValue = fillRect_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ImageDataUtil_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *ImageDataUtil_obj_sStaticStorageInfo = 0;
#endif

::hx::Class ImageDataUtil_obj::__mClass;

static ::String ImageDataUtil_obj_sStaticFields[] = {
	HX_("fillRect",47,45,b9,6c),
	::String(null())
};

void ImageDataUtil_obj::__register()
{
	ImageDataUtil_obj _hx_dummy;
	ImageDataUtil_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("lime._internal.graphics.ImageDataUtil",cf,fd,b0,0e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ImageDataUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ImageDataUtil_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< ImageDataUtil_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ImageDataUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ImageDataUtil_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace lime
} // end namespace _internal
} // end namespace graphics
