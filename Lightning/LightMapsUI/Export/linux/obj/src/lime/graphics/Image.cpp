// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeCFFI
#include <lime/_internal/backend/native/NativeCFFI.h>
#endif
#ifndef INCLUDED_lime__internal_graphics_ImageCanvasUtil
#include <lime/_internal/graphics/ImageCanvasUtil.h>
#endif
#ifndef INCLUDED_lime__internal_graphics_ImageDataUtil
#include <lime/_internal/graphics/ImageDataUtil.h>
#endif
#ifndef INCLUDED_lime_app_Future
#include <lime/app/Future.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_ImageBuffer
#include <lime/graphics/ImageBuffer.h>
#endif
#ifndef INCLUDED_lime_graphics_ImageType
#include <lime/graphics/ImageType.h>
#endif
#ifndef INCLUDED_lime_math_Rectangle
#include <lime/math/Rectangle.h>
#endif
#ifndef INCLUDED_lime_net__HTTPRequest_AbstractHTTPRequest
#include <lime/net/_HTTPRequest/AbstractHTTPRequest.h>
#endif
#ifndef INCLUDED_lime_net__HTTPRequest_Bytes
#include <lime/net/_HTTPRequest_Bytes.h>
#endif
#ifndef INCLUDED_lime_net__HTTPRequest_lime_graphics_Image
#include <lime/net/_HTTPRequest_lime_graphics_Image.h>
#endif
#ifndef INCLUDED_lime_net__IHTTPRequest
#include <lime/net/_IHTTPRequest.h>
#endif
#ifndef INCLUDED_lime_system_CFFI
#include <lime/system/CFFI.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_TAError
#include <lime/utils/TAError.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_221_new,"lime.graphics.Image","new",0x344ae603,"lime.graphics.Image.new","lime/graphics/Image.hx",221,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_532_fillRect,"lime.graphics.Image","fillRect",0x2421e0c4,"lime.graphics.Image.fillRect","lime/graphics/Image.hx",532,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1402___clipRect,"lime.graphics.Image","__clipRect",0xd30737f1,"lime.graphics.Image.__clipRect","lime/graphics/Image.hx",1402,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1474___fromBytes,"lime.graphics.Image","__fromBytes",0x40972c24,"lime.graphics.Image.__fromBytes","lime/graphics/Image.hx",1474,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1531___fromFile,"lime.graphics.Image","__fromFile",0x1c2444e3,"lime.graphics.Image.__fromFile","lime/graphics/Image.hx",1531,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1693___fromImageBuffer,"lime.graphics.Image","__fromImageBuffer",0xe152fb34,"lime.graphics.Image.__fromImageBuffer","lime/graphics/Image.hx",1693,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1885_get_rect,"lime.graphics.Image","get_rect",0x82caa42a,"lime.graphics.Image.get_rect","lime/graphics/Image.hx",1885,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1897_get_src,"lime.graphics.Image","get_src",0x66c2929e,"lime.graphics.Image.get_src","lime/graphics/Image.hx",1897,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1906_get_transparent,"lime.graphics.Image","get_transparent",0xe1ee610c,"lime.graphics.Image.get_transparent","lime/graphics/Image.hx",1906,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_652_fromBytes,"lime.graphics.Image","fromBytes",0x36406484,"lime.graphics.Image.fromBytes","lime/graphics/Image.hx",652,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_695_fromFile,"lime.graphics.Image","fromFile",0x58f03883,"lime.graphics.Image.fromFile","lime/graphics/Image.hx",695,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_997_loadFromBytes,"lime.graphics.Image","loadFromBytes",0xafa862fe,"lime.graphics.Image.loadFromBytes","lime/graphics/Image.hx",997,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_941_loadFromBytes,"lime.graphics.Image","loadFromBytes",0xafa862fe,"lime.graphics.Image.loadFromBytes","lime/graphics/Image.hx",941,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1056_loadFromFile,"lime.graphics.Image","loadFromFile",0xfb592749,"lime.graphics.Image.loadFromFile","lime/graphics/Image.hx",1056,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1007_loadFromFile,"lime.graphics.Image","loadFromFile",0xfb592749,"lime.graphics.Image.loadFromFile","lime/graphics/Image.hx",1007,0xc7b862ad)
namespace lime{
namespace graphics{

void Image_obj::__construct( ::lime::graphics::ImageBuffer buffer,::hx::Null< int >  __o_offsetX,::hx::Null< int >  __o_offsetY,::hx::Null< int >  __o_width,::hx::Null< int >  __o_height, ::Dynamic color, ::lime::graphics::ImageType type){
            		int offsetX = __o_offsetX.Default(0);
            		int offsetY = __o_offsetY.Default(0);
            		int width = __o_width.Default(-1);
            		int height = __o_height.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_221_new)
HXLINE( 222)		this->offsetX = offsetX;
HXLINE( 223)		this->offsetY = offsetY;
HXLINE( 224)		this->width = width;
HXLINE( 225)		this->height = height;
HXLINE( 227)		this->version = 0;
HXLINE( 229)		if (::hx::IsNull( type )) {
HXLINE( 236)			type = ::lime::graphics::ImageType_obj::DATA_dyn();
            		}
HXLINE( 240)		this->type = type;
HXLINE( 242)		if (::hx::IsNull( buffer )) {
HXLINE( 244)			bool _hx_tmp;
HXDLIN( 244)			if ((width > 0)) {
HXLINE( 244)				_hx_tmp = (height > 0);
            			}
            			else {
HXLINE( 244)				_hx_tmp = false;
            			}
HXDLIN( 244)			if (_hx_tmp) {
HXLINE( 246)				switch((int)(this->type->_hx_getIndex())){
            					case (int)0: {
HXLINE( 249)						this->buffer =  ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,null(),width,height,null(),null());
HXLINE( 250)						::lime::_internal::graphics::ImageCanvasUtil_obj::createCanvas(::hx::ObjectPtr<OBJ_>(this),width,height);
HXLINE( 252)						bool _hx_tmp1;
HXDLIN( 252)						if (::hx::IsNotNull( color )) {
HXLINE( 252)							_hx_tmp1 = ::hx::IsNotEq( color,0 );
            						}
            						else {
HXLINE( 252)							_hx_tmp1 = false;
            						}
HXDLIN( 252)						if (_hx_tmp1) {
HXLINE( 254)							this->fillRect( ::lime::math::Rectangle_obj::__alloc( HX_CTX ,0,0,width,height),( (int)(color) ),null());
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 258)						 ::Dynamic elements = ((width * height) * 4);
HXDLIN( 258)						 ::haxe::io::Bytes buffer1 = null();
HXDLIN( 258)						::cpp::VirtualArray array = null();
HXDLIN( 258)						 ::lime::utils::ArrayBufferView view = null();
HXDLIN( 258)						 ::Dynamic len = null();
HXDLIN( 258)						 ::lime::utils::ArrayBufferView this1;
HXDLIN( 258)						if (::hx::IsNotNull( elements )) {
HXLINE( 258)							this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,4);
            						}
            						else {
HXLINE( 258)							if (::hx::IsNotNull( array )) {
HXLINE( 258)								 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN( 258)								_this->byteOffset = 0;
HXDLIN( 258)								_this->length = array->get_length();
HXDLIN( 258)								_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN( 258)								_this->buffer = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN( 258)								_this->copyFromArray(array,null());
HXDLIN( 258)								this1 = _this;
            							}
            							else {
HXLINE( 258)								if (::hx::IsNotNull( view )) {
HXLINE( 258)									 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN( 258)									 ::haxe::io::Bytes srcData = view->buffer;
HXDLIN( 258)									int srcLength = view->length;
HXDLIN( 258)									int srcByteOffset = view->byteOffset;
HXDLIN( 258)									int srcElementSize = view->bytesPerElement;
HXDLIN( 258)									int elementSize = _this1->bytesPerElement;
HXDLIN( 258)									if ((view->type == _this1->type)) {
HXLINE( 258)										int srcLength1 = srcData->length;
HXDLIN( 258)										int cloneLength = (srcLength1 - srcByteOffset);
HXDLIN( 258)										_this1->buffer = ::haxe::io::Bytes_obj::alloc(cloneLength);
HXDLIN( 258)										_this1->buffer->blit(0,srcData,srcByteOffset,cloneLength);
            									}
            									else {
HXLINE( 258)										HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            									}
HXDLIN( 258)									_this1->byteLength = (_this1->bytesPerElement * srcLength);
HXDLIN( 258)									_this1->byteOffset = 0;
HXDLIN( 258)									_this1->length = srcLength;
HXDLIN( 258)									this1 = _this1;
            								}
            								else {
HXLINE( 258)									if (::hx::IsNotNull( buffer1 )) {
HXLINE( 258)										 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN( 258)										int in_byteOffset = 0;
HXDLIN( 258)										if ((in_byteOffset < 0)) {
HXLINE( 258)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN( 258)										if ((::hx::Mod(in_byteOffset,_this2->bytesPerElement) != 0)) {
HXLINE( 258)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN( 258)										int bufferByteLength = buffer1->length;
HXDLIN( 258)										int elementSize1 = _this2->bytesPerElement;
HXDLIN( 258)										int newByteLength = bufferByteLength;
HXDLIN( 258)										if (::hx::IsNull( len )) {
HXLINE( 258)											newByteLength = (bufferByteLength - in_byteOffset);
HXDLIN( 258)											if ((::hx::Mod(bufferByteLength,_this2->bytesPerElement) != 0)) {
HXLINE( 258)												HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            											}
HXDLIN( 258)											if ((newByteLength < 0)) {
HXLINE( 258)												HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            											}
            										}
            										else {
HXLINE( 258)											newByteLength = (( (int)(len) ) * _this2->bytesPerElement);
HXDLIN( 258)											int newRange = (in_byteOffset + newByteLength);
HXDLIN( 258)											if ((newRange > bufferByteLength)) {
HXLINE( 258)												HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            											}
            										}
HXDLIN( 258)										_this2->buffer = buffer1;
HXDLIN( 258)										_this2->byteOffset = in_byteOffset;
HXDLIN( 258)										_this2->byteLength = newByteLength;
HXDLIN( 258)										_this2->length = ::Std_obj::_hx_int((( (Float)(newByteLength) ) / ( (Float)(_this2->bytesPerElement) )));
HXDLIN( 258)										this1 = _this2;
            									}
            									else {
HXLINE( 258)										HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8Array",6b,44,d5,85));
            									}
            								}
            							}
            						}
HXDLIN( 258)						this->buffer =  ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,this1,width,height,null(),null());
HXLINE( 260)						bool _hx_tmp2;
HXDLIN( 260)						if (::hx::IsNotNull( color )) {
HXLINE( 260)							_hx_tmp2 = ::hx::IsNotEq( color,0 );
            						}
            						else {
HXLINE( 260)							_hx_tmp2 = false;
            						}
HXDLIN( 260)						if (_hx_tmp2) {
HXLINE( 262)							this->fillRect( ::lime::math::Rectangle_obj::__alloc( HX_CTX ,0,0,width,height),( (int)(color) ),null());
            						}
            					}
            					break;
            					case (int)2: {
            					}
            					break;
            					default:{
            					}
            				}
            			}
            		}
            		else {
HXLINE( 277)			this->_hx___fromImageBuffer(buffer);
            		}
            	}

Dynamic Image_obj::__CreateEmpty() { return new Image_obj; }

void *Image_obj::_hx_vtable = 0;

Dynamic Image_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Image_obj > _hx_result = new Image_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6]);
	return _hx_result;
}

bool Image_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x33f052f7;
}

void Image_obj::fillRect( ::lime::math::Rectangle rect,int color, ::Dynamic format){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_532_fillRect)
HXLINE( 533)		rect = this->_hx___clipRect(rect);
HXLINE( 534)		bool _hx_tmp;
HXDLIN( 534)		if (::hx::IsNotNull( this->buffer )) {
HXLINE( 534)			_hx_tmp = ::hx::IsNull( rect );
            		}
            		else {
HXLINE( 534)			_hx_tmp = true;
            		}
HXDLIN( 534)		if (_hx_tmp) {
HXLINE( 534)			return;
            		}
HXLINE( 536)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 539)				::lime::_internal::graphics::ImageCanvasUtil_obj::fillRect(::hx::ObjectPtr<OBJ_>(this),rect,color,( (int)(format) ));
            			}
            			break;
            			case (int)1: {
HXLINE( 546)				if ((this->buffer->data->length == 0)) {
HXLINE( 546)					return;
            				}
HXLINE( 548)				::lime::_internal::graphics::ImageDataUtil_obj::fillRect(::hx::ObjectPtr<OBJ_>(this),rect,color,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE( 551)				rect->offset(( (Float)(this->offsetX) ),( (Float)(this->offsetY) ));
HXLINE( 553)				int argb;
HXDLIN( 553)				if (::hx::IsNull( format )) {
HXLINE( 557)					int rgba = color;
HXDLIN( 557)					int argb1 = 0;
HXDLIN( 557)					argb1 = ((((((rgba & 255) & 255) << 24) | (((::hx::UShr(rgba,24) & 255) & 255) << 16)) | (((::hx::UShr(rgba,16) & 255) & 255) << 8)) | ((::hx::UShr(rgba,8) & 255) & 255));
HXLINE( 553)					argb = argb1;
            				}
            				else {
HXLINE( 553)					 ::Dynamic _hx_switch_0 = format;
            					if (  (_hx_switch_0==1) ){
HXLINE( 553)						argb = color;
HXDLIN( 553)						goto _hx_goto_1;
            					}
            					if (  (_hx_switch_0==2) ){
HXLINE( 556)						int bgra = color;
HXDLIN( 556)						int argb2 = 0;
HXDLIN( 556)						argb2 = ((((((bgra & 255) & 255) << 24) | (((::hx::UShr(bgra,8) & 255) & 255) << 16)) | (((::hx::UShr(bgra,16) & 255) & 255) << 8)) | ((::hx::UShr(bgra,24) & 255) & 255));
HXLINE( 553)						argb = argb2;
HXLINE( 556)						goto _hx_goto_1;
            					}
            					/* default */{
HXLINE( 557)						int rgba1 = color;
HXDLIN( 557)						int argb3 = 0;
HXDLIN( 557)						argb3 = ((((((rgba1 & 255) & 255) << 24) | (((::hx::UShr(rgba1,24) & 255) & 255) << 16)) | (((::hx::UShr(rgba1,16) & 255) & 255) << 8)) | ((::hx::UShr(rgba1,8) & 255) & 255));
HXLINE( 553)						argb = argb3;
            					}
            					_hx_goto_1:;
            				}
HXLINE( 560)				 ::Dynamic _hx_tmp1 =  ::Dynamic(this->buffer->_hx___srcBitmapData->__Field(HX_("fillRect",47,45,b9,6c),::hx::paccDynamic));
HXDLIN( 560)				_hx_tmp1(rect->_hx___toFlashRectangle(),argb);
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Image_obj,fillRect,(void))

 ::lime::math::Rectangle Image_obj::_hx___clipRect( ::lime::math::Rectangle r){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1402___clipRect)
HXLINE(1403)		if (::hx::IsNull( r )) {
HXLINE(1403)			return null();
            		}
HXLINE(1405)		if ((r->x < 0)) {
HXLINE(1407)			 ::lime::math::Rectangle r1 = r;
HXDLIN(1407)			r1->width = (r1->width - -(r->x));
HXLINE(1408)			r->x = ( (Float)(0) );
HXLINE(1410)			if (((r->x + r->width) <= 0)) {
HXLINE(1410)				return null();
            			}
            		}
HXLINE(1413)		if ((r->y < 0)) {
HXLINE(1415)			 ::lime::math::Rectangle r2 = r;
HXDLIN(1415)			r2->height = (r2->height - -(r->y));
HXLINE(1416)			r->y = ( (Float)(0) );
HXLINE(1418)			if (((r->y + r->height) <= 0)) {
HXLINE(1418)				return null();
            			}
            		}
HXLINE(1421)		if (((r->x + r->width) >= this->width)) {
HXLINE(1423)			 ::lime::math::Rectangle r3 = r;
HXDLIN(1423)			r3->width = (r3->width - ((r->x + r->width) - ( (Float)(this->width) )));
HXLINE(1425)			if ((r->width <= 0)) {
HXLINE(1425)				return null();
            			}
            		}
HXLINE(1428)		if (((r->y + r->height) >= this->height)) {
HXLINE(1430)			 ::lime::math::Rectangle r4 = r;
HXDLIN(1430)			r4->height = (r4->height - ((r->y + r->height) - ( (Float)(this->height) )));
HXLINE(1432)			if ((r->height <= 0)) {
HXLINE(1432)				return null();
            			}
            		}
HXLINE(1435)		return r;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,_hx___clipRect,return )

bool Image_obj::_hx___fromBytes( ::haxe::io::Bytes bytes, ::Dynamic onload){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1474___fromBytes)
HXLINE(1499)		 ::lime::graphics::ImageBuffer imageBuffer = null();
HXLINE(1502)		::cpp::Function<  ::hx::Object *  ( ::hx::Object *, ::hx::Object *) > imageBuffer1 = ::lime::_internal::backend::native::NativeCFFI_obj::lime_image_load_bytes;
HXDLIN(1502)		 ::Dynamic elements = null();
HXDLIN(1502)		 ::haxe::io::Bytes buffer = ::haxe::io::Bytes_obj::alloc(0);
HXDLIN(1502)		::cpp::VirtualArray array = null();
HXDLIN(1502)		 ::lime::utils::ArrayBufferView view = null();
HXDLIN(1502)		 ::Dynamic len = null();
HXDLIN(1502)		 ::lime::utils::ArrayBufferView this1;
HXDLIN(1502)		if (::hx::IsNotNull( elements )) {
HXLINE(1502)			this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,4);
            		}
            		else {
HXLINE(1502)			if (::hx::IsNotNull( array )) {
HXLINE(1502)				 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1502)				_this->byteOffset = 0;
HXDLIN(1502)				_this->length = array->get_length();
HXDLIN(1502)				_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN(1502)				_this->buffer = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN(1502)				_this->copyFromArray(array,null());
HXDLIN(1502)				this1 = _this;
            			}
            			else {
HXLINE(1502)				if (::hx::IsNotNull( view )) {
HXLINE(1502)					 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1502)					 ::haxe::io::Bytes srcData = view->buffer;
HXDLIN(1502)					int srcLength = view->length;
HXDLIN(1502)					int srcByteOffset = view->byteOffset;
HXDLIN(1502)					int srcElementSize = view->bytesPerElement;
HXDLIN(1502)					int elementSize = _this1->bytesPerElement;
HXDLIN(1502)					if ((view->type == _this1->type)) {
HXLINE(1502)						int srcLength1 = srcData->length;
HXDLIN(1502)						int cloneLength = (srcLength1 - srcByteOffset);
HXDLIN(1502)						_this1->buffer = ::haxe::io::Bytes_obj::alloc(cloneLength);
HXDLIN(1502)						_this1->buffer->blit(0,srcData,srcByteOffset,cloneLength);
            					}
            					else {
HXLINE(1502)						HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            					}
HXDLIN(1502)					_this1->byteLength = (_this1->bytesPerElement * srcLength);
HXDLIN(1502)					_this1->byteOffset = 0;
HXDLIN(1502)					_this1->length = srcLength;
HXDLIN(1502)					this1 = _this1;
            				}
            				else {
HXLINE(1502)					if (::hx::IsNotNull( buffer )) {
HXLINE(1502)						 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1502)						int in_byteOffset = 0;
HXDLIN(1502)						if ((in_byteOffset < 0)) {
HXLINE(1502)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN(1502)						if ((::hx::Mod(in_byteOffset,_this2->bytesPerElement) != 0)) {
HXLINE(1502)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN(1502)						int bufferByteLength = buffer->length;
HXDLIN(1502)						int elementSize1 = _this2->bytesPerElement;
HXDLIN(1502)						int newByteLength = bufferByteLength;
HXDLIN(1502)						if (::hx::IsNull( len )) {
HXLINE(1502)							newByteLength = (bufferByteLength - in_byteOffset);
HXDLIN(1502)							if ((::hx::Mod(bufferByteLength,_this2->bytesPerElement) != 0)) {
HXLINE(1502)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN(1502)							if ((newByteLength < 0)) {
HXLINE(1502)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE(1502)							newByteLength = (( (int)(len) ) * _this2->bytesPerElement);
HXDLIN(1502)							int newRange = (in_byteOffset + newByteLength);
HXDLIN(1502)							if ((newRange > bufferByteLength)) {
HXLINE(1502)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN(1502)						_this2->buffer = buffer;
HXDLIN(1502)						_this2->byteOffset = in_byteOffset;
HXDLIN(1502)						_this2->byteLength = newByteLength;
HXDLIN(1502)						_this2->length = ::Std_obj::_hx_int((( (Float)(newByteLength) ) / ( (Float)(_this2->bytesPerElement) )));
HXDLIN(1502)						this1 = _this2;
            					}
            					else {
HXLINE(1502)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8Array",6b,44,d5,85));
            					}
            				}
            			}
            		}
HXDLIN(1502)		imageBuffer = ( ( ::Dynamic)(imageBuffer1(::hx::DynamicPtr(bytes),::hx::DynamicPtr( ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,this1,null(),null(),null(),null())))) );
HXLINE(1512)		if (::hx::IsNotNull( imageBuffer )) {
HXLINE(1514)			this->_hx___fromImageBuffer(imageBuffer);
HXLINE(1516)			if (::hx::IsNotNull( onload )) {
HXLINE(1518)				onload(::hx::ObjectPtr<OBJ_>(this));
            			}
HXLINE(1521)			return true;
            		}
HXLINE(1527)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Image_obj,_hx___fromBytes,return )

bool Image_obj::_hx___fromFile(::String path, ::Dynamic onload, ::Dynamic onerror){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1531___fromFile)
HXLINE(1620)		 ::lime::graphics::ImageBuffer buffer = null();
HXLINE(1625)		if (::lime::_hx_system::CFFI_obj::enabled) {
HXLINE(1628)			::cpp::Function<  ::hx::Object *  ( ::hx::Object *, ::hx::Object *) > buffer1 = ::lime::_internal::backend::native::NativeCFFI_obj::lime_image_load_file;
HXDLIN(1628)			 ::Dynamic elements = null();
HXDLIN(1628)			 ::haxe::io::Bytes buffer2 = ::haxe::io::Bytes_obj::alloc(0);
HXDLIN(1628)			::cpp::VirtualArray array = null();
HXDLIN(1628)			 ::lime::utils::ArrayBufferView view = null();
HXDLIN(1628)			 ::Dynamic len = null();
HXDLIN(1628)			 ::lime::utils::ArrayBufferView this1;
HXDLIN(1628)			if (::hx::IsNotNull( elements )) {
HXLINE(1628)				this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,4);
            			}
            			else {
HXLINE(1628)				if (::hx::IsNotNull( array )) {
HXLINE(1628)					 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1628)					_this->byteOffset = 0;
HXDLIN(1628)					_this->length = array->get_length();
HXDLIN(1628)					_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN(1628)					_this->buffer = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN(1628)					_this->copyFromArray(array,null());
HXDLIN(1628)					this1 = _this;
            				}
            				else {
HXLINE(1628)					if (::hx::IsNotNull( view )) {
HXLINE(1628)						 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1628)						 ::haxe::io::Bytes srcData = view->buffer;
HXDLIN(1628)						int srcLength = view->length;
HXDLIN(1628)						int srcByteOffset = view->byteOffset;
HXDLIN(1628)						int srcElementSize = view->bytesPerElement;
HXDLIN(1628)						int elementSize = _this1->bytesPerElement;
HXDLIN(1628)						if ((view->type == _this1->type)) {
HXLINE(1628)							int srcLength1 = srcData->length;
HXDLIN(1628)							int cloneLength = (srcLength1 - srcByteOffset);
HXDLIN(1628)							_this1->buffer = ::haxe::io::Bytes_obj::alloc(cloneLength);
HXDLIN(1628)							_this1->buffer->blit(0,srcData,srcByteOffset,cloneLength);
            						}
            						else {
HXLINE(1628)							HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            						}
HXDLIN(1628)						_this1->byteLength = (_this1->bytesPerElement * srcLength);
HXDLIN(1628)						_this1->byteOffset = 0;
HXDLIN(1628)						_this1->length = srcLength;
HXDLIN(1628)						this1 = _this1;
            					}
            					else {
HXLINE(1628)						if (::hx::IsNotNull( buffer2 )) {
HXLINE(1628)							 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1628)							int in_byteOffset = 0;
HXDLIN(1628)							if ((in_byteOffset < 0)) {
HXLINE(1628)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN(1628)							if ((::hx::Mod(in_byteOffset,_this2->bytesPerElement) != 0)) {
HXLINE(1628)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN(1628)							int bufferByteLength = buffer2->length;
HXDLIN(1628)							int elementSize1 = _this2->bytesPerElement;
HXDLIN(1628)							int newByteLength = bufferByteLength;
HXDLIN(1628)							if (::hx::IsNull( len )) {
HXLINE(1628)								newByteLength = (bufferByteLength - in_byteOffset);
HXDLIN(1628)								if ((::hx::Mod(bufferByteLength,_this2->bytesPerElement) != 0)) {
HXLINE(1628)									HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            								}
HXDLIN(1628)								if ((newByteLength < 0)) {
HXLINE(1628)									HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            								}
            							}
            							else {
HXLINE(1628)								newByteLength = (( (int)(len) ) * _this2->bytesPerElement);
HXDLIN(1628)								int newRange = (in_byteOffset + newByteLength);
HXDLIN(1628)								if ((newRange > bufferByteLength)) {
HXLINE(1628)									HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            								}
            							}
HXDLIN(1628)							_this2->buffer = buffer2;
HXDLIN(1628)							_this2->byteOffset = in_byteOffset;
HXDLIN(1628)							_this2->byteLength = newByteLength;
HXDLIN(1628)							_this2->length = ::Std_obj::_hx_int((( (Float)(newByteLength) ) / ( (Float)(_this2->bytesPerElement) )));
HXDLIN(1628)							this1 = _this2;
            						}
            						else {
HXLINE(1628)							HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8Array",6b,44,d5,85));
            						}
            					}
            				}
            			}
HXDLIN(1628)			buffer = ( ( ::Dynamic)(buffer1(::hx::DynamicPtr(path),::hx::DynamicPtr( ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,this1,null(),null(),null(),null())))) );
            		}
HXLINE(1674)		if (::hx::IsNotNull( buffer )) {
HXLINE(1676)			this->_hx___fromImageBuffer(buffer);
HXLINE(1678)			if (::hx::IsNotNull( onload )) {
HXLINE(1680)				onload(::hx::ObjectPtr<OBJ_>(this));
            			}
HXLINE(1683)			return true;
            		}
HXLINE(1689)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Image_obj,_hx___fromFile,return )

void Image_obj::_hx___fromImageBuffer( ::lime::graphics::ImageBuffer buffer){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1693___fromImageBuffer)
HXLINE(1694)		this->buffer = buffer;
HXLINE(1696)		if (::hx::IsNotNull( buffer )) {
HXLINE(1698)			if ((this->width == -1)) {
HXLINE(1700)				this->width = buffer->width;
            			}
HXLINE(1703)			if ((this->height == -1)) {
HXLINE(1705)				this->height = buffer->height;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,_hx___fromImageBuffer,(void))

 ::lime::math::Rectangle Image_obj::get_rect(){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1885_get_rect)
HXDLIN(1885)		return  ::lime::math::Rectangle_obj::__alloc( HX_CTX ,0,0,this->width,this->height);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_rect,return )

 ::Dynamic Image_obj::get_src(){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1897_get_src)
HXDLIN(1897)		return this->buffer->get_src();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_src,return )

bool Image_obj::get_transparent(){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1906_get_transparent)
HXLINE(1907)		if (::hx::IsNull( this->buffer )) {
HXLINE(1907)			return false;
            		}
HXLINE(1908)		return this->buffer->transparent;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_transparent,return )

 ::lime::graphics::Image Image_obj::fromBytes( ::haxe::io::Bytes bytes){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_652_fromBytes)
HXLINE( 653)		if (::hx::IsNull( bytes )) {
HXLINE( 653)			return null();
            		}
HXLINE( 654)		 ::lime::graphics::Image image =  ::lime::graphics::Image_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null());
HXLINE( 655)		if (image->_hx___fromBytes(bytes,null())) {
HXLINE( 657)			return image;
            		}
            		else {
HXLINE( 661)			return null();
            		}
HXLINE( 655)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,fromBytes,return )

 ::lime::graphics::Image Image_obj::fromFile(::String path){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_695_fromFile)
HXLINE( 696)		if (::hx::IsNull( path )) {
HXLINE( 696)			return null();
            		}
HXLINE( 697)		 ::lime::graphics::Image image =  ::lime::graphics::Image_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null());
HXLINE( 698)		if (image->_hx___fromFile(path,null(),null())) {
HXLINE( 700)			return image;
            		}
            		else {
HXLINE( 704)			return null();
            		}
HXLINE( 698)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,fromFile,return )

 ::lime::app::Future Image_obj::loadFromBytes( ::haxe::io::Bytes bytes){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::haxe::io::Bytes,bytes) HXARGC(0)
            		 ::lime::graphics::Image _hx_run(){
            			HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_997_loadFromBytes)
HXLINE( 997)			return ::lime::graphics::Image_obj::fromBytes(bytes);
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_941_loadFromBytes)
HXLINE( 942)		if (::hx::IsNull( bytes )) {
HXLINE( 942)			return ::lime::app::Future_obj::withValue(null());
            		}
HXLINE( 997)		return  ::lime::app::Future_obj::__alloc( HX_CTX , ::Dynamic(new _hx_Closure_0(bytes)),true);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,loadFromBytes,return )

 ::lime::app::Future Image_obj::loadFromFile(::String path){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		 ::lime::app::Future _hx_run( ::lime::graphics::Image image){
            			HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1056_loadFromFile)
HXLINE(1056)			if (::hx::IsNotNull( image )) {
HXLINE(1058)				return ::lime::app::Future_obj::withValue(image);
            			}
            			else {
HXLINE(1062)				return ::lime::app::Future_obj::withError(HX_("",00,00,00,00));
            			}
HXLINE(1056)			return null();
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1007_loadFromFile)
HXLINE(1008)		if (::hx::IsNull( path )) {
HXLINE(1008)			return ::lime::app::Future_obj::withValue(null());
            		}
HXLINE(1053)		 ::lime::net::_HTTPRequest_lime_graphics_Image request =  ::lime::net::_HTTPRequest_lime_graphics_Image_obj::__alloc( HX_CTX ,null());
HXLINE(1054)		return request->load(path)->then( ::Dynamic(new _hx_Closure_0()));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,loadFromFile,return )


::hx::ObjectPtr< Image_obj > Image_obj::__new( ::lime::graphics::ImageBuffer buffer,::hx::Null< int >  __o_offsetX,::hx::Null< int >  __o_offsetY,::hx::Null< int >  __o_width,::hx::Null< int >  __o_height, ::Dynamic color, ::lime::graphics::ImageType type) {
	::hx::ObjectPtr< Image_obj > __this = new Image_obj();
	__this->__construct(buffer,__o_offsetX,__o_offsetY,__o_width,__o_height,color,type);
	return __this;
}

::hx::ObjectPtr< Image_obj > Image_obj::__alloc(::hx::Ctx *_hx_ctx, ::lime::graphics::ImageBuffer buffer,::hx::Null< int >  __o_offsetX,::hx::Null< int >  __o_offsetY,::hx::Null< int >  __o_width,::hx::Null< int >  __o_height, ::Dynamic color, ::lime::graphics::ImageType type) {
	Image_obj *__this = (Image_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Image_obj), true, "lime.graphics.Image"));
	*(void **)__this = Image_obj::_hx_vtable;
	__this->__construct(buffer,__o_offsetX,__o_offsetY,__o_width,__o_height,color,type);
	return __this;
}

Image_obj::Image_obj()
{
}

void Image_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Image);
	HX_MARK_MEMBER_NAME(buffer,"buffer");
	HX_MARK_MEMBER_NAME(dirty,"dirty");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(offsetX,"offsetX");
	HX_MARK_MEMBER_NAME(offsetY,"offsetY");
	HX_MARK_MEMBER_NAME(rect,"rect");
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(version,"version");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_END_CLASS();
}

void Image_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(buffer,"buffer");
	HX_VISIT_MEMBER_NAME(dirty,"dirty");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(offsetX,"offsetX");
	HX_VISIT_MEMBER_NAME(offsetY,"offsetY");
	HX_VISIT_MEMBER_NAME(rect,"rect");
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(version,"version");
	HX_VISIT_MEMBER_NAME(width,"width");
}

::hx::Val Image_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"src") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_src() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"rect") ) { return ::hx::Val( inCallProp == ::hx::paccAlways ? get_rect() : rect ); }
		if (HX_FIELD_EQ(inName,"type") ) { return ::hx::Val( type ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dirty") ) { return ::hx::Val( dirty ); }
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { return ::hx::Val( buffer ); }
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"offsetX") ) { return ::hx::Val( offsetX ); }
		if (HX_FIELD_EQ(inName,"offsetY") ) { return ::hx::Val( offsetY ); }
		if (HX_FIELD_EQ(inName,"version") ) { return ::hx::Val( version ); }
		if (HX_FIELD_EQ(inName,"get_src") ) { return ::hx::Val( get_src_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"fillRect") ) { return ::hx::Val( fillRect_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_rect") ) { return ::hx::Val( get_rect_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__clipRect") ) { return ::hx::Val( _hx___clipRect_dyn() ); }
		if (HX_FIELD_EQ(inName,"__fromFile") ) { return ::hx::Val( _hx___fromFile_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"transparent") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_transparent() ); }
		if (HX_FIELD_EQ(inName,"__fromBytes") ) { return ::hx::Val( _hx___fromBytes_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_transparent") ) { return ::hx::Val( get_transparent_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__fromImageBuffer") ) { return ::hx::Val( _hx___fromImageBuffer_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Image_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"fromFile") ) { outValue = fromFile_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fromBytes") ) { outValue = fromBytes_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"loadFromFile") ) { outValue = loadFromFile_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"loadFromBytes") ) { outValue = loadFromBytes_dyn(); return true; }
	}
	return false;
}

::hx::Val Image_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"rect") ) { rect=inValue.Cast<  ::lime::math::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast<  ::lime::graphics::ImageType >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dirty") ) { dirty=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { buffer=inValue.Cast<  ::lime::graphics::ImageBuffer >(); return inValue; }
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"offsetX") ) { offsetX=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"offsetY") ) { offsetY=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"version") ) { version=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Image_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("buffer",00,bd,94,d0));
	outFields->push(HX_("dirty",12,50,d0,d9));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("offsetX",65,09,65,d7));
	outFields->push(HX_("offsetY",66,09,65,d7));
	outFields->push(HX_("rect",24,4d,a7,4b));
	outFields->push(HX_("src",e4,a6,57,00));
	outFields->push(HX_("transparent",52,2b,ba,22));
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("version",18,e7,f1,7c));
	outFields->push(HX_("width",06,b6,62,ca));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Image_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::lime::graphics::ImageBuffer */ ,(int)offsetof(Image_obj,buffer),HX_("buffer",00,bd,94,d0)},
	{::hx::fsBool,(int)offsetof(Image_obj,dirty),HX_("dirty",12,50,d0,d9)},
	{::hx::fsInt,(int)offsetof(Image_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsInt,(int)offsetof(Image_obj,offsetX),HX_("offsetX",65,09,65,d7)},
	{::hx::fsInt,(int)offsetof(Image_obj,offsetY),HX_("offsetY",66,09,65,d7)},
	{::hx::fsObject /*  ::lime::math::Rectangle */ ,(int)offsetof(Image_obj,rect),HX_("rect",24,4d,a7,4b)},
	{::hx::fsObject /*  ::lime::graphics::ImageType */ ,(int)offsetof(Image_obj,type),HX_("type",ba,f2,08,4d)},
	{::hx::fsInt,(int)offsetof(Image_obj,version),HX_("version",18,e7,f1,7c)},
	{::hx::fsInt,(int)offsetof(Image_obj,width),HX_("width",06,b6,62,ca)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Image_obj_sStaticStorageInfo = 0;
#endif

static ::String Image_obj_sMemberFields[] = {
	HX_("buffer",00,bd,94,d0),
	HX_("dirty",12,50,d0,d9),
	HX_("height",e7,07,4c,02),
	HX_("offsetX",65,09,65,d7),
	HX_("offsetY",66,09,65,d7),
	HX_("rect",24,4d,a7,4b),
	HX_("type",ba,f2,08,4d),
	HX_("version",18,e7,f1,7c),
	HX_("width",06,b6,62,ca),
	HX_("fillRect",47,45,b9,6c),
	HX_("__clipRect",34,03,a3,fb),
	HX_("__fromBytes",81,3b,4d,a0),
	HX_("__fromFile",26,10,c0,44),
	HX_("__fromImageBuffer",51,6e,ca,ca),
	HX_("get_rect",ad,08,62,cb),
	HX_("get_src",7b,6f,cc,26),
	HX_("get_transparent",e9,e2,9b,e3),
	::String(null()) };

::hx::Class Image_obj::__mClass;

static ::String Image_obj_sStaticFields[] = {
	HX_("fromBytes",a1,f2,20,72),
	HX_("fromFile",06,9d,87,a1),
	HX_("loadFromBytes",9b,c3,86,f4),
	HX_("loadFromFile",4c,89,f0,5a),
	::String(null())
};

void Image_obj::__register()
{
	Image_obj _hx_dummy;
	Image_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("lime.graphics.Image",91,28,c1,9c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Image_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Image_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Image_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Image_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Image_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Image_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace lime
} // end namespace graphics
