// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_LightProgram
#include <LightProgram.h>
#endif
#ifndef INCLUDED_Program
#include <Program.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeOpenGLRenderContext
#include <lime/_internal/backend/native/NativeOpenGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics__WebGLRenderContext_WebGLRenderContext_Impl_
#include <lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils__DataPointer_DataPointer_Impl_
#include <lime/utils/_DataPointer/DataPointer_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_2e47bea3b5a2fe42_23_new,"LightProgram","new",0x41670460,"LightProgram.new","LightProgram.hx",23,0x844fa710)
HX_LOCAL_STACK_FRAME(_hx_pos_2e47bea3b5a2fe42_60_getShaderVarLocations,"LightProgram","getShaderVarLocations",0xee8bd1b2,"LightProgram.getShaderVarLocations","LightProgram.hx",60,0x844fa710)
HX_LOCAL_STACK_FRAME(_hx_pos_2e47bea3b5a2fe42_84_render,"LightProgram","render",0xd10eb756,"LightProgram.render","LightProgram.hx",84,0x844fa710)

void LightProgram_obj::__construct( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl){
            	HX_STACKFRAME(&_hx_pos_2e47bea3b5a2fe42_23_new)
HXLINE(  24)		::String vertexSource = HX_("#version 300 es\n\n\t\t\t\tlayout (location = 0) in vec3 aPos;\n                 \n\t\t\t\tuniform mat4 model;\n\t\t\t\tuniform mat4 view;\n\t\t\t\tuniform mat4 proj;\n\n                void main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position =  proj * view * model * vec4(aPos, 1.0);\n                   \n\t\t\t\t}\n",25,c8,58,2b);
HXLINE(  39)		::String fragmentSource = HX_("#version 300 es\n\t\t\t\tprecision mediump float;\n\n                out vec4 FragColor;\n\n\t\t\t\tvoid main() \n\t\t\t\t{\n\t\t\t\t\tFragColor = vec4(1.0);\n\t\t\t\t}\n",50,62,4b,ea);
HXLINE(  50)		super::__construct(gl);
HXLINE(  51)		this->createGLSLProgram(vertexSource,fragmentSource);
HXLINE(  52)		this->getShaderVarLocations();
            	}

Dynamic LightProgram_obj::__CreateEmpty() { return new LightProgram_obj; }

void *LightProgram_obj::_hx_vtable = 0;

Dynamic LightProgram_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< LightProgram_obj > _hx_result = new LightProgram_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool LightProgram_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x051ee72e) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x051ee72e;
	} else {
		return inClassId==(int)0x12dc3730;
	}
}

void LightProgram_obj::getShaderVarLocations(){
            	HX_STACKFRAME(&_hx_pos_2e47bea3b5a2fe42_60_getShaderVarLocations)
HXLINE(  62)		this->_programVertexAttribute = this->_gl->getAttribLocation(this->_glProgram,HX_("aPos",b3,c7,5a,40));
HXLINE(  63)		this->_gl->enableVertexAttribArray(this->_programVertexAttribute);
HXLINE(  66)		this->_programModelUniform = this->_gl->getUniformLocation(this->_glProgram,HX_("model",a9,23,58,0c));
HXLINE(  67)		this->_programViewUniform = this->_gl->getUniformLocation(this->_glProgram,HX_("view",65,32,4f,4e));
HXLINE(  68)		this->_programProjectionUniform = this->_gl->getUniformLocation(this->_glProgram,HX_("proj",9d,c7,5e,4a));
            	}


HX_DEFINE_DYNAMIC_FUNC0(LightProgram_obj,getShaderVarLocations,(void))

void LightProgram_obj::render( ::Dynamic params){
            	HX_STACKFRAME(&_hx_pos_2e47bea3b5a2fe42_84_render)
HXLINE(  86)		::lime::graphics::_WebGLRenderContext::WebGLRenderContext_Impl__obj::uniformMatrix4fv(this->_gl,this->_programViewUniform,false,( ( ::lime::utils::ArrayBufferView)(params->__Field(HX_("viewMatrix",86,36,15,fd),::hx::paccDynamic)) ));
HXLINE(  88)		::lime::graphics::_WebGLRenderContext::WebGLRenderContext_Impl__obj::uniformMatrix4fv(this->_gl,this->_programProjectionUniform,false,( ( ::lime::utils::ArrayBufferView)(params->__Field(HX_("projectionMatrix",30,88,bb,d0),::hx::paccDynamic)) ));
HXLINE(  90)		::lime::graphics::_WebGLRenderContext::WebGLRenderContext_Impl__obj::uniformMatrix4fv(this->_gl,this->_programModelUniform,false,( ( ::lime::utils::ArrayBufferView)(params->__Field(HX_("modelMatrix",ca,72,9c,b1),::hx::paccDynamic)) ));
HXLINE(  93)		this->_gl->bindBuffer(this->_gl->ARRAY_BUFFER,( ( ::lime::graphics::opengl::GLObject)(params->__Field(HX_("vbo",c3,df,59,00),::hx::paccDynamic)) ));
HXLINE(  96)		int stride = 32;
HXLINE(  99)		{
HXLINE(  99)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext this1 = this->_gl;
HXDLIN(  99)			int indx = this->_programVertexAttribute;
HXDLIN(  99)			int type = this->_gl->FLOAT;
HXDLIN(  99)			this1->vertexAttribPointer(indx,3,type,false,stride,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt(0));
            		}
HXLINE( 100)		this->_gl->enableVertexAttribArray(0);
HXLINE( 103)		this->_gl->drawArrays(this->_gl->TRIANGLES,0,36);
            	}


HX_DEFINE_DYNAMIC_FUNC1(LightProgram_obj,render,(void))


::hx::ObjectPtr< LightProgram_obj > LightProgram_obj::__new( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl) {
	::hx::ObjectPtr< LightProgram_obj > __this = new LightProgram_obj();
	__this->__construct(gl);
	return __this;
}

::hx::ObjectPtr< LightProgram_obj > LightProgram_obj::__alloc(::hx::Ctx *_hx_ctx, ::lime::_internal::backend::native::NativeOpenGLRenderContext gl) {
	LightProgram_obj *__this = (LightProgram_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(LightProgram_obj), true, "LightProgram"));
	*(void **)__this = LightProgram_obj::_hx_vtable;
	__this->__construct(gl);
	return __this;
}

LightProgram_obj::LightProgram_obj()
{
}

::hx::Val LightProgram_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_programViewUniform") ) { return ::hx::Val( _programViewUniform ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"_programModelUniform") ) { return ::hx::Val( _programModelUniform ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"getShaderVarLocations") ) { return ::hx::Val( getShaderVarLocations_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"_programVertexAttribute") ) { return ::hx::Val( _programVertexAttribute ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"_programProjectionUniform") ) { return ::hx::Val( _programProjectionUniform ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val LightProgram_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 19:
		if (HX_FIELD_EQ(inName,"_programViewUniform") ) { _programViewUniform=inValue.Cast< int >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"_programModelUniform") ) { _programModelUniform=inValue.Cast< int >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"_programVertexAttribute") ) { _programVertexAttribute=inValue.Cast< int >(); return inValue; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"_programProjectionUniform") ) { _programProjectionUniform=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void LightProgram_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_programViewUniform",4a,15,90,24));
	outFields->push(HX_("_programProjectionUniform",a0,e6,07,53));
	outFields->push(HX_("_programModelUniform",30,60,b1,c1));
	outFields->push(HX_("_programVertexAttribute",93,99,82,ec));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo LightProgram_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(LightProgram_obj,_programViewUniform),HX_("_programViewUniform",4a,15,90,24)},
	{::hx::fsInt,(int)offsetof(LightProgram_obj,_programProjectionUniform),HX_("_programProjectionUniform",a0,e6,07,53)},
	{::hx::fsInt,(int)offsetof(LightProgram_obj,_programModelUniform),HX_("_programModelUniform",30,60,b1,c1)},
	{::hx::fsInt,(int)offsetof(LightProgram_obj,_programVertexAttribute),HX_("_programVertexAttribute",93,99,82,ec)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *LightProgram_obj_sStaticStorageInfo = 0;
#endif

static ::String LightProgram_obj_sMemberFields[] = {
	HX_("_programViewUniform",4a,15,90,24),
	HX_("_programProjectionUniform",a0,e6,07,53),
	HX_("_programModelUniform",30,60,b1,c1),
	HX_("_programVertexAttribute",93,99,82,ec),
	HX_("getShaderVarLocations",b2,9d,9b,44),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class LightProgram_obj::__mClass;

void LightProgram_obj::__register()
{
	LightProgram_obj _hx_dummy;
	LightProgram_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("LightProgram",6e,94,3d,1c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(LightProgram_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< LightProgram_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LightProgram_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LightProgram_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

