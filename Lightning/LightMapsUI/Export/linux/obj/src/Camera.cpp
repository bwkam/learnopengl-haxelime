// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Camera
#include <Camera.h>
#endif
#ifndef INCLUDED_lime_app_Application
#include <lime/app/Application.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_lime_app_Module
#include <lime/app/Module.h>
#endif
#ifndef INCLUDED_lime_math_Vector4
#include <lime/math/Vector4.h>
#endif
#ifndef INCLUDED_lime_ui_Window
#include <lime/ui/Window.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_26_init,"Camera","init",0x07750559,"Camera.init","Camera.hx",26,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_35_moveCamera,"Camera","moveCamera",0x2586e79f,"Camera.moveCamera","Camera.hx",35,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_63_onMouseMove,"Camera","onMouseMove",0x0bce7f8e,"Camera.onMouseMove","Camera.hx",63,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_5_boot,"Camera","boot",0x02d54e7b,"Camera.boot","Camera.hx",5,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_6_boot,"Camera","boot",0x02d54e7b,"Camera.boot","Camera.hx",6,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_7_boot,"Camera","boot",0x02d54e7b,"Camera.boot","Camera.hx",7,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_8_boot,"Camera","boot",0x02d54e7b,"Camera.boot","Camera.hx",8,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_12_boot,"Camera","boot",0x02d54e7b,"Camera.boot","Camera.hx",12,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_18_boot,"Camera","boot",0x02d54e7b,"Camera.boot","Camera.hx",18,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_19_boot,"Camera","boot",0x02d54e7b,"Camera.boot","Camera.hx",19,0xdbe9d119)
HX_LOCAL_STACK_FRAME(_hx_pos_7072c536837f8d29_20_boot,"Camera","boot",0x02d54e7b,"Camera.boot","Camera.hx",20,0xdbe9d119)

void Camera_obj::__construct() { }

Dynamic Camera_obj::__CreateEmpty() { return new Camera_obj; }

void *Camera_obj::_hx_vtable = 0;

Dynamic Camera_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Camera_obj > _hx_result = new Camera_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Camera_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4d6b7d85;
}

bool Camera_obj::moveLeft;

bool Camera_obj::moveRight;

bool Camera_obj::moveForward;

bool Camera_obj::moveBackward;

int Camera_obj::speed;

bool Camera_obj::firstMouse;

Float Camera_obj::lastX;

Float Camera_obj::lastY;

Float Camera_obj::xOffset;

Float Camera_obj::yOffset;

Float Camera_obj::sensitivity;

Float Camera_obj::yaw;

Float Camera_obj::pitch;

Float Camera_obj::fov;

 ::lime::math::Vector4 Camera_obj::pos;

 ::lime::math::Vector4 Camera_obj::front;

 ::lime::math::Vector4 Camera_obj::up;

void Camera_obj::init(){
            	HX_GC_STACKFRAME(&_hx_pos_7072c536837f8d29_26_init)
HXLINE(  27)		::Camera_obj::lastX = (( (Float)(::lime::app::Application_obj::current->_hx___window->_hx___width) ) / ( (Float)(2) ));
HXLINE(  28)		::Camera_obj::lastY = (( (Float)(::lime::app::Application_obj::current->_hx___window->_hx___height) ) / ( (Float)(2) ));
HXLINE(  29)		::Camera_obj::speed = 10;
HXLINE(  30)		::Camera_obj::pos =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)0.0),((Float)10.0),((Float)1.0));
HXLINE(  31)		::Camera_obj::front =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)0.0),((Float)-1.0),((Float)1.0));
HXLINE(  32)		::Camera_obj::up =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)1.0),((Float)0.0),((Float)1.0));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Camera_obj,init,(void))

void Camera_obj::moveCamera(Float delta){
            	HX_GC_STACKFRAME(&_hx_pos_7072c536837f8d29_35_moveCamera)
HXLINE(  36)		Float camSpeed = (( (Float)(10) ) * delta);
HXLINE(  37)		if (::Camera_obj::moveForward) {
HXLINE(  38)			 ::lime::math::Vector4 _this = ::Camera_obj::front;
HXDLIN(  38)			 ::lime::math::Vector4 tgt =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,_this->x,_this->y,_this->z,_this->w);
HXLINE(  39)			{
HXLINE(  39)				Float l = ::Math_obj::sqrt((((tgt->x * tgt->x) + (tgt->y * tgt->y)) + (tgt->z * tgt->z)));
HXDLIN(  39)				if ((l != 0)) {
HXLINE(  39)					 ::lime::math::Vector4 tgt1 = tgt;
HXDLIN(  39)					tgt1->x = (tgt1->x / l);
HXDLIN(  39)					 ::lime::math::Vector4 tgt2 = tgt;
HXDLIN(  39)					tgt2->y = (tgt2->y / l);
HXDLIN(  39)					 ::lime::math::Vector4 tgt3 = tgt;
HXDLIN(  39)					tgt3->z = (tgt3->z / l);
            				}
            			}
HXLINE(  40)			{
HXLINE(  40)				 ::lime::math::Vector4 tgt4 = tgt;
HXDLIN(  40)				tgt4->x = (tgt4->x * camSpeed);
HXDLIN(  40)				 ::lime::math::Vector4 tgt5 = tgt;
HXDLIN(  40)				tgt5->y = (tgt5->y * camSpeed);
HXDLIN(  40)				 ::lime::math::Vector4 tgt6 = tgt;
HXDLIN(  40)				tgt6->z = (tgt6->z * camSpeed);
            			}
HXLINE(  41)			 ::lime::math::Vector4 _this1 = ::Camera_obj::pos;
HXDLIN(  41)			 ::lime::math::Vector4 result = null();
HXDLIN(  41)			if (::hx::IsNull( result )) {
HXLINE(  41)				result =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN(  41)			{
HXLINE(  41)				result->x = (_this1->x + tgt->x);
HXDLIN(  41)				result->y = (_this1->y + tgt->y);
HXDLIN(  41)				result->z = (_this1->z + tgt->z);
            			}
HXDLIN(  41)			::Camera_obj::pos = result;
            		}
HXLINE(  43)		if (::Camera_obj::moveBackward) {
HXLINE(  44)			 ::lime::math::Vector4 _this2 = ::Camera_obj::front;
HXDLIN(  44)			 ::lime::math::Vector4 tgt7 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,_this2->x,_this2->y,_this2->z,_this2->w);
HXLINE(  45)			{
HXLINE(  45)				Float l1 = ::Math_obj::sqrt((((tgt7->x * tgt7->x) + (tgt7->y * tgt7->y)) + (tgt7->z * tgt7->z)));
HXDLIN(  45)				if ((l1 != 0)) {
HXLINE(  45)					 ::lime::math::Vector4 tgt8 = tgt7;
HXDLIN(  45)					tgt8->x = (tgt8->x / l1);
HXDLIN(  45)					 ::lime::math::Vector4 tgt9 = tgt7;
HXDLIN(  45)					tgt9->y = (tgt9->y / l1);
HXDLIN(  45)					 ::lime::math::Vector4 tgt10 = tgt7;
HXDLIN(  45)					tgt10->z = (tgt10->z / l1);
            				}
            			}
HXLINE(  46)			{
HXLINE(  46)				 ::lime::math::Vector4 tgt11 = tgt7;
HXDLIN(  46)				tgt11->x = (tgt11->x * camSpeed);
HXDLIN(  46)				 ::lime::math::Vector4 tgt12 = tgt7;
HXDLIN(  46)				tgt12->y = (tgt12->y * camSpeed);
HXDLIN(  46)				 ::lime::math::Vector4 tgt13 = tgt7;
HXDLIN(  46)				tgt13->z = (tgt13->z * camSpeed);
            			}
HXLINE(  47)			 ::lime::math::Vector4 _this3 = ::Camera_obj::pos;
HXDLIN(  47)			 ::lime::math::Vector4 result1 = null();
HXDLIN(  47)			if (::hx::IsNull( result1 )) {
HXLINE(  47)				result1 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN(  47)			{
HXLINE(  47)				result1->x = (_this3->x - tgt7->x);
HXDLIN(  47)				result1->y = (_this3->y - tgt7->y);
HXDLIN(  47)				result1->z = (_this3->z - tgt7->z);
            			}
HXDLIN(  47)			::Camera_obj::pos = result1;
            		}
HXLINE(  49)		if (::Camera_obj::moveLeft) {
HXLINE(  50)			 ::lime::math::Vector4 _this4 = ::Camera_obj::front;
HXDLIN(  50)			 ::lime::math::Vector4 a = ::Camera_obj::up;
HXDLIN(  50)			 ::lime::math::Vector4 result2 = null();
HXDLIN(  50)			if (::hx::IsNull( result2 )) {
HXLINE(  50)				result2 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN(  50)			{
HXLINE(  50)				Float ya = ((_this4->z * a->x) - (_this4->x * a->z));
HXDLIN(  50)				Float za = ((_this4->x * a->y) - (_this4->y * a->x));
HXDLIN(  50)				result2->x = ((_this4->y * a->z) - (_this4->z * a->y));
HXDLIN(  50)				result2->y = ya;
HXDLIN(  50)				result2->z = za;
            			}
HXDLIN(  50)			result2->w = ( (Float)(1) );
HXDLIN(  50)			 ::lime::math::Vector4 m = result2;
HXLINE(  51)			{
HXLINE(  51)				Float l2 = ::Math_obj::sqrt((((m->x * m->x) + (m->y * m->y)) + (m->z * m->z)));
HXDLIN(  51)				if ((l2 != 0)) {
HXLINE(  51)					 ::lime::math::Vector4 m1 = m;
HXDLIN(  51)					m1->x = (m1->x / l2);
HXDLIN(  51)					 ::lime::math::Vector4 m2 = m;
HXDLIN(  51)					m2->y = (m2->y / l2);
HXDLIN(  51)					 ::lime::math::Vector4 m3 = m;
HXDLIN(  51)					m3->z = (m3->z / l2);
            				}
            			}
HXLINE(  52)			{
HXLINE(  52)				 ::lime::math::Vector4 m4 = m;
HXDLIN(  52)				m4->x = (m4->x * camSpeed);
HXDLIN(  52)				 ::lime::math::Vector4 m5 = m;
HXDLIN(  52)				m5->y = (m5->y * camSpeed);
HXDLIN(  52)				 ::lime::math::Vector4 m6 = m;
HXDLIN(  52)				m6->z = (m6->z * camSpeed);
            			}
HXLINE(  53)			 ::lime::math::Vector4 _this5 = ::Camera_obj::pos;
HXDLIN(  53)			 ::lime::math::Vector4 result3 = null();
HXDLIN(  53)			if (::hx::IsNull( result3 )) {
HXLINE(  53)				result3 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN(  53)			{
HXLINE(  53)				result3->x = (_this5->x - m->x);
HXDLIN(  53)				result3->y = (_this5->y - m->y);
HXDLIN(  53)				result3->z = (_this5->z - m->z);
            			}
HXDLIN(  53)			::Camera_obj::pos = result3;
            		}
HXLINE(  55)		if (::Camera_obj::moveRight) {
HXLINE(  56)			 ::lime::math::Vector4 _this6 = ::Camera_obj::front;
HXDLIN(  56)			 ::lime::math::Vector4 a1 = ::Camera_obj::up;
HXDLIN(  56)			 ::lime::math::Vector4 result4 = null();
HXDLIN(  56)			if (::hx::IsNull( result4 )) {
HXLINE(  56)				result4 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN(  56)			{
HXLINE(  56)				Float ya1 = ((_this6->z * a1->x) - (_this6->x * a1->z));
HXDLIN(  56)				Float za1 = ((_this6->x * a1->y) - (_this6->y * a1->x));
HXDLIN(  56)				result4->x = ((_this6->y * a1->z) - (_this6->z * a1->y));
HXDLIN(  56)				result4->y = ya1;
HXDLIN(  56)				result4->z = za1;
            			}
HXDLIN(  56)			result4->w = ( (Float)(1) );
HXDLIN(  56)			 ::lime::math::Vector4 m7 = result4;
HXLINE(  57)			{
HXLINE(  57)				Float l3 = ::Math_obj::sqrt((((m7->x * m7->x) + (m7->y * m7->y)) + (m7->z * m7->z)));
HXDLIN(  57)				if ((l3 != 0)) {
HXLINE(  57)					 ::lime::math::Vector4 m8 = m7;
HXDLIN(  57)					m8->x = (m8->x / l3);
HXDLIN(  57)					 ::lime::math::Vector4 m9 = m7;
HXDLIN(  57)					m9->y = (m9->y / l3);
HXDLIN(  57)					 ::lime::math::Vector4 m10 = m7;
HXDLIN(  57)					m10->z = (m10->z / l3);
            				}
            			}
HXLINE(  58)			{
HXLINE(  58)				 ::lime::math::Vector4 m11 = m7;
HXDLIN(  58)				m11->x = (m11->x * camSpeed);
HXDLIN(  58)				 ::lime::math::Vector4 m12 = m7;
HXDLIN(  58)				m12->y = (m12->y * camSpeed);
HXDLIN(  58)				 ::lime::math::Vector4 m13 = m7;
HXDLIN(  58)				m13->z = (m13->z * camSpeed);
            			}
HXLINE(  59)			 ::lime::math::Vector4 _this7 = ::Camera_obj::pos;
HXDLIN(  59)			 ::lime::math::Vector4 result5 = null();
HXDLIN(  59)			if (::hx::IsNull( result5 )) {
HXLINE(  59)				result5 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN(  59)			{
HXLINE(  59)				result5->x = (_this7->x + m7->x);
HXDLIN(  59)				result5->y = (_this7->y + m7->y);
HXDLIN(  59)				result5->z = (_this7->z + m7->z);
            			}
HXDLIN(  59)			::Camera_obj::pos = result5;
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Camera_obj,moveCamera,(void))

void Camera_obj::onMouseMove(Float x,Float y){
            	HX_GC_STACKFRAME(&_hx_pos_7072c536837f8d29_63_onMouseMove)
HXLINE(  64)		if (::Camera_obj::firstMouse) {
HXLINE(  65)			::Camera_obj::lastX = x;
HXLINE(  66)			::Camera_obj::lastY = y;
HXLINE(  67)			::Camera_obj::firstMouse = false;
            		}
HXLINE(  69)		::Camera_obj::sensitivity = ((Float)0.1);
HXLINE(  70)		::Camera_obj::xOffset = (x - ::Camera_obj::lastX);
HXLINE(  71)		::Camera_obj::yOffset = (::Camera_obj::lastY - y);
HXLINE(  72)		::Camera_obj::lastX = x;
HXLINE(  73)		::Camera_obj::lastY = y;
HXLINE(  74)		 ::Dynamic _hx_tmp = ::hx::ClassOf< ::Camera >();
HXDLIN(  74)		::Camera_obj::xOffset = (::Camera_obj::xOffset * ::Camera_obj::sensitivity);
HXLINE(  75)		 ::Dynamic _hx_tmp1 = ::hx::ClassOf< ::Camera >();
HXDLIN(  75)		::Camera_obj::yOffset = (::Camera_obj::yOffset * ::Camera_obj::sensitivity);
HXLINE(  76)		 ::Dynamic _hx_tmp2 = ::hx::ClassOf< ::Camera >();
HXDLIN(  76)		::Camera_obj::yaw = (::Camera_obj::yaw + ::Camera_obj::xOffset);
HXLINE(  77)		 ::Dynamic _hx_tmp3 = ::hx::ClassOf< ::Camera >();
HXDLIN(  77)		::Camera_obj::pitch = (::Camera_obj::pitch + ::Camera_obj::yOffset);
HXLINE(  78)		if ((::Camera_obj::pitch > ((Float)89.0))) {
HXLINE(  79)			::Camera_obj::pitch = ((Float)89.0);
            		}
HXLINE(  80)		if ((::Camera_obj::pitch < ((Float)-89.0))) {
HXLINE(  81)			::Camera_obj::pitch = ((Float)-89.0);
            		}
HXLINE(  82)		 ::lime::math::Vector4 direction =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE(  83)		direction->x = (::Math_obj::cos(((::Camera_obj::yaw * ::Math_obj::PI) / ( (Float)(180) ))) * ::Math_obj::cos(((::Camera_obj::pitch * ::Math_obj::PI) / ( (Float)(180) ))));
HXLINE(  84)		direction->y = ::Math_obj::sin(((::Camera_obj::pitch * ::Math_obj::PI) / ( (Float)(180) )));
HXLINE(  85)		direction->z = (::Math_obj::sin(((::Camera_obj::yaw * ::Math_obj::PI) / ( (Float)(180) ))) * ::Math_obj::cos(((::Camera_obj::pitch * ::Math_obj::PI) / ( (Float)(180) ))));
HXLINE(  86)		{
HXLINE(  86)			Float l = ::Math_obj::sqrt((((direction->x * direction->x) + (direction->y * direction->y)) + (direction->z * direction->z)));
HXDLIN(  86)			if ((l != 0)) {
HXLINE(  86)				 ::lime::math::Vector4 direction1 = direction;
HXDLIN(  86)				direction1->x = (direction1->x / l);
HXDLIN(  86)				 ::lime::math::Vector4 direction2 = direction;
HXDLIN(  86)				direction2->y = (direction2->y / l);
HXDLIN(  86)				 ::lime::math::Vector4 direction3 = direction;
HXDLIN(  86)				direction3->z = (direction3->z / l);
            			}
            		}
HXLINE(  87)		::Camera_obj::front = direction;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Camera_obj,onMouseMove,(void))


Camera_obj::Camera_obj()
{
}

bool Camera_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"up") ) { outValue = ( up ); return true; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"yaw") ) { outValue = ( yaw ); return true; }
		if (HX_FIELD_EQ(inName,"fov") ) { outValue = ( fov ); return true; }
		if (HX_FIELD_EQ(inName,"pos") ) { outValue = ( pos ); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"init") ) { outValue = init_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { outValue = ( speed ); return true; }
		if (HX_FIELD_EQ(inName,"lastX") ) { outValue = ( lastX ); return true; }
		if (HX_FIELD_EQ(inName,"lastY") ) { outValue = ( lastY ); return true; }
		if (HX_FIELD_EQ(inName,"pitch") ) { outValue = ( pitch ); return true; }
		if (HX_FIELD_EQ(inName,"front") ) { outValue = ( front ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"xOffset") ) { outValue = ( xOffset ); return true; }
		if (HX_FIELD_EQ(inName,"yOffset") ) { outValue = ( yOffset ); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"moveLeft") ) { outValue = ( moveLeft ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"moveRight") ) { outValue = ( moveRight ); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"firstMouse") ) { outValue = ( firstMouse ); return true; }
		if (HX_FIELD_EQ(inName,"moveCamera") ) { outValue = moveCamera_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"moveForward") ) { outValue = ( moveForward ); return true; }
		if (HX_FIELD_EQ(inName,"sensitivity") ) { outValue = ( sensitivity ); return true; }
		if (HX_FIELD_EQ(inName,"onMouseMove") ) { outValue = onMouseMove_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"moveBackward") ) { outValue = ( moveBackward ); return true; }
	}
	return false;
}

bool Camera_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"up") ) { up=ioValue.Cast<  ::lime::math::Vector4 >(); return true; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"yaw") ) { yaw=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"fov") ) { fov=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"pos") ) { pos=ioValue.Cast<  ::lime::math::Vector4 >(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { speed=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"lastX") ) { lastX=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"lastY") ) { lastY=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"pitch") ) { pitch=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"front") ) { front=ioValue.Cast<  ::lime::math::Vector4 >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"xOffset") ) { xOffset=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"yOffset") ) { yOffset=ioValue.Cast< Float >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"moveLeft") ) { moveLeft=ioValue.Cast< bool >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"moveRight") ) { moveRight=ioValue.Cast< bool >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"firstMouse") ) { firstMouse=ioValue.Cast< bool >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"moveForward") ) { moveForward=ioValue.Cast< bool >(); return true; }
		if (HX_FIELD_EQ(inName,"sensitivity") ) { sensitivity=ioValue.Cast< Float >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"moveBackward") ) { moveBackward=ioValue.Cast< bool >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Camera_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Camera_obj_sStaticStorageInfo[] = {
	{::hx::fsBool,(void *) &Camera_obj::moveLeft,HX_("moveLeft",b8,73,67,ea)},
	{::hx::fsBool,(void *) &Camera_obj::moveRight,HX_("moveRight",0b,db,2a,a7)},
	{::hx::fsBool,(void *) &Camera_obj::moveForward,HX_("moveForward",b4,1a,47,be)},
	{::hx::fsBool,(void *) &Camera_obj::moveBackward,HX_("moveBackward",14,74,4e,bb)},
	{::hx::fsInt,(void *) &Camera_obj::speed,HX_("speed",87,97,69,81)},
	{::hx::fsBool,(void *) &Camera_obj::firstMouse,HX_("firstMouse",d5,5f,43,4a)},
	{::hx::fsFloat,(void *) &Camera_obj::lastX,HX_("lastX",42,01,bc,6f)},
	{::hx::fsFloat,(void *) &Camera_obj::lastY,HX_("lastY",43,01,bc,6f)},
	{::hx::fsFloat,(void *) &Camera_obj::xOffset,HX_("xOffset",2b,b6,e3,12)},
	{::hx::fsFloat,(void *) &Camera_obj::yOffset,HX_("yOffset",ec,2c,79,3c)},
	{::hx::fsFloat,(void *) &Camera_obj::sensitivity,HX_("sensitivity",1f,94,c5,49)},
	{::hx::fsFloat,(void *) &Camera_obj::yaw,HX_("yaw",af,25,5c,00)},
	{::hx::fsFloat,(void *) &Camera_obj::pitch,HX_("pitch",c0,bb,a0,c2)},
	{::hx::fsFloat,(void *) &Camera_obj::fov,HX_("fov",0d,c7,4d,00)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(void *) &Camera_obj::pos,HX_("pos",94,5d,55,00)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(void *) &Camera_obj::front,HX_("front",a9,18,8e,06)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(void *) &Camera_obj::up,HX_("up",5b,66,00,00)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Camera_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Camera_obj::moveLeft,"moveLeft");
	HX_MARK_MEMBER_NAME(Camera_obj::moveRight,"moveRight");
	HX_MARK_MEMBER_NAME(Camera_obj::moveForward,"moveForward");
	HX_MARK_MEMBER_NAME(Camera_obj::moveBackward,"moveBackward");
	HX_MARK_MEMBER_NAME(Camera_obj::speed,"speed");
	HX_MARK_MEMBER_NAME(Camera_obj::firstMouse,"firstMouse");
	HX_MARK_MEMBER_NAME(Camera_obj::lastX,"lastX");
	HX_MARK_MEMBER_NAME(Camera_obj::lastY,"lastY");
	HX_MARK_MEMBER_NAME(Camera_obj::xOffset,"xOffset");
	HX_MARK_MEMBER_NAME(Camera_obj::yOffset,"yOffset");
	HX_MARK_MEMBER_NAME(Camera_obj::sensitivity,"sensitivity");
	HX_MARK_MEMBER_NAME(Camera_obj::yaw,"yaw");
	HX_MARK_MEMBER_NAME(Camera_obj::pitch,"pitch");
	HX_MARK_MEMBER_NAME(Camera_obj::fov,"fov");
	HX_MARK_MEMBER_NAME(Camera_obj::pos,"pos");
	HX_MARK_MEMBER_NAME(Camera_obj::front,"front");
	HX_MARK_MEMBER_NAME(Camera_obj::up,"up");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Camera_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Camera_obj::moveLeft,"moveLeft");
	HX_VISIT_MEMBER_NAME(Camera_obj::moveRight,"moveRight");
	HX_VISIT_MEMBER_NAME(Camera_obj::moveForward,"moveForward");
	HX_VISIT_MEMBER_NAME(Camera_obj::moveBackward,"moveBackward");
	HX_VISIT_MEMBER_NAME(Camera_obj::speed,"speed");
	HX_VISIT_MEMBER_NAME(Camera_obj::firstMouse,"firstMouse");
	HX_VISIT_MEMBER_NAME(Camera_obj::lastX,"lastX");
	HX_VISIT_MEMBER_NAME(Camera_obj::lastY,"lastY");
	HX_VISIT_MEMBER_NAME(Camera_obj::xOffset,"xOffset");
	HX_VISIT_MEMBER_NAME(Camera_obj::yOffset,"yOffset");
	HX_VISIT_MEMBER_NAME(Camera_obj::sensitivity,"sensitivity");
	HX_VISIT_MEMBER_NAME(Camera_obj::yaw,"yaw");
	HX_VISIT_MEMBER_NAME(Camera_obj::pitch,"pitch");
	HX_VISIT_MEMBER_NAME(Camera_obj::fov,"fov");
	HX_VISIT_MEMBER_NAME(Camera_obj::pos,"pos");
	HX_VISIT_MEMBER_NAME(Camera_obj::front,"front");
	HX_VISIT_MEMBER_NAME(Camera_obj::up,"up");
};

#endif

::hx::Class Camera_obj::__mClass;

static ::String Camera_obj_sStaticFields[] = {
	HX_("moveLeft",b8,73,67,ea),
	HX_("moveRight",0b,db,2a,a7),
	HX_("moveForward",b4,1a,47,be),
	HX_("moveBackward",14,74,4e,bb),
	HX_("speed",87,97,69,81),
	HX_("firstMouse",d5,5f,43,4a),
	HX_("lastX",42,01,bc,6f),
	HX_("lastY",43,01,bc,6f),
	HX_("xOffset",2b,b6,e3,12),
	HX_("yOffset",ec,2c,79,3c),
	HX_("sensitivity",1f,94,c5,49),
	HX_("yaw",af,25,5c,00),
	HX_("pitch",c0,bb,a0,c2),
	HX_("fov",0d,c7,4d,00),
	HX_("pos",94,5d,55,00),
	HX_("front",a9,18,8e,06),
	HX_("up",5b,66,00,00),
	HX_("init",10,3b,bb,45),
	HX_("moveCamera",96,c0,ba,07),
	HX_("onMouseMove",b7,7e,f8,16),
	::String(null())
};

void Camera_obj::__register()
{
	Camera_obj _hx_dummy;
	Camera_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Camera",c5,ba,20,ec);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Camera_obj::__GetStatic;
	__mClass->mSetStaticField = &Camera_obj::__SetStatic;
	__mClass->mMarkFunc = Camera_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Camera_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Camera_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Camera_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Camera_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Camera_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Camera_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_7072c536837f8d29_5_boot)
HXDLIN(   5)		moveLeft = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_7072c536837f8d29_6_boot)
HXDLIN(   6)		moveRight = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_7072c536837f8d29_7_boot)
HXDLIN(   7)		moveForward = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_7072c536837f8d29_8_boot)
HXDLIN(   8)		moveBackward = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_7072c536837f8d29_12_boot)
HXDLIN(  12)		firstMouse = true;
            	}
{
            	HX_STACKFRAME(&_hx_pos_7072c536837f8d29_18_boot)
HXDLIN(  18)		yaw = ((Float)-90.0);
            	}
{
            	HX_STACKFRAME(&_hx_pos_7072c536837f8d29_19_boot)
HXDLIN(  19)		pitch = ((Float)0.0);
            	}
{
            	HX_STACKFRAME(&_hx_pos_7072c536837f8d29_20_boot)
HXDLIN(  20)		fov = ((Float)45.0);
            	}
}

