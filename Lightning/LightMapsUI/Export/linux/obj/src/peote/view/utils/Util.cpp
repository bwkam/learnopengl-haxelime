// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_peote_view_utils_Util
#include <peote/view/utils/Util.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_0ec05e9759fe5f9e_26_resolveFormulaCyclic,"peote.view.utils.Util","resolveFormulaCyclic",0x09875bbc,"peote.view.utils.Util.resolveFormulaCyclic","peote/view/utils/Util.hx",26,0xfbeedc58)
HX_LOCAL_STACK_FRAME(_hx_pos_0ec05e9759fe5f9e_39_resolveFormulaKey,"peote.view.utils.Util","resolveFormulaKey",0xd1302e7c,"peote.view.utils.Util.resolveFormulaKey","peote/view/utils/Util.hx",39,0xfbeedc58)
HX_LOCAL_STACK_FRAME(_hx_pos_0ec05e9759fe5f9e_67_resolveFormulaVars,"peote.view.utils.Util","resolveFormulaVars",0x403ac82f,"peote.view.utils.Util.resolveFormulaVars","peote/view/utils/Util.hx",67,0xfbeedc58)
namespace peote{
namespace view{
namespace utils{

void Util_obj::__construct() { }

Dynamic Util_obj::__CreateEmpty() { return new Util_obj; }

void *Util_obj::_hx_vtable = 0;

Dynamic Util_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Util_obj > _hx_result = new Util_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Util_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x24cec1a3;
}

void Util_obj::resolveFormulaCyclic( ::haxe::ds::StringMap formulas){
            	HX_GC_STACKFRAME(&_hx_pos_0ec05e9759fe5f9e_26_resolveFormulaCyclic)
HXLINE(  27)		::Array< ::String > resolved = ::Array_obj< ::String >::__new();
HXLINE(  28)		{
HXLINE(  28)			 ::Dynamic k = formulas->keys();
HXDLIN(  28)			while(( (bool)(k->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  28)				::String k1 = ( (::String)(k->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE(  30)				 ::Dynamic err = ::peote::view::utils::Util_obj::resolveFormulaKey(k1,formulas,resolved,null());
HXLINE(  31)				if (::hx::IsNotNull( err->__Field(HX_("errKey",3a,27,4d,51),::hx::paccDynamic) )) {
HXLINE(  31)					HX_STACK_DO_THROW(err);
            				}
            			}
            		}
HXLINE(  34)		{
HXLINE(  34)			 ::Dynamic k2 = formulas->keys();
HXDLIN(  34)			while(( (bool)(k2->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  34)				::String k3 = ( (::String)(k2->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE(  35)				 ::EReg _hx_tmp =  ::EReg_obj::__alloc( HX_CTX ,HX_("___:::___",84,be,54,ac),HX_("g",67,00,00,00));
HXDLIN(  35)				formulas->set(k3,_hx_tmp->replace(formulas->get_string(k3),HX_("",00,00,00,00)));
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Util_obj,resolveFormulaCyclic,(void))

 ::Dynamic Util_obj::resolveFormulaKey(::String key, ::haxe::ds::StringMap formulas,::Array< ::String > resolved,::Array< ::String > fromKeys){
            	HX_GC_STACKFRAME(&_hx_pos_0ec05e9759fe5f9e_39_resolveFormulaKey)
HXLINE(  40)		if (::hx::IsNull( fromKeys )) {
HXLINE(  40)			fromKeys = ::Array_obj< ::String >::__new(1)->init(0,key);
            		}
HXLINE(  41)		if (::hx::IsNull( resolved )) {
HXLINE(  41)			resolved = ::Array_obj< ::String >::__new(0);
            		}
HXLINE(  43)		::String formula = formulas->get_string(key);
HXLINE(  44)		if ((resolved->indexOf(key,null()) >= 0)) {
HXLINE(  44)			return  ::Dynamic(::hx::Anon_obj::Create(3)
            				->setFixed(0,HX_("formula",66,e7,3d,df),formula)
            				->setFixed(1,HX_("errKey",3a,27,4d,51),null())
            				->setFixed(2,HX_("errVar",82,7c,55,51),null()));
            		}
HXLINE(  47)		{
HXLINE(  47)			 ::Dynamic k = formulas->keys();
HXDLIN(  47)			while(( (bool)(k->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  47)				::String k1 = ( (::String)(k->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN(  47)				if ((k1 != key)) {
HXLINE(  49)					 ::EReg regexp =  ::EReg_obj::__alloc( HX_CTX ,((HX_("(^|.*?[^\\w.])",7f,c6,d6,57) + k1) + HX_("\\b.*?",bd,53,c7,39)),HX_("g",67,00,00,00));
HXLINE(  50)					if (regexp->match(formula)) {
HXLINE(  52)						if ((fromKeys->indexOf(k1,null()) >= 0)) {
HXLINE(  52)							return  ::Dynamic(::hx::Anon_obj::Create(3)
            								->setFixed(0,HX_("formula",66,e7,3d,df),formula)
            								->setFixed(1,HX_("errKey",3a,27,4d,51),key)
            								->setFixed(2,HX_("errVar",82,7c,55,51),k1));
            						}
HXLINE(  54)						 ::Dynamic f = ::peote::view::utils::Util_obj::resolveFormulaKey(k1,formulas,resolved,fromKeys->concat(::Array_obj< ::String >::__new(1)->init(0,k1)));
HXLINE(  55)						if (::hx::IsNotNull( f->__Field(HX_("errKey",3a,27,4d,51),::hx::paccDynamic) )) {
HXLINE(  55)							return f;
            						}
HXLINE(  57)						formula = regexp->replace(formula,( (::String)(((HX_("$1(___:::___",29,6b,75,a1) + f->__Field(HX_("formula",66,e7,3d,df),::hx::paccDynamic)) + HX_("___:::___)",25,f5,d1,1d))) ));
            					}
            				}
            			}
            		}
HXLINE(  61)		formulas->set(key,formula);
HXLINE(  62)		resolved->push(key);
HXLINE(  63)		return  ::Dynamic(::hx::Anon_obj::Create(3)
            			->setFixed(0,HX_("formula",66,e7,3d,df),formula)
            			->setFixed(1,HX_("errKey",3a,27,4d,51),null())
            			->setFixed(2,HX_("errVar",82,7c,55,51),null()));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Util_obj,resolveFormulaKey,return )

void Util_obj::resolveFormulaVars( ::haxe::ds::StringMap formulas, ::haxe::ds::StringMap attribs){
            	HX_GC_STACKFRAME(&_hx_pos_0ec05e9759fe5f9e_67_resolveFormulaVars)
HXDLIN(  67)		 ::Dynamic key = formulas->keys();
HXDLIN(  67)		while(( (bool)(key->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXDLIN(  67)			::String key1 = ( (::String)(key->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE(  68)			::String formula = formulas->get_string(key1);
HXLINE(  69)			{
HXLINE(  69)				 ::Dynamic k = attribs->keys();
HXDLIN(  69)				while(( (bool)(k->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  69)					::String k1 = ( (::String)(k->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE(  70)					 ::EReg regexp =  ::EReg_obj::__alloc( HX_CTX ,((HX_("(^|.*?[^\\w.])",7f,c6,d6,57) + k1) + HX_("\\b.*?",bd,53,c7,39)),HX_("g",67,00,00,00));
HXLINE(  71)					if (regexp->match(formula)) {
HXLINE(  72)						formula = regexp->replace(formula,((HX_("$1(",fb,7b,1b,00) + attribs->get(k1)) + HX_(")",29,00,00,00)));
            					}
            				}
            			}
HXLINE(  74)			formulas->set(key1,formula);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Util_obj,resolveFormulaVars,(void))


Util_obj::Util_obj()
{
}

bool Util_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 17:
		if (HX_FIELD_EQ(inName,"resolveFormulaKey") ) { outValue = resolveFormulaKey_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"resolveFormulaVars") ) { outValue = resolveFormulaVars_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"resolveFormulaCyclic") ) { outValue = resolveFormulaCyclic_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Util_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Util_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Util_obj::__mClass;

static ::String Util_obj_sStaticFields[] = {
	HX_("resolveFormulaCyclic",f3,1d,10,fe),
	HX_("resolveFormulaKey",e5,f3,77,3f),
	HX_("resolveFormulaVars",a6,be,bf,50),
	::String(null())
};

void Util_obj::__register()
{
	Util_obj _hx_dummy;
	Util_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("peote.view.utils.Util",45,99,a2,05);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Util_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Util_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Util_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Util_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Util_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace peote
} // end namespace view
} // end namespace utils
