// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeOpenGLRenderContext
#include <lime/_internal/backend/native/NativeOpenGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_peote_view_ActiveTexture
#include <peote/view/ActiveTexture.h>
#endif
#ifndef INCLUDED_peote_view_BufferInterface
#include <peote/view/BufferInterface.h>
#endif
#ifndef INCLUDED_peote_view_Display
#include <peote/view/Display.h>
#endif
#ifndef INCLUDED_peote_view_Precision
#include <peote/view/Precision.h>
#endif
#ifndef INCLUDED_peote_view_Program
#include <peote/view/Program.h>
#endif
#ifndef INCLUDED_peote_view_Texture
#include <peote/view/Texture.h>
#endif
#ifndef INCLUDED_peote_view_UniformFloat
#include <peote/view/UniformFloat.h>
#endif
#ifndef INCLUDED_peote_view_Version
#include <peote/view/Version.h>
#endif
#ifndef INCLUDED_peote_view__TextureData_TextureDataImpl
#include <peote/view/_TextureData/TextureDataImpl.h>
#endif
#ifndef INCLUDED_peote_view_utils_GLTool
#include <peote/view/utils/GLTool.h>
#endif
#ifndef INCLUDED_peote_view_utils_RenderListItem_peote_view_ActiveTexture
#include <peote/view/utils/RenderListItem_peote_view_ActiveTexture.h>
#endif
#ifndef INCLUDED_peote_view_utils_RenderList_peote_view_ActiveTexture
#include <peote/view/utils/RenderList_peote_view_ActiveTexture.h>
#endif
#ifndef INCLUDED_peote_view_utils_RenderList_peote_view_Program
#include <peote/view/utils/RenderList_peote_view_Program.h>
#endif
#ifndef INCLUDED_peote_view_utils_TexUtils
#include <peote/view/utils/TexUtils.h>
#endif
#ifndef INCLUDED_peote_view_utils_Util
#include <peote/view/utils/Util.h>
#endif
#ifndef INCLUDED_utils_MultipassTemplate
#include <utils/MultipassTemplate.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_28_new,"peote.view.Program","new",0x799000d0,"peote.view.Program.new","peote/view/Program.hx",28,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_160_addToDisplay,"peote.view.Program","addToDisplay",0x8084c536,"peote.view.Program.addToDisplay","peote/view/Program.hx",160,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_263_createProg,"peote.view.Program","createProg",0x3ea84646,"peote.view.Program.createProg","peote/view/Program.hx",263,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_361_parseColorFormula,"peote.view.Program","parseColorFormula",0xebb3d186,"peote.view.Program.parseColorFormula","peote/view/Program.hx",361,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_456_setColorFormula,"peote.view.Program","setColorFormula",0x2645cb75,"peote.view.Program.setColorFormula","peote/view/Program.hx",456,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_476_injectIntoFragmentShader,"peote.view.Program","injectIntoFragmentShader",0xa685c056,"peote.view.Program.injectIntoFragmentShader","peote/view/Program.hx",476,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_484_generateUniformFloatsGLSL,"peote.view.Program","generateUniformFloatsGLSL",0x01377ca4,"peote.view.Program.generateUniformFloatsGLSL","peote/view/Program.hx",484,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_492_accumulateUniformsFloat,"peote.view.Program","accumulateUniformsFloat",0x89a421cb,"peote.view.Program.accumulateUniformsFloat","peote/view/Program.hx",492,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_541_parseAndResolveFormulas,"peote.view.Program","parseAndResolveFormulas",0x9872c9c5,"peote.view.Program.parseAndResolveFormulas","peote/view/Program.hx",541,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_552_parseAndResolveFormulas,"peote.view.Program","parseAndResolveFormulas",0x9872c9c5,"peote.view.Program.parseAndResolveFormulas","peote/view/Program.hx",552,0x6b0a9d00)
HX_LOCAL_STACK_FRAME(_hx_pos_2e0c77bf7c76f0ca_787_updateTextures,"peote.view.Program","updateTextures",0x1b8aaff1,"peote.view.Program.updateTextures","peote/view/Program.hx",787,0x6b0a9d00)
namespace peote{
namespace view{

void Program_obj::__construct(::Dynamic buffer){
            	HX_GC_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_28_new)
HXLINE( 357)		this->uniformFloats = ::Array_obj< ::Dynamic>::__new();
HXLINE( 355)		this->uniformFloatsFragment = null();
HXLINE( 354)		this->uniformFloatsVertex = null();
HXLINE( 235)		this->ready = false;
HXLINE( 121)		this->hasFragmentInjection = false;
HXLINE( 119)		this->fragmentFloatPrecision = null();
HXLINE( 117)		this->formulaHasChanged = false;
HXLINE( 116)		this->formula =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 115)		this->colorFormula = HX_("",00,00,00,00);
HXLINE( 111)		this->usedID_by_ColorFormula = 0;
HXLINE( 110)		this->used_by_ColorFormula = 0;
HXLINE( 109)		this->textureID_Defaults = ::Array_obj< ::Dynamic>::__new();
HXLINE( 108)		this->customTextureIdentifiers = ::Array_obj< ::String >::__new();
HXLINE( 101)		this->activeUnits = ::Array_obj< int >::__new();
HXLINE( 100)		this->activeTextures = ::Array_obj< ::Dynamic>::__new();
HXLINE(  99)		this->textureLayers =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  97)		this->textureListPicking =  ::peote::view::utils::RenderList_peote_view_ActiveTexture_obj::__alloc( HX_CTX , ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX ));
HXLINE(  96)		this->textureList =  ::peote::view::utils::RenderList_peote_view_ActiveTexture_obj::__alloc( HX_CTX , ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX ));
HXLINE(  54)		this->glShaderConfig =  ::Dynamic(::hx::Anon_obj::Create(33)
            			->setFixed(0,HX_("isINSTANCED",e5,c9,20,83),false)
            			->setFixed(1,HX_("hasTEXTURE_FUNCTIONS",dd,c5,41,84),false)
            			->setFixed(2,HX_("FRAGMENT_SAMPLER_PRECISION",58,54,68,88),null())
            			->setFixed(3,HX_("VERTEX_FLOAT_PRECISION",40,c3,a7,8e),null())
            			->setFixed(4,HX_("FORMULA_CONSTANTS",f6,30,e1,8e), ::Dynamic(::hx::Anon_obj::Create(0)))
            			->setFixed(5,HX_("TEXTURE_DEFAULTS",d6,cb,f2,92),::Array_obj< ::Dynamic>::__new(0))
            			->setFixed(6,HX_("POS_FORMULA",3b,a2,8b,99),null())
            			->setFixed(7,HX_("VERTEX_INJECTION",dc,0b,fe,ac),HX_("",00,00,00,00))
            			->setFixed(8,HX_("ROTZ_FORMULA",4a,8a,0c,ae),null())
            			->setFixed(9,HX_("FRAGMENT_INT_PRECISION",7f,0e,c8,ae),null())
            			->setFixed(10,HX_("VARIN",6c,3a,ab,af),HX_("varying",70,bc,7b,e7))
            			->setFixed(11,HX_("hasTEXTURES",92,b0,59,b8),false)
            			->setFixed(12,HX_("TEXTURES",38,87,54,bf),::Array_obj< ::Dynamic>::__new(0))
            			->setFixed(13,HX_("isES3",5b,16,4b,c1),false)
            			->setFixed(14,HX_("isUBO",b8,2b,57,c1),false)
            			->setFixed(15,HX_("FRAGMENT_FLOAT_PRECISION",ac,c3,74,ce),null())
            			->setFixed(16,HX_("VERTEX_INT_PRECISION",13,41,1a,d0),null())
            			->setFixed(17,HX_("FRAGMENT_INJECTION",48,b3,05,e2),HX_("",00,00,00,00))
            			->setFixed(18,HX_("FORMULA_VARYINGS",5c,59,a0,f6), ::Dynamic(::hx::Anon_obj::Create(0)))
            			->setFixed(19,HX_("VERTEX_SAMPLER_PRECISION",ec,60,09,fb),null())
            			->setFixed(20,HX_("PIVOT_FORMULA",69,09,71,fd),null())
            			->setFixed(21,HX_("IN",e5,3f,00,00),HX_("attribute",1c,70,f0,fa))
            			->setFixed(22,HX_("VAROUT",07,78,2c,06),HX_("varying",70,bc,7b,e7))
            			->setFixed(23,HX_("SIZE_FORMULA",88,a6,86,1e),null())
            			->setFixed(24,HX_("hasFRAGMENT_INJECTION",22,d1,a9,20),false)
            			->setFixed(25,HX_("isPICKING",d7,4f,13,2b),false)
            			->setFixed(26,HX_("PIXELDIVISOR",98,d3,99,2b),HX_("1.0",b3,56,25,00))
            			->setFixed(27,HX_("FRAGMENT_EXTENSIONS",63,3f,ba,2d),::Array_obj< ::Dynamic>::__new(0))
            			->setFixed(28,HX_("DISCARD",fe,ed,7d,32),HX_("0.0",72,94,24,00))
            			->setFixed(29,HX_("isPIXELSNAPPING",f8,93,3f,54),false)
            			->setFixed(30,HX_("FRAGMENT_CALC_LAYER",96,4e,b7,5b),HX_("",00,00,00,00))
            			->setFixed(31,HX_("isDISCARD",54,43,2b,69),true)
            			->setFixed(32,HX_("FRAGMENT_PROGRAM_UNIFORMS",c9,7d,2b,7c),HX_("",00,00,00,00)));
HXLINE(  50)		this->glFragmentShaderPicking = null();
HXLINE(  49)		this->glVertexShaderPicking = null();
HXLINE(  48)		this->glFragmentShader = null();
HXLINE(  47)		this->glVertexShader = null();
HXLINE(  46)		this->glProgramPicking = null();
HXLINE(  45)		this->glProgram = null();
HXLINE(  43)		this->gl = null();
HXLINE(  42)		this->displays = ::Array_obj< ::Dynamic>::__new();
HXLINE(  38)		this->isVisible = true;
HXLINE(  36)		this->autoUpdateTextures = true;
HXLINE(  34)		this->clearMask = false;
HXLINE(  33)		this->mask = 0;
HXLINE(  30)		this->colorEnabled = true;
HXLINE( 125)		this->buffer = buffer;
HXLINE( 126)		this->alphaEnabled = ::peote::view::BufferInterface_obj::hasAlpha(buffer);
HXLINE( 127)		this->zIndexEnabled = ::peote::view::BufferInterface_obj::hasZindex(buffer);
HXLINE( 129)		this->colorIdentifiers = ::peote::view::BufferInterface_obj::getColorIdentifiers(buffer);
HXLINE( 130)		this->customIdentifiers = ::peote::view::BufferInterface_obj::getCustomIdentifiers(buffer);
HXLINE( 131)		this->customVaryings = ::peote::view::BufferInterface_obj::getCustomVaryings(buffer);
HXLINE( 132)		this->textureIdentifiers = ::peote::view::BufferInterface_obj::getTextureIdentifiers(buffer);
HXLINE( 134)		this->defaultColorFormula = ::peote::view::BufferInterface_obj::getDefaultColorFormula(buffer);
HXLINE( 135)		this->defaultFormulaVars = ::peote::view::BufferInterface_obj::getDefaultFormulaVars(buffer);
HXLINE( 140)		{
HXLINE( 140)			 ::Dynamic k = ::peote::view::BufferInterface_obj::getFormulas(buffer)->keys();
HXDLIN( 140)			while(( (bool)(k->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 140)				::String k1 = ( (::String)(k->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 140)				 ::haxe::ds::StringMap _hx_tmp = this->formula;
HXDLIN( 140)				_hx_tmp->set(k1,::peote::view::BufferInterface_obj::getFormulas(buffer)->get(k1));
            			}
            		}
HXLINE( 145)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 145)			::peote::view::utils::Util_obj::resolveFormulaCyclic(::peote::view::BufferInterface_obj::getFormulas(buffer));
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE( 145)				 ::Dynamic e = _g;
HXDLIN( 145)				::String _hx_tmp1 = ((HX_("Error: cyclic reference of \"",07,aa,27,13) + ::Std_obj::string( ::Dynamic(e->__Field(HX_("errVar",82,7c,55,51),::hx::paccDynamic)))) + HX_("\" inside @formula \"",ce,1e,43,01));
HXDLIN( 145)				::String _hx_tmp2 = ((_hx_tmp1 + ::Std_obj::string( ::Dynamic(e->__Field(HX_("formula",66,e7,3d,df),::hx::paccDynamic)))) + HX_("\" for \"",cd,c8,d9,55));
HXDLIN( 145)				HX_STACK_DO_THROW(((_hx_tmp2 + ::Std_obj::string( ::Dynamic(e->__Field(HX_("errKey",3a,27,4d,51),::hx::paccDynamic)))) + HX_("\"",22,00,00,00)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 147)		 ::haxe::ds::StringMap _hx_tmp3 = ::peote::view::BufferInterface_obj::getFormulas(buffer);
HXDLIN( 147)		::peote::view::utils::Util_obj::resolveFormulaVars(_hx_tmp3,::peote::view::BufferInterface_obj::getAttributes(buffer));
HXLINE( 154)		this->parseColorFormula();
            	}

Dynamic Program_obj::__CreateEmpty() { return new Program_obj; }

void *Program_obj::_hx_vtable = 0;

Dynamic Program_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Program_obj > _hx_result = new Program_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Program_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x20e01034;
}

void Program_obj::addToDisplay( ::peote::view::Display display, ::peote::view::Program atProgram,::hx::Null< bool >  __o_addBefore){
            		bool addBefore = __o_addBefore.Default(false);
            	HX_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_160_addToDisplay)
HXLINE( 161)		if ((this->displays->indexOf(display,null()) < 0)) {
HXLINE( 165)			this->displays->push(display);
HXLINE( 166)			{
HXLINE( 166)				 ::lime::_internal::backend::native::NativeOpenGLRenderContext newGl = display->gl;
HXDLIN( 166)				bool _hx_tmp;
HXDLIN( 166)				if (::hx::IsNotNull( newGl )) {
HXLINE( 166)					_hx_tmp = ::hx::IsInstanceNotEq( newGl,this->gl );
            				}
            				else {
HXLINE( 166)					_hx_tmp = false;
            				}
HXDLIN( 166)				if (_hx_tmp) {
HXLINE( 166)					{
HXLINE( 166)						int _g = 0;
HXDLIN( 166)						::Array< ::Dynamic> _g1 = this->displays;
HXDLIN( 166)						while((_g < _g1->length)){
HXLINE( 166)							 ::peote::view::Display d = _g1->__get(_g).StaticCast<  ::peote::view::Display >();
HXDLIN( 166)							_g = (_g + 1);
HXDLIN( 166)							bool _hx_tmp1;
HXDLIN( 166)							if (::hx::IsNotNull( d->gl )) {
HXLINE( 166)								_hx_tmp1 = ::hx::IsInstanceNotEq( d->gl,newGl );
            							}
            							else {
HXLINE( 166)								_hx_tmp1 = false;
            							}
HXDLIN( 166)							if (_hx_tmp1) {
HXLINE( 166)								HX_STACK_DO_THROW(HX_("Error, program can not used inside different gl-contexts",ef,f8,25,08));
            							}
            						}
            					}
HXDLIN( 166)					if (::hx::IsNotNull( this->gl )) {
HXLINE( 166)						this->gl->deleteShader(this->glVertexShader);
HXDLIN( 166)						this->gl->deleteShader(this->glFragmentShader);
HXDLIN( 166)						this->gl->deleteProgram(this->glProgram);
HXDLIN( 166)						if (::peote::view::BufferInterface_obj::hasPicking(this->buffer)) {
HXLINE( 166)							this->gl->deleteShader(this->glVertexShaderPicking);
HXDLIN( 166)							this->gl->deleteShader(this->glFragmentShaderPicking);
HXDLIN( 166)							this->gl->deleteProgram(this->glProgramPicking);
            						}
            					}
HXDLIN( 166)					this->gl = newGl;
HXDLIN( 166)					if (::peote::view::Version_obj::isES3) {
HXLINE( 166)						this->glShaderConfig->__SetField(HX_("isES3",5b,16,4b,c1),true,::hx::paccDynamic);
HXDLIN( 166)						this->glShaderConfig->__SetField(HX_("IN",e5,3f,00,00),HX_("in",e5,5b,00,00),::hx::paccDynamic);
HXDLIN( 166)						this->glShaderConfig->__SetField(HX_("VARIN",6c,3a,ab,af),HX_("in",e5,5b,00,00),::hx::paccDynamic);
HXDLIN( 166)						this->glShaderConfig->__SetField(HX_("VAROUT",07,78,2c,06),HX_("out",8e,a0,54,00),::hx::paccDynamic);
            					}
HXDLIN( 166)					this->glShaderConfig->__SetField(HX_("FRAGMENT_EXTENSIONS",63,3f,ba,2d),::Array_obj< ::Dynamic>::__new(0),::hx::paccDynamic);
HXDLIN( 166)					if (::hx::IsNotNull( this->gl->getExtension(HX_("OES_standard_derivatives",8c,cb,00,04)) )) {
HXLINE( 166)						( (::Array< ::Dynamic>)(this->glShaderConfig->__Field(HX_("FRAGMENT_EXTENSIONS",63,3f,ba,2d),::hx::paccDynamic)) )->push( ::Dynamic(::hx::Anon_obj::Create(1)
            							->setFixed(0,HX_("EXTENSION",5f,03,69,e0),HX_("GL_OES_standard_derivatives",26,6c,66,da))));
            					}
HXDLIN( 166)					if (::hx::IsNotNull( this->gl->getExtension(HX_("EXT_color_buffer_float",b7,19,0b,dd)) )) {
HXLINE( 166)						( (::Array< ::Dynamic>)(this->glShaderConfig->__Field(HX_("FRAGMENT_EXTENSIONS",63,3f,ba,2d),::hx::paccDynamic)) )->push( ::Dynamic(::hx::Anon_obj::Create(1)
            							->setFixed(0,HX_("EXTENSION",5f,03,69,e0),HX_("EXT_color_buffer_float",b7,19,0b,dd))));
            					}
            					else {
HXLINE( 166)						if (::hx::IsNotNull( this->gl->getExtension(HX_("OES_texture_float",76,0b,21,02)) )) {
HXLINE( 166)							( (::Array< ::Dynamic>)(this->glShaderConfig->__Field(HX_("FRAGMENT_EXTENSIONS",63,3f,ba,2d),::hx::paccDynamic)) )->push( ::Dynamic(::hx::Anon_obj::Create(1)
            								->setFixed(0,HX_("EXTENSION",5f,03,69,e0),HX_("OES_texture_float",76,0b,21,02))));
            						}
            					}
HXDLIN( 166)					::peote::view::BufferInterface_obj::setNewGLContext(this->buffer,this->gl);
HXDLIN( 166)					{
HXLINE( 166)						this->createProg(null());
HXDLIN( 166)						if (::peote::view::BufferInterface_obj::hasPicking(this->buffer)) {
HXLINE( 166)							this->createProg(true);
            						}
            					}
HXDLIN( 166)					{
HXLINE( 166)						int _g2 = 0;
HXDLIN( 166)						::Array< ::Dynamic> _g3 = this->activeTextures;
HXDLIN( 166)						while((_g2 < _g3->length)){
HXLINE( 166)							 ::peote::view::Texture t = _g3->__get(_g2).StaticCast<  ::peote::view::Texture >();
HXDLIN( 166)							_g2 = (_g2 + 1);
HXDLIN( 166)							{
HXLINE( 166)								 ::lime::_internal::backend::native::NativeOpenGLRenderContext newGl1 = this->gl;
HXDLIN( 166)								bool _hx_tmp2;
HXDLIN( 166)								if (::hx::IsNotNull( newGl1 )) {
HXLINE( 166)									_hx_tmp2 = ::hx::IsInstanceNotEq( newGl1,t->gl );
            								}
            								else {
HXLINE( 166)									_hx_tmp2 = false;
            								}
HXDLIN( 166)								if (_hx_tmp2) {
HXLINE( 166)									{
HXLINE( 166)										int _g4 = 0;
HXDLIN( 166)										::Array< ::Dynamic> _g5 = t->programs;
HXDLIN( 166)										while((_g4 < _g5->length)){
HXLINE( 166)											 ::peote::view::Program p = _g5->__get(_g4).StaticCast<  ::peote::view::Program >();
HXDLIN( 166)											_g4 = (_g4 + 1);
HXDLIN( 166)											bool _hx_tmp3;
HXDLIN( 166)											if (::hx::IsNotNull( p->gl )) {
HXLINE( 166)												_hx_tmp3 = ::hx::IsInstanceNotEq( p->gl,newGl1 );
            											}
            											else {
HXLINE( 166)												_hx_tmp3 = false;
            											}
HXDLIN( 166)											if (_hx_tmp3) {
HXLINE( 166)												HX_STACK_DO_THROW(HX_("Error, texture can not used inside different gl-contexts",06,26,7d,73));
            											}
            										}
            									}
HXDLIN( 166)									{
HXLINE( 166)										int _g6 = 0;
HXDLIN( 166)										::Array< ::Dynamic> _g7 = t->displays;
HXDLIN( 166)										while((_g6 < _g7->length)){
HXLINE( 166)											 ::peote::view::Display d1 = _g7->__get(_g6).StaticCast<  ::peote::view::Display >();
HXDLIN( 166)											_g6 = (_g6 + 1);
HXDLIN( 166)											bool _hx_tmp4;
HXDLIN( 166)											if (::hx::IsNotNull( d1->gl )) {
HXLINE( 166)												_hx_tmp4 = ::hx::IsInstanceNotEq( d1->gl,newGl1 );
            											}
            											else {
HXLINE( 166)												_hx_tmp4 = false;
            											}
HXDLIN( 166)											if (_hx_tmp4) {
HXLINE( 166)												HX_STACK_DO_THROW(HX_("Error, texture can not used inside different gl-contexts",06,26,7d,73));
            											}
            										}
            									}
HXDLIN( 166)									if (::hx::IsNotNull( t->gl )) {
HXLINE( 166)										t->gl->deleteTexture(t->glTexture);
HXDLIN( 166)										t->glTexture = null();
HXDLIN( 166)										bool _hx_tmp5;
HXDLIN( 166)										if ((t->displays->length == 0)) {
HXLINE( 166)											_hx_tmp5 = ::hx::IsNotNull( t->framebuffer );
            										}
            										else {
HXLINE( 166)											_hx_tmp5 = false;
            										}
HXDLIN( 166)										if (_hx_tmp5) {
HXLINE( 166)											t->gl->deleteFramebuffer(t->framebuffer);
HXDLIN( 166)											t->framebuffer = null();
HXDLIN( 166)											if (::hx::IsNotNull( t->glDepthBuffer )) {
HXLINE( 166)												t->gl->deleteRenderbuffer(t->glDepthBuffer);
            											}
HXDLIN( 166)											t->glDepthBuffer = null();
            										}
            									}
HXDLIN( 166)									t->gl = newGl1;
HXDLIN( 166)									{
HXLINE( 166)										bool _hx_tmp6;
HXDLIN( 166)										int t1 = t->width;
HXDLIN( 166)										if (!(::hx::IsGreater( t1,t->gl->getParameter(t->gl->MAX_TEXTURE_SIZE) ))) {
HXLINE( 166)											int t2 = t->height;
HXDLIN( 166)											_hx_tmp6 = ::hx::IsGreater( t2,t->gl->getParameter(t->gl->MAX_TEXTURE_SIZE) );
            										}
            										else {
HXLINE( 166)											_hx_tmp6 = true;
            										}
HXDLIN( 166)										if (_hx_tmp6) {
HXLINE( 166)											HX_STACK_DO_THROW(HX_("Error, texture size is greater then gl.MAX_TEXTURE_SIZE",84,65,32,52));
            										}
HXDLIN( 166)										t->glTexture = ::peote::view::utils::TexUtils_obj::createEmptyTexture(t->gl,t->width,t->height,t->colorChannels,t->createMipmaps,t->magFilter,t->minFilter,t->useFloat);
            									}
HXDLIN( 166)									bool _hx_tmp7;
HXDLIN( 166)									if ((t->displays->length > 0)) {
HXLINE( 166)										_hx_tmp7 = ::hx::IsNull( t->framebuffer );
            									}
            									else {
HXLINE( 166)										_hx_tmp7 = false;
            									}
HXDLIN( 166)									if (_hx_tmp7) {
HXLINE( 166)										t->glDepthBuffer = t->gl->createRenderbuffer();
HXDLIN( 166)										 ::lime::_internal::backend::native::NativeOpenGLRenderContext gl = t->gl;
HXDLIN( 166)										 ::lime::graphics::opengl::GLObject texture = t->glTexture;
HXDLIN( 166)										 ::lime::graphics::opengl::GLObject depthBuffer = t->glDepthBuffer;
HXDLIN( 166)										int width = t->width;
HXDLIN( 166)										int height = t->height;
HXDLIN( 166)										 ::lime::graphics::opengl::GLObject framebuffer = gl->createFramebuffer();
HXDLIN( 166)										gl->bindRenderbuffer(gl->RENDERBUFFER,depthBuffer);
HXDLIN( 166)										::peote::view::utils::GLTool_obj::clearGlErrorQueue(gl);
HXDLIN( 166)										gl->renderbufferStorage(gl->RENDERBUFFER,gl->DEPTH_COMPONENT24,width,height);
HXDLIN( 166)										int _hx_tmp8 = ::peote::view::utils::GLTool_obj::getLastGlError(gl);
HXDLIN( 166)										if ((_hx_tmp8 == gl->INVALID_ENUM)) {
HXLINE( 166)											::haxe::Log_obj::trace(HX_("switching to DEPTH_COMPONENT16 for framebuffer",69,ed,16,03),::hx::SourceInfo(HX_("peote/view/utils/GLTool.hx",3d,2a,d3,ba),41,HX_("peote.view.utils.GLTool",00,20,8a,f7),HX_("createFramebuffer",51,ef,e8,cc)));
HXDLIN( 166)											gl->renderbufferStorage(gl->RENDERBUFFER,gl->DEPTH_COMPONENT16,width,height);
            										}
HXDLIN( 166)										gl->bindFramebuffer(gl->FRAMEBUFFER,framebuffer);
HXDLIN( 166)										gl->framebufferRenderbuffer(gl->FRAMEBUFFER,gl->DEPTH_ATTACHMENT,gl->RENDERBUFFER,depthBuffer);
HXDLIN( 166)										gl->framebufferTexture2D(gl->FRAMEBUFFER,gl->COLOR_ATTACHMENT0,gl->TEXTURE_2D,texture,0);
HXDLIN( 166)										int _hx_tmp9 = gl->checkFramebufferStatus(gl->FRAMEBUFFER);
HXDLIN( 166)										if ((_hx_tmp9 != gl->FRAMEBUFFER_COMPLETE)) {
HXLINE( 166)											HX_STACK_DO_THROW(HX_("Error: Framebuffer not complete!",5a,13,e6,19));
            										}
HXDLIN( 166)										gl->bindFramebuffer(gl->FRAMEBUFFER,null());
HXDLIN( 166)										gl->bindRenderbuffer(gl->RENDERBUFFER,null());
HXDLIN( 166)										t->framebuffer = framebuffer;
HXDLIN( 166)										t->updated = true;
            									}
HXDLIN( 166)									{
HXLINE( 166)										 ::Dynamic image = t->images->keys();
HXDLIN( 166)										while(( (bool)(image->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 166)											 ::peote::view::_TextureData::TextureDataImpl image1 = ( ( ::peote::view::_TextureData::TextureDataImpl)(image->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 166)											t->bufferImage(image1,t->images->get(image1));
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 172)		display->programList->add(::hx::ObjectPtr<OBJ_>(this),atProgram,addBefore);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Program_obj,addToDisplay,(void))

void Program_obj::createProg(::hx::Null< bool >  __o_isPicking){
            		bool isPicking = __o_isPicking.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_263_createProg)
HXLINE( 267)		bool _hx_tmp;
HXDLIN( 267)		if (isPicking) {
HXLINE( 267)			_hx_tmp = true;
            		}
            		else {
HXLINE( 267)			_hx_tmp = false;
            		}
HXDLIN( 267)		this->glShaderConfig->__SetField(HX_("isPICKING",d7,4f,13,2b),_hx_tmp,::hx::paccDynamic);
HXLINE( 269)		if (::hx::IsNotNull( this->fragmentFloatPrecision )) {
HXLINE( 269)			this->glShaderConfig->__SetField(HX_("FRAGMENT_FLOAT_PRECISION",ac,c3,74,ce),this->fragmentFloatPrecision,::hx::paccDynamic);
            		}
            		else {
HXLINE( 271)			bool _hx_tmp1;
HXDLIN( 271)			if (::peote::view::BufferInterface_obj::needFragmentPrecision(this->buffer)) {
HXLINE( 271)				_hx_tmp1 = ::hx::IsLess( ::peote::view::Precision_obj::FragmentFloat->__Field(HX_("medium",75,54,c8,fe),::hx::paccDynamic),23 );
            			}
            			else {
HXLINE( 271)				_hx_tmp1 = false;
            			}
HXDLIN( 271)			if (_hx_tmp1) {
HXLINE( 272)				 ::Dynamic t = ::peote::view::Precision_obj::FragmentFloat;
HXDLIN( 272)				::String _hx_tmp2;
HXDLIN( 272)				if (::hx::IsGreater( t->__Field(HX_("high",62,37,0e,45),::hx::paccDynamic),0 )) {
HXLINE( 272)					_hx_tmp2 = HX_("highp",ce,3e,62,27);
            				}
            				else {
HXLINE( 272)					if (::hx::IsGreater( t->__Field(HX_("medium",75,54,c8,fe),::hx::paccDynamic),0 )) {
HXLINE( 272)						_hx_tmp2 = HX_("mediump",5b,92,81,f0);
            					}
            					else {
HXLINE( 272)						if (::hx::IsGreater( t->__Field(HX_("low",94,54,52,00),::hx::paccDynamic),0 )) {
HXLINE( 272)							_hx_tmp2 = HX_("lowp",5c,ad,b7,47);
            						}
            						else {
HXLINE( 272)							_hx_tmp2 = null();
            						}
            					}
            				}
HXDLIN( 272)				this->glShaderConfig->__SetField(HX_("FRAGMENT_FLOAT_PRECISION",ac,c3,74,ce),_hx_tmp2,::hx::paccDynamic);
            			}
            			else {
HXLINE( 274)				 ::Dynamic t1 = ::peote::view::Precision_obj::FragmentFloat;
HXDLIN( 274)				::String _hx_tmp3;
HXDLIN( 274)				bool _hx_tmp4;
HXDLIN( 274)				if (::hx::IsGreater( t1->__Field(HX_("high",62,37,0e,45),::hx::paccDynamic),0 )) {
HXLINE( 274)					_hx_tmp4 = false;
            				}
            				else {
HXLINE( 274)					_hx_tmp4 = false;
            				}
HXDLIN( 274)				if (_hx_tmp4) {
HXLINE( 274)					_hx_tmp3 = HX_("highp",ce,3e,62,27);
            				}
            				else {
HXLINE( 274)					if (::hx::IsGreater( t1->__Field(HX_("medium",75,54,c8,fe),::hx::paccDynamic),0 )) {
HXLINE( 274)						_hx_tmp3 = HX_("mediump",5b,92,81,f0);
            					}
            					else {
HXLINE( 274)						if (::hx::IsGreater( t1->__Field(HX_("low",94,54,52,00),::hx::paccDynamic),0 )) {
HXLINE( 274)							_hx_tmp3 = HX_("lowp",5c,ad,b7,47);
            						}
            						else {
HXLINE( 274)							_hx_tmp3 = null();
            						}
            					}
            				}
HXDLIN( 274)				this->glShaderConfig->__SetField(HX_("FRAGMENT_FLOAT_PRECISION",ac,c3,74,ce),_hx_tmp3,::hx::paccDynamic);
            			}
            		}
HXLINE( 277)		this->parseAndResolveFormulas();
HXLINE( 279)		 ::lime::_internal::backend::native::NativeOpenGLRenderContext gl = this->gl;
HXDLIN( 279)		int type = this->gl->VERTEX_SHADER;
HXDLIN( 279)		::String shader = ::peote::view::BufferInterface_obj::getVertexShader(this->buffer);
HXDLIN( 279)		 ::Dynamic conf = this->glShaderConfig;
HXDLIN( 279)		 ::utils::MultipassTemplate _hx_template =  ::utils::MultipassTemplate_obj::__alloc( HX_CTX ,shader);
HXDLIN( 279)		 ::EReg shaderSrc = ::peote::view::utils::GLTool_obj::rStartspaces;
HXDLIN( 279)		 ::EReg shaderSrc1 = ::peote::view::utils::GLTool_obj::rEmptylines;
HXDLIN( 279)		::String shaderSrc2 = shaderSrc->replace(shaderSrc1->replace(_hx_template->execute(conf,null()),HX_("\n",0a,00,00,00)),HX_("",00,00,00,00));
HXDLIN( 279)		 ::lime::graphics::opengl::GLObject glShader = gl->createShader(type);
HXDLIN( 279)		gl->shaderSource(glShader,shaderSrc2);
HXDLIN( 279)		gl->compileShader(glShader);
HXDLIN( 279)		 ::lime::graphics::opengl::GLObject glVShader;
HXDLIN( 279)		if (::hx::IsEq( gl->getShaderParameter(glShader,gl->COMPILE_STATUS),0 )) {
HXLINE( 279)			::String glVShader1;
HXDLIN( 279)			if ((type == gl->VERTEX_SHADER)) {
HXLINE( 279)				glVShader1 = HX_("vertex",64,db,47,a1);
            			}
            			else {
HXLINE( 279)				glVShader1 = HX_("fragment",d0,5f,e5,ad);
            			}
HXDLIN( 279)			HX_STACK_DO_THROW((((HX_("ERROR compiling ",28,66,70,45) + glVShader1) + HX_(" shader\n",25,c5,d4,85)) + gl->getShaderInfoLog(glShader)));
            		}
            		else {
HXLINE( 279)			glVShader = glShader;
            		}
HXLINE( 280)		 ::lime::_internal::backend::native::NativeOpenGLRenderContext gl1 = this->gl;
HXDLIN( 280)		int type1 = this->gl->FRAGMENT_SHADER;
HXDLIN( 280)		::String shader1 = ::peote::view::BufferInterface_obj::getFragmentShader(this->buffer);
HXDLIN( 280)		 ::Dynamic conf1 = this->glShaderConfig;
HXDLIN( 280)		 ::utils::MultipassTemplate template1 =  ::utils::MultipassTemplate_obj::__alloc( HX_CTX ,shader1);
HXDLIN( 280)		 ::EReg shaderSrc3 = ::peote::view::utils::GLTool_obj::rStartspaces;
HXDLIN( 280)		 ::EReg shaderSrc4 = ::peote::view::utils::GLTool_obj::rEmptylines;
HXDLIN( 280)		::String shaderSrc5 = shaderSrc3->replace(shaderSrc4->replace(template1->execute(conf1,null()),HX_("\n",0a,00,00,00)),HX_("",00,00,00,00));
HXDLIN( 280)		 ::lime::graphics::opengl::GLObject glShader1 = gl1->createShader(type1);
HXDLIN( 280)		gl1->shaderSource(glShader1,shaderSrc5);
HXDLIN( 280)		gl1->compileShader(glShader1);
HXDLIN( 280)		 ::lime::graphics::opengl::GLObject glFShader;
HXDLIN( 280)		if (::hx::IsEq( gl1->getShaderParameter(glShader1,gl1->COMPILE_STATUS),0 )) {
HXLINE( 280)			::String glFShader1;
HXDLIN( 280)			if ((type1 == gl1->VERTEX_SHADER)) {
HXLINE( 280)				glFShader1 = HX_("vertex",64,db,47,a1);
            			}
            			else {
HXLINE( 280)				glFShader1 = HX_("fragment",d0,5f,e5,ad);
            			}
HXDLIN( 280)			HX_STACK_DO_THROW((((HX_("ERROR compiling ",28,66,70,45) + glFShader1) + HX_(" shader\n",25,c5,d4,85)) + gl1->getShaderInfoLog(glShader1)));
            		}
            		else {
HXLINE( 280)			glFShader = glShader1;
            		}
HXLINE( 282)		 ::lime::graphics::opengl::GLObject glProg = this->gl->createProgram();
HXLINE( 284)		this->gl->attachShader(glProg,glVShader);
HXLINE( 285)		this->gl->attachShader(glProg,glFShader);
HXLINE( 287)		::peote::view::BufferInterface_obj::bindAttribLocations(this->buffer,this->gl,glProg);
HXLINE( 289)		{
HXLINE( 289)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext gl2 = this->gl;
HXDLIN( 289)			gl2->linkProgram(glProg);
HXDLIN( 289)			if (::hx::IsEq( gl2->getProgramParameter(glProg,gl2->LINK_STATUS),0 )) {
HXLINE( 289)				::String _hx_tmp5 = (gl2->getProgramInfoLog(glProg) + HX_("VALIDATE_STATUS: ",61,4a,52,b0));
HXDLIN( 289)				::String _hx_tmp6 = ((_hx_tmp5 + ::Std_obj::string(gl2->getProgramParameter(glProg,gl2->VALIDATE_STATUS))) + HX_("ERROR: ",4e,70,de,69));
HXDLIN( 289)				HX_STACK_DO_THROW((_hx_tmp6 + gl2->getError()));
            			}
            		}
HXLINE( 291)		bool _hx_tmp7;
HXDLIN( 291)		if (!(isPicking)) {
HXLINE( 291)			_hx_tmp7 = false;
            		}
            		else {
HXLINE( 291)			_hx_tmp7 = false;
            		}
HXDLIN( 291)		if (_hx_tmp7) {
HXLINE( 293)			int index = this->gl->getUniformBlockIndex(glProg,HX_("uboView",07,65,eb,52));
HXLINE( 294)			if ((index != this->gl->INVALID_INDEX)) {
HXLINE( 294)				this->gl->uniformBlockBinding(glProg,index,0);
            			}
HXLINE( 295)			index = this->gl->getUniformBlockIndex(glProg,HX_("uboDisplay",e0,c8,ed,f7));
HXLINE( 296)			if ((index != this->gl->INVALID_INDEX)) {
HXLINE( 296)				this->gl->uniformBlockBinding(glProg,index,1);
            			}
            		}
            		else {
HXLINE( 300)			if (!(isPicking)) {
HXLINE( 301)				this->uRESOLUTION = this->gl->getUniformLocation(glProg,HX_("uResolution",01,3e,a1,49));
HXLINE( 302)				this->uZOOM = this->gl->getUniformLocation(glProg,HX_("uZoom",28,ae,b3,99));
HXLINE( 303)				this->uOFFSET = this->gl->getUniformLocation(glProg,HX_("uOffset",e8,51,23,96));
            			}
            			else {
HXLINE( 305)				this->uRESOLUTION_PICK = this->gl->getUniformLocation(glProg,HX_("uResolution",01,3e,a1,49));
HXLINE( 306)				this->uZOOM_PICK = this->gl->getUniformLocation(glProg,HX_("uZoom",28,ae,b3,99));
HXLINE( 307)				this->uOFFSET_PICK = this->gl->getUniformLocation(glProg,HX_("uOffset",e8,51,23,96));
            			}
            		}
HXLINE( 311)		if (!(isPicking)) {
HXLINE( 312)			this->uTIME = this->gl->getUniformLocation(glProg,HX_("uTime",22,d7,b7,95));
HXLINE( 313)			this->uniformFloatLocations = ::Array_obj< int >::__new();
HXLINE( 314)			{
HXLINE( 314)				int _g = 0;
HXDLIN( 314)				::Array< ::Dynamic> _g1 = this->uniformFloats;
HXDLIN( 314)				while((_g < _g1->length)){
HXLINE( 314)					 ::peote::view::UniformFloat u = _g1->__get(_g).StaticCast<  ::peote::view::UniformFloat >();
HXDLIN( 314)					_g = (_g + 1);
HXDLIN( 314)					::Array< int > _hx_tmp8 = this->uniformFloatLocations;
HXDLIN( 314)					_hx_tmp8->push(this->gl->getUniformLocation(glProg,u->name));
            				}
            			}
            		}
            		else {
HXLINE( 317)			this->uTIME_PICK = this->gl->getUniformLocation(glProg,HX_("uTime",22,d7,b7,95));
HXLINE( 318)			this->uniformFloatPickLocations = ::Array_obj< int >::__new();
HXLINE( 319)			{
HXLINE( 319)				int _g2 = 0;
HXDLIN( 319)				::Array< ::Dynamic> _g3 = this->uniformFloats;
HXDLIN( 319)				while((_g2 < _g3->length)){
HXLINE( 319)					 ::peote::view::UniformFloat u1 = _g3->__get(_g2).StaticCast<  ::peote::view::UniformFloat >();
HXDLIN( 319)					_g2 = (_g2 + 1);
HXDLIN( 319)					::Array< int > _hx_tmp9 = this->uniformFloatPickLocations;
HXDLIN( 319)					_hx_tmp9->push(this->gl->getUniformLocation(glProg,u1->name));
            				}
            			}
            		}
HXLINE( 322)		if (!(isPicking)) {
HXLINE( 324)			this->textureList->clear();
HXLINE( 325)			{
HXLINE( 325)				int _g4 = 0;
HXDLIN( 325)				int _g5 = this->activeTextures->length;
HXDLIN( 325)				while((_g4 < _g5)){
HXLINE( 325)					_g4 = (_g4 + 1);
HXDLIN( 325)					int i = (_g4 - 1);
HXLINE( 326)					 ::peote::view::utils::RenderList_peote_view_ActiveTexture _hx_tmp10 = this->textureList;
HXDLIN( 326)					int _hx_tmp11 = this->activeUnits->__get(i);
HXDLIN( 326)					 ::peote::view::Texture _hx_tmp12 = this->activeTextures->__get(i).StaticCast<  ::peote::view::Texture >();
HXDLIN( 326)					_hx_tmp10->add( ::peote::view::ActiveTexture_obj::__alloc( HX_CTX ,_hx_tmp11,_hx_tmp12,this->gl->getUniformLocation(glProg,(HX_("uTexture",e6,18,40,90) + i))),null(),false);
            				}
            			}
HXLINE( 328)			this->glProgram = glProg;
HXLINE( 329)			this->glVertexShader = glVShader;
HXLINE( 330)			this->glFragmentShader = glFShader;
            		}
            		else {
HXLINE( 333)			this->textureListPicking->clear();
HXLINE( 334)			{
HXLINE( 334)				int _g6 = 0;
HXDLIN( 334)				int _g7 = this->activeTextures->length;
HXDLIN( 334)				while((_g6 < _g7)){
HXLINE( 334)					_g6 = (_g6 + 1);
HXDLIN( 334)					int i1 = (_g6 - 1);
HXLINE( 335)					 ::peote::view::utils::RenderList_peote_view_ActiveTexture _hx_tmp13 = this->textureListPicking;
HXDLIN( 335)					int _hx_tmp14 = this->activeUnits->__get(i1);
HXDLIN( 335)					 ::peote::view::Texture _hx_tmp15 = this->activeTextures->__get(i1).StaticCast<  ::peote::view::Texture >();
HXDLIN( 335)					_hx_tmp13->add( ::peote::view::ActiveTexture_obj::__alloc( HX_CTX ,_hx_tmp14,_hx_tmp15,this->gl->getUniformLocation(glProg,(HX_("uTexture",e6,18,40,90) + i1))),null(),false);
            				}
            			}
HXLINE( 337)			this->glProgramPicking = glProg;
HXLINE( 338)			this->glVertexShaderPicking = glVShader;
HXLINE( 339)			this->glFragmentShaderPicking = glFShader;
            		}
HXLINE( 341)		this->ready = true;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Program_obj,createProg,(void))

void Program_obj::parseColorFormula(){
            	HX_GC_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_361_parseColorFormula)
HXLINE( 362)		::String formula = HX_("",00,00,00,00);
HXLINE( 364)		if ((this->colorFormula != HX_("",00,00,00,00))) {
HXLINE( 364)			formula = this->colorFormula;
            		}
            		else {
HXLINE( 365)			if ((this->defaultColorFormula != HX_("",00,00,00,00))) {
HXLINE( 365)				formula = this->defaultColorFormula;
            			}
            			else {
HXLINE( 367)				::Array< ::String > col = this->colorIdentifiers->copy();
HXLINE( 368)				::Array< ::String > tex = ::Array_obj< ::String >::__new();
HXLINE( 369)				{
HXLINE( 369)					int _g = 0;
HXDLIN( 369)					int _g1 = this->textureIdentifiers->length;
HXDLIN( 369)					while((_g < _g1)){
HXLINE( 369)						_g = (_g + 1);
HXDLIN( 369)						int i = (_g - 1);
HXLINE( 370)						if (this->textureLayers->exists(i)) {
HXLINE( 370)							tex->push(this->textureIdentifiers->__get(i));
            						}
            					}
            				}
HXLINE( 371)				{
HXLINE( 371)					int _g2 = 0;
HXDLIN( 371)					int _g3 = this->customTextureIdentifiers->length;
HXDLIN( 371)					while((_g2 < _g3)){
HXLINE( 371)						_g2 = (_g2 + 1);
HXDLIN( 371)						int i1 = (_g2 - 1);
HXLINE( 372)						if (this->textureLayers->exists((this->textureIdentifiers->length + i1))) {
HXLINE( 372)							tex->push(this->customTextureIdentifiers->__get(i1));
            						}
            					}
            				}
HXLINE( 375)				if (((col->length + tex->length) == 0)) {
HXLINE( 375)					int this1 = -16776961;
HXDLIN( 375)					::String s = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this1 >> 24) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 375)					::String formula1;
HXDLIN( 375)					bool formula2;
HXDLIN( 375)					if ((s.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 375)						formula2 = (s.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            					}
            					else {
HXLINE( 375)						formula2 = true;
            					}
HXDLIN( 375)					if (formula2) {
HXLINE( 375)						formula1 = s;
            					}
            					else {
HXLINE( 375)						formula1 = (s + HX_(".0",42,28,00,00));
            					}
HXDLIN( 375)					::String s1 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this1 >> 16) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 375)					::String formula3;
HXDLIN( 375)					bool formula4;
HXDLIN( 375)					if ((s1.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 375)						formula4 = (s1.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            					}
            					else {
HXLINE( 375)						formula4 = true;
            					}
HXDLIN( 375)					if (formula4) {
HXLINE( 375)						formula3 = s1;
            					}
            					else {
HXLINE( 375)						formula3 = (s1 + HX_(".0",42,28,00,00));
            					}
HXDLIN( 375)					::String s2 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this1 >> 8) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 375)					::String formula5;
HXDLIN( 375)					bool formula6;
HXDLIN( 375)					if ((s2.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 375)						formula6 = (s2.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            					}
            					else {
HXLINE( 375)						formula6 = true;
            					}
HXDLIN( 375)					if (formula6) {
HXLINE( 375)						formula5 = s2;
            					}
            					else {
HXLINE( 375)						formula5 = (s2 + HX_(".0",42,28,00,00));
            					}
HXDLIN( 375)					::String s3 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)((this1 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 375)					::String formula7;
HXDLIN( 375)					bool formula8;
HXDLIN( 375)					if ((s3.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 375)						formula8 = (s3.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            					}
            					else {
HXLINE( 375)						formula8 = true;
            					}
HXDLIN( 375)					if (formula8) {
HXLINE( 375)						formula7 = s3;
            					}
            					else {
HXLINE( 375)						formula7 = (s3 + HX_(".0",42,28,00,00));
            					}
HXDLIN( 375)					formula = (((((HX_("vec4(",c8,4c,56,34) + formula1) + HX_(", ",74,26,00,00)) + formula3) + HX_(",",2c,00,00,00)) + ((((HX_(" ",20,00,00,00) + formula5) + HX_(", ",74,26,00,00)) + formula7) + HX_(")",29,00,00,00)));
            				}
            				else {
HXLINE( 377)					if ((tex->length > 0)) {
HXLINE( 378)						formula = ( (::String)(tex->shift()) );
HXLINE( 379)						if ((col->length > 0)) {
HXLINE( 379)							formula = (((HX_("",00,00,00,00) + col->shift()) + HX_(" * ",d6,6c,18,00)) + formula);
            						}
            					}
HXLINE( 381)					{
HXLINE( 381)						int _g4 = 0;
HXDLIN( 381)						while((_g4 < tex->length)){
HXLINE( 381)							::String t = tex->__get(_g4);
HXDLIN( 381)							_g4 = (_g4 + 1);
HXLINE( 382)							if ((col->length > 0)) {
HXLINE( 382)								t = ((((HX_("",00,00,00,00) + col->shift()) + HX_(" * ",d6,6c,18,00)) + t) + HX_(" ",20,00,00,00));
            							}
HXLINE( 383)							formula = ((((((HX_("mix( ",94,d3,6f,08) + formula) + HX_(", ",74,26,00,00)) + t) + HX_(", (",34,7f,21,00)) + t) + HX_(").a )",e5,4f,1f,ba));
            						}
            					}
HXLINE( 386)					while((col->length > 0)){
HXLINE( 387)						::String formula9;
HXDLIN( 387)						if ((formula != HX_("",00,00,00,00))) {
HXLINE( 387)							formula9 = HX_("*",2a,00,00,00);
            						}
            						else {
HXLINE( 387)							formula9 = HX_("",00,00,00,00);
            						}
HXDLIN( 387)						formula = (formula + (formula9 + col->shift()));
HXLINE( 388)						if ((col->length > 0)) {
HXLINE( 388)							formula = ((((HX_("(",28,00,00,00) + formula) + HX_(" + ",b5,6d,18,00)) + col->shift()) + HX_(")",29,00,00,00));
            						}
            					}
            				}
            			}
            		}
HXLINE( 394)		{
HXLINE( 394)			int _g5 = 0;
HXDLIN( 394)			int _g6 = this->colorIdentifiers->length;
HXDLIN( 394)			while((_g5 < _g6)){
HXLINE( 394)				_g5 = (_g5 + 1);
HXDLIN( 394)				int i2 = (_g5 - 1);
HXLINE( 395)				 ::EReg regexp =  ::EReg_obj::__alloc( HX_CTX ,((HX_("(^|.*?[^\\w.])",7f,c6,d6,57) + this->colorIdentifiers->__get(i2)) + HX_("\\b.*?",bd,53,c7,39)),HX_("g",67,00,00,00));
HXLINE( 396)				if (regexp->match(formula)) {
HXLINE( 397)					formula = regexp->replace(formula,((HX_("$1",8d,1f,00,00) + HX_("c",63,00,00,00)) + i2));
            				}
            			}
            		}
HXLINE( 399)		{
HXLINE( 399)			int _g7 = 0;
HXDLIN( 399)			int _g8 = this->customIdentifiers->length;
HXDLIN( 399)			while((_g7 < _g8)){
HXLINE( 399)				_g7 = (_g7 + 1);
HXDLIN( 399)				int i3 = (_g7 - 1);
HXLINE( 400)				 ::EReg regexp1 =  ::EReg_obj::__alloc( HX_CTX ,((HX_("(^|.*?[^\\w.])",7f,c6,d6,57) + this->customIdentifiers->__get(i3)) + HX_("\\b.*?",bd,53,c7,39)),HX_("g",67,00,00,00));
HXLINE( 401)				if (regexp1->match(formula)) {
HXLINE( 402)					if (::hx::IsNotNull( this->customVaryings->__get(i3) )) {
HXLINE( 403)						formula = regexp1->replace(formula,(HX_("$1",8d,1f,00,00) + this->customVaryings->__get(i3)));
            					}
            					else {
HXLINE( 404)						HX_STACK_DO_THROW(((HX_("Error while parsing ColorFormula: custom identifier ",68,6a,5d,17) + this->customIdentifiers->__get(i3)) + HX_(" need @varying to access in fragmentshader",93,c0,46,91)));
            					}
            				}
            			}
            		}
HXLINE( 407)		this->textureID_Defaults = ::Array_obj< ::Dynamic>::__new();
HXLINE( 408)		this->used_by_ColorFormula = 0;
HXLINE( 409)		this->usedID_by_ColorFormula = 0;
HXLINE( 411)		{
HXLINE( 411)			int _g9 = 0;
HXDLIN( 411)			int _g10 = this->textureIdentifiers->length;
HXDLIN( 411)			while((_g9 < _g10)){
HXLINE( 411)				_g9 = (_g9 + 1);
HXDLIN( 411)				int i4 = (_g9 - 1);
HXLINE( 413)				 ::EReg regexp2 =  ::EReg_obj::__alloc( HX_CTX ,((HX_("(^|.*?[^\\w.])",7f,c6,d6,57) + this->textureIdentifiers->__get(i4)) + HX_("\\b.*?",bd,53,c7,39)),HX_("g",67,00,00,00));
HXLINE( 414)				if (regexp2->match(formula)) {
HXLINE( 415)					if (this->textureLayers->exists(i4)) {
HXLINE( 415)						formula = regexp2->replace(formula,((HX_("$1",8d,1f,00,00) + HX_("t",74,00,00,00)) + i4));
            					}
HXLINE( 416)					 ::peote::view::Program _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 416)					_hx_tmp->used_by_ColorFormula = (_hx_tmp->used_by_ColorFormula | (1 << i4));
            				}
HXLINE( 419)				regexp2 =  ::EReg_obj::__alloc( HX_CTX ,((HX_("(^|.*?[^\\w.])",7f,c6,d6,57) + (this->textureIdentifiers->__get(i4) + HX_("_ID",fa,55,48,00))) + HX_("\\b.*?",bd,53,c7,39)),HX_("g",67,00,00,00));
HXLINE( 420)				if (regexp2->match(formula)) {
HXLINE( 421)					formula = regexp2->replace(formula,(HX_("$1",8d,1f,00,00) + i4));
HXLINE( 422)					 ::peote::view::Program _hx_tmp1 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 422)					_hx_tmp1->usedID_by_ColorFormula = (_hx_tmp1->usedID_by_ColorFormula | (1 << i4));
HXLINE( 423)					if (!(this->textureLayers->exists(i4))) {
HXLINE( 423)						::Array< ::Dynamic> _hx_tmp2 = this->textureID_Defaults;
HXDLIN( 423)						int this2 = this->defaultFormulaVars->get_int(this->textureIdentifiers->__get(i4));
HXDLIN( 423)						::String s4 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this2 >> 24) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 423)						::String _hx_tmp3;
HXDLIN( 423)						bool _hx_tmp4;
HXDLIN( 423)						if ((s4.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 423)							_hx_tmp4 = (s4.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            						}
            						else {
HXLINE( 423)							_hx_tmp4 = true;
            						}
HXDLIN( 423)						if (_hx_tmp4) {
HXLINE( 423)							_hx_tmp3 = s4;
            						}
            						else {
HXLINE( 423)							_hx_tmp3 = (s4 + HX_(".0",42,28,00,00));
            						}
HXDLIN( 423)						::String s5 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this2 >> 16) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 423)						::String _hx_tmp5;
HXDLIN( 423)						bool _hx_tmp6;
HXDLIN( 423)						if ((s5.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 423)							_hx_tmp6 = (s5.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            						}
            						else {
HXLINE( 423)							_hx_tmp6 = true;
            						}
HXDLIN( 423)						if (_hx_tmp6) {
HXLINE( 423)							_hx_tmp5 = s5;
            						}
            						else {
HXLINE( 423)							_hx_tmp5 = (s5 + HX_(".0",42,28,00,00));
            						}
HXDLIN( 423)						::String s6 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this2 >> 8) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 423)						::String _hx_tmp7;
HXDLIN( 423)						bool _hx_tmp8;
HXDLIN( 423)						if ((s6.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 423)							_hx_tmp8 = (s6.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            						}
            						else {
HXLINE( 423)							_hx_tmp8 = true;
            						}
HXDLIN( 423)						if (_hx_tmp8) {
HXLINE( 423)							_hx_tmp7 = s6;
            						}
            						else {
HXLINE( 423)							_hx_tmp7 = (s6 + HX_(".0",42,28,00,00));
            						}
HXDLIN( 423)						::String s7 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)((this2 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 423)						::String _hx_tmp9;
HXDLIN( 423)						bool _hx_tmp10;
HXDLIN( 423)						if ((s7.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 423)							_hx_tmp10 = (s7.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            						}
            						else {
HXLINE( 423)							_hx_tmp10 = true;
            						}
HXDLIN( 423)						if (_hx_tmp10) {
HXLINE( 423)							_hx_tmp9 = s7;
            						}
            						else {
HXLINE( 423)							_hx_tmp9 = (s7 + HX_(".0",42,28,00,00));
            						}
HXDLIN( 423)						_hx_tmp2->push( ::Dynamic(::hx::Anon_obj::Create(2)
            							->setFixed(0,HX_("value",71,7f,b8,31),(((((HX_("vec4(",c8,4c,56,34) + _hx_tmp3) + HX_(", ",74,26,00,00)) + _hx_tmp5) + HX_(",",2c,00,00,00)) + ((((HX_(" ",20,00,00,00) + _hx_tmp7) + HX_(", ",74,26,00,00)) + _hx_tmp9) + HX_(")",29,00,00,00))))
            							->setFixed(1,HX_("layer",d1,81,c0,6f),i4)));
            					}
            				}
            			}
            		}
HXLINE( 427)		{
HXLINE( 427)			int _g11 = 0;
HXDLIN( 427)			int _g12 = this->customTextureIdentifiers->length;
HXDLIN( 427)			while((_g11 < _g12)){
HXLINE( 427)				_g11 = (_g11 + 1);
HXDLIN( 427)				int i5 = (_g11 - 1);
HXLINE( 429)				 ::EReg regexp3 =  ::EReg_obj::__alloc( HX_CTX ,((HX_("(^|.*?[^\\w.])",7f,c6,d6,57) + this->customTextureIdentifiers->__get(i5)) + HX_("\\b.*?",bd,53,c7,39)),HX_("g",67,00,00,00));
HXLINE( 430)				if (regexp3->match(formula)) {
HXLINE( 431)					if (this->textureLayers->exists((this->textureIdentifiers->length + i5))) {
HXLINE( 431)						formula = regexp3->replace(formula,((HX_("$1",8d,1f,00,00) + HX_("t",74,00,00,00)) + (this->textureIdentifiers->length + i5)));
            					}
HXLINE( 432)					 ::peote::view::Program _hx_tmp11 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 432)					_hx_tmp11->used_by_ColorFormula = (_hx_tmp11->used_by_ColorFormula | (1 << (this->textureIdentifiers->length + i5)));
            				}
HXLINE( 435)				regexp3 =  ::EReg_obj::__alloc( HX_CTX ,((HX_("(^|.*?[^\\w.])",7f,c6,d6,57) + (this->customTextureIdentifiers->__get(i5) + HX_("_ID",fa,55,48,00))) + HX_("\\b.*?",bd,53,c7,39)),HX_("g",67,00,00,00));
HXLINE( 436)				if (regexp3->match(formula)) {
HXLINE( 437)					formula = regexp3->replace(formula,(HX_("$1",8d,1f,00,00) + (this->textureIdentifiers->length + i5)));
HXLINE( 438)					 ::peote::view::Program _hx_tmp12 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 438)					_hx_tmp12->usedID_by_ColorFormula = (_hx_tmp12->usedID_by_ColorFormula | (1 << (this->textureIdentifiers->length + i5)));
HXLINE( 439)					if (!(this->textureLayers->exists((this->textureIdentifiers->length + i5)))) {
HXLINE( 439)						::Array< ::Dynamic> _hx_tmp13 = this->textureID_Defaults;
HXDLIN( 439)						int _hx_tmp14 = (this->textureIdentifiers->length + i5);
HXDLIN( 439)						int this3 = this->defaultFormulaVars->get_int(this->textureIdentifiers->__get((this->textureIdentifiers->length + i5)));
HXDLIN( 439)						::String s8 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this3 >> 24) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 439)						::String _hx_tmp15;
HXDLIN( 439)						bool _hx_tmp16;
HXDLIN( 439)						if ((s8.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 439)							_hx_tmp16 = (s8.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            						}
            						else {
HXLINE( 439)							_hx_tmp16 = true;
            						}
HXDLIN( 439)						if (_hx_tmp16) {
HXLINE( 439)							_hx_tmp15 = s8;
            						}
            						else {
HXLINE( 439)							_hx_tmp15 = (s8 + HX_(".0",42,28,00,00));
            						}
HXDLIN( 439)						::String s9 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this3 >> 16) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 439)						::String _hx_tmp17;
HXDLIN( 439)						bool _hx_tmp18;
HXDLIN( 439)						if ((s9.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 439)							_hx_tmp18 = (s9.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            						}
            						else {
HXLINE( 439)							_hx_tmp18 = true;
            						}
HXDLIN( 439)						if (_hx_tmp18) {
HXLINE( 439)							_hx_tmp17 = s9;
            						}
            						else {
HXLINE( 439)							_hx_tmp17 = (s9 + HX_(".0",42,28,00,00));
            						}
HXDLIN( 439)						::String s10 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this3 >> 8) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 439)						::String _hx_tmp19;
HXDLIN( 439)						bool _hx_tmp20;
HXDLIN( 439)						if ((s10.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 439)							_hx_tmp20 = (s10.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            						}
            						else {
HXLINE( 439)							_hx_tmp20 = true;
            						}
HXDLIN( 439)						if (_hx_tmp20) {
HXLINE( 439)							_hx_tmp19 = s10;
            						}
            						else {
HXLINE( 439)							_hx_tmp19 = (s10 + HX_(".0",42,28,00,00));
            						}
HXDLIN( 439)						::String s11 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)((this3 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 439)						::String _hx_tmp21;
HXDLIN( 439)						bool _hx_tmp22;
HXDLIN( 439)						if ((s11.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 439)							_hx_tmp22 = (s11.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            						}
            						else {
HXLINE( 439)							_hx_tmp22 = true;
            						}
HXDLIN( 439)						if (_hx_tmp22) {
HXLINE( 439)							_hx_tmp21 = s11;
            						}
            						else {
HXLINE( 439)							_hx_tmp21 = (s11 + HX_(".0",42,28,00,00));
            						}
HXDLIN( 439)						_hx_tmp13->push( ::Dynamic(::hx::Anon_obj::Create(2)
            							->setFixed(0,HX_("value",71,7f,b8,31),(((((HX_("vec4(",c8,4c,56,34) + _hx_tmp15) + HX_(", ",74,26,00,00)) + _hx_tmp17) + HX_(",",2c,00,00,00)) + ((((HX_(" ",20,00,00,00) + _hx_tmp19) + HX_(", ",74,26,00,00)) + _hx_tmp21) + HX_(")",29,00,00,00))))
            							->setFixed(1,HX_("layer",d1,81,c0,6f),_hx_tmp14)));
            					}
            				}
            			}
            		}
HXLINE( 445)		{
HXLINE( 445)			 ::Dynamic name = this->defaultFormulaVars->keys();
HXDLIN( 445)			while(( (bool)(name->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 445)				::String name1 = ( (::String)(name->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 447)				 ::EReg regexp4 =  ::EReg_obj::__alloc( HX_CTX ,((HX_("(^|.*?[^\\w.])",7f,c6,d6,57) + name1) + HX_("\\b.*?",bd,53,c7,39)),HX_("g",67,00,00,00));
HXLINE( 448)				if (regexp4->match(formula)) {
HXLINE( 449)					int this4 = this->defaultFormulaVars->get_int(name1);
HXDLIN( 449)					::String s12 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this4 >> 24) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 449)					::String formula10;
HXDLIN( 449)					bool formula11;
HXDLIN( 449)					if ((s12.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 449)						formula11 = (s12.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            					}
            					else {
HXLINE( 449)						formula11 = true;
            					}
HXDLIN( 449)					if (formula11) {
HXLINE( 449)						formula10 = s12;
            					}
            					else {
HXLINE( 449)						formula10 = (s12 + HX_(".0",42,28,00,00));
            					}
HXDLIN( 449)					::String s13 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this4 >> 16) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 449)					::String formula12;
HXDLIN( 449)					bool formula13;
HXDLIN( 449)					if ((s13.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 449)						formula13 = (s13.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            					}
            					else {
HXLINE( 449)						formula13 = true;
            					}
HXDLIN( 449)					if (formula13) {
HXLINE( 449)						formula12 = s13;
            					}
            					else {
HXLINE( 449)						formula12 = (s13 + HX_(".0",42,28,00,00));
            					}
HXDLIN( 449)					::String s14 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(((this4 >> 8) & 255)) ) / ( (Float)(255) ))));
HXDLIN( 449)					::String formula14;
HXDLIN( 449)					bool formula15;
HXDLIN( 449)					if ((s14.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 449)						formula15 = (s14.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            					}
            					else {
HXLINE( 449)						formula15 = true;
            					}
HXDLIN( 449)					if (formula15) {
HXLINE( 449)						formula14 = s14;
            					}
            					else {
HXLINE( 449)						formula14 = (s14 + HX_(".0",42,28,00,00));
            					}
HXDLIN( 449)					::String s15 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)((this4 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 449)					::String formula16;
HXDLIN( 449)					bool formula17;
HXDLIN( 449)					if ((s15.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 449)						formula17 = (s15.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            					}
            					else {
HXLINE( 449)						formula17 = true;
            					}
HXDLIN( 449)					if (formula17) {
HXLINE( 449)						formula16 = s15;
            					}
            					else {
HXLINE( 449)						formula16 = (s15 + HX_(".0",42,28,00,00));
            					}
HXDLIN( 449)					formula = regexp4->replace(formula,(HX_("$1",8d,1f,00,00) + (((((HX_("vec4(",c8,4c,56,34) + formula10) + HX_(", ",74,26,00,00)) + formula12) + HX_(",",2c,00,00,00)) + ((((HX_(" ",20,00,00,00) + formula14) + HX_(", ",74,26,00,00)) + formula16) + HX_(")",29,00,00,00)))));
            				}
            			}
            		}
HXLINE( 453)		this->glShaderConfig->__SetField(HX_("FRAGMENT_CALC_LAYER",96,4e,b7,5b),formula,::hx::paccDynamic);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Program_obj,parseColorFormula,(void))

void Program_obj::setColorFormula(::String __o_formula, ::haxe::ds::StringMap varDefaults, ::Dynamic autoUpdateTextures){
            		::String formula = __o_formula;
            		if (::hx::IsNull(__o_formula)) formula = HX_("",00,00,00,00);
            	HX_GC_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_456_setColorFormula)
HXLINE( 457)		this->colorFormula = formula;
HXLINE( 458)		if (::hx::IsNotNull( varDefaults )) {
HXLINE( 459)			 ::Dynamic name = varDefaults->keys();
HXDLIN( 459)			while(( (bool)(name->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 459)				::String name1 = ( (::String)(name->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 460)				 ::EReg regexp =  ::EReg_obj::__alloc( HX_CTX ,HX_("^([a-zA-z_]+\\d*)+$",1c,bf,72,6e),HX_("g",67,00,00,00));
HXDLIN( 460)				if (!(regexp->match(name1))) {
HXLINE( 460)					HX_STACK_DO_THROW(((HX_("Error: \"",14,9c,d7,b8) + name1) + HX_("\" is not an identifier, please use only letters/numbers or \"_\" (starting with a letter)",52,87,ec,d2)));
            				}
HXLINE( 461)				 ::haxe::ds::StringMap _hx_tmp = this->defaultFormulaVars;
HXDLIN( 461)				_hx_tmp->set(name1,varDefaults->get(name1));
            			}
            		}
HXLINE( 463)		if (::hx::IsNotNull( autoUpdateTextures )) {
HXLINE( 463)			if (( (bool)(autoUpdateTextures) )) {
HXLINE( 463)				this->updateTextures();
            			}
            		}
            		else {
HXLINE( 464)			if (this->autoUpdateTextures) {
HXLINE( 464)				this->updateTextures();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Program_obj,setColorFormula,(void))

void Program_obj::injectIntoFragmentShader(::String __o_glslCode,::hx::Null< bool >  __o_uTimeUniformEnabled,::Array< ::Dynamic> uniformFloats, ::Dynamic autoUpdateTextures){
            		::String glslCode = __o_glslCode;
            		if (::hx::IsNull(__o_glslCode)) glslCode = HX_("",00,00,00,00);
            		bool uTimeUniformEnabled = __o_uTimeUniformEnabled.Default(false);
            	HX_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_476_injectIntoFragmentShader)
HXLINE( 477)		bool _hx_tmp;
HXDLIN( 477)		if ((glslCode == HX_("",00,00,00,00))) {
HXLINE( 477)			_hx_tmp = false;
            		}
            		else {
HXLINE( 477)			_hx_tmp = true;
            		}
HXDLIN( 477)		this->hasFragmentInjection = _hx_tmp;
HXLINE( 478)		this->uniformFloatsFragment = uniformFloats;
HXLINE( 479)		::String _hx_tmp1;
HXDLIN( 479)		if (uTimeUniformEnabled) {
HXLINE( 479)			_hx_tmp1 = HX_("uniform float uTime;",49,63,18,68);
            		}
            		else {
HXLINE( 479)			_hx_tmp1 = HX_("",00,00,00,00);
            		}
HXDLIN( 479)		::String _hx_tmp2 = (_hx_tmp1 + this->generateUniformFloatsGLSL(uniformFloats));
HXDLIN( 479)		this->glShaderConfig->__SetField(HX_("FRAGMENT_INJECTION",48,b3,05,e2),(_hx_tmp2 + glslCode),::hx::paccDynamic);
HXLINE( 480)		this->accumulateUniformsFloat();
HXLINE( 481)		if (::hx::IsNotNull( autoUpdateTextures )) {
HXLINE( 481)			if (( (bool)(autoUpdateTextures) )) {
HXLINE( 481)				this->updateTextures();
            			}
            		}
            		else {
HXLINE( 481)			if (this->autoUpdateTextures) {
HXLINE( 481)				this->updateTextures();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Program_obj,injectIntoFragmentShader,(void))

::String Program_obj::generateUniformFloatsGLSL(::Array< ::Dynamic> uniformFloats){
            	HX_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_484_generateUniformFloatsGLSL)
HXLINE( 485)		::String out = HX_("",00,00,00,00);
HXLINE( 486)		if (::hx::IsNotNull( uniformFloats )) {
HXLINE( 487)			int _g = 0;
HXDLIN( 487)			while((_g < uniformFloats->length)){
HXLINE( 487)				 ::peote::view::UniformFloat u = uniformFloats->__get(_g).StaticCast<  ::peote::view::UniformFloat >();
HXDLIN( 487)				_g = (_g + 1);
HXDLIN( 487)				out = (out + ((HX_("uniform float ",70,08,5a,60) + u->name) + HX_(";",3b,00,00,00)));
            			}
            		}
HXLINE( 488)		return out;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Program_obj,generateUniformFloatsGLSL,return )

void Program_obj::accumulateUniformsFloat(){
            	HX_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_492_accumulateUniformsFloat)
HXDLIN( 492)		if (::hx::IsNull( this->uniformFloatsVertex )) {
HXLINE( 493)			if (::hx::IsNotNull( this->uniformFloatsFragment )) {
HXLINE( 493)				this->uniformFloats = this->uniformFloatsFragment;
            			}
            		}
            		else {
HXLINE( 495)			if (::hx::IsNull( this->uniformFloatsFragment )) {
HXLINE( 496)				this->uniformFloats = this->uniformFloatsVertex;
            			}
            			else {
HXLINE( 499)				this->uniformFloats = this->uniformFloatsVertex;
HXLINE( 500)				{
HXLINE( 500)					int _g = 0;
HXDLIN( 500)					::Array< ::Dynamic> _g1 = this->uniformFloatsFragment;
HXDLIN( 500)					while((_g < _g1->length)){
HXLINE( 500)						 ::peote::view::UniformFloat u = _g1->__get(_g).StaticCast<  ::peote::view::UniformFloat >();
HXDLIN( 500)						_g = (_g + 1);
HXLINE( 501)						if ((this->uniformFloats->indexOf(u,null()) < 0)) {
HXLINE( 502)							this->uniformFloats->push(u);
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Program_obj,accumulateUniformsFloat,(void))

void Program_obj::parseAndResolveFormulas(){
            	HX_GC_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_541_parseAndResolveFormulas)
HXDLIN( 541)		 ::peote::view::Program _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 543)		if (this->formulaHasChanged) {
            			HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0, ::peote::view::Program,_gthis, ::haxe::ds::StringMap,formulaResolved) HXARGC(4)
            			::String _hx_run(::String x,::String y,::String dx,::String dy){
            				HX_GC_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_552_parseAndResolveFormulas)
HXLINE( 553)				::String nx = ::peote::view::BufferInterface_obj::getFormulaNames(_gthis->buffer)->get_string(x);
HXLINE( 555)				if (::hx::IsNull( nx )) {
HXLINE( 555)					nx = HX_("",00,00,00,00);
            				}
HXLINE( 557)				::String ny = ::peote::view::BufferInterface_obj::getFormulaNames(_gthis->buffer)->get_string(y);
HXLINE( 559)				if (::hx::IsNull( ny )) {
HXLINE( 559)					ny = HX_("",00,00,00,00);
            				}
HXLINE( 561)				::String fx = formulaResolved->get_string(nx);
HXLINE( 562)				::String fy = formulaResolved->get_string(ny);
HXLINE( 564)				bool formulaTemplateValue;
HXDLIN( 564)				if (::hx::IsEq( fx,::peote::view::BufferInterface_obj::getFormulas(_gthis->buffer)->get(nx) )) {
HXLINE( 564)					formulaTemplateValue = ::hx::IsNotEq( fy,::peote::view::BufferInterface_obj::getFormulas(_gthis->buffer)->get(ny) );
            				}
            				else {
HXLINE( 564)					formulaTemplateValue = true;
            				}
HXDLIN( 564)				if (formulaTemplateValue) {
HXLINE( 565)					if (::hx::IsNull( fx )) {
HXLINE( 565)						fx = ::peote::view::BufferInterface_obj::getAttributes(_gthis->buffer)->get_string(nx);
            					}
HXLINE( 566)					if (::hx::IsNull( fx )) {
HXLINE( 566)						fx = dx;
            					}
HXLINE( 568)					if (::hx::IsNull( fy )) {
HXLINE( 568)						fy = ::peote::view::BufferInterface_obj::getAttributes(_gthis->buffer)->get_string(ny);
            					}
HXLINE( 569)					if (::hx::IsNull( fy )) {
HXLINE( 569)						fy = dy;
            					}
HXLINE( 571)					bool formulaTemplateValue1;
HXDLIN( 571)					if ((x == HX_("rotation",3e,3d,86,08))) {
HXLINE( 571)						formulaTemplateValue1 = (fx != HX_("0.0",72,94,24,00));
            					}
            					else {
HXLINE( 571)						formulaTemplateValue1 = false;
            					}
HXDLIN( 571)					if (formulaTemplateValue1) {
HXLINE( 571)						fx = (((HX_("(",28,00,00,00) + fx) + HX_(")/180.0*",45,8e,4f,c1)) + ::Math_obj::PI);
            					}
HXLINE( 572)					bool formulaTemplateValue2;
HXDLIN( 572)					if ((y == HX_("zIndex",38,10,cc,18))) {
HXLINE( 572)						formulaTemplateValue2 = (fy != HX_("0.0",72,94,24,00));
            					}
            					else {
HXLINE( 572)						formulaTemplateValue2 = false;
            					}
HXDLIN( 572)					if (formulaTemplateValue2) {
HXLINE( 572)						::String s = (HX_("",00,00,00,00) + ::Std_obj::string(::peote::view::BufferInterface_obj::getMaxZindex(_gthis->buffer)));
HXDLIN( 572)						::String fy1;
HXDLIN( 572)						bool fy2;
HXDLIN( 572)						if ((s.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 572)							fy2 = (s.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            						}
            						else {
HXLINE( 572)							fy2 = true;
            						}
HXDLIN( 572)						if (fy2) {
HXLINE( 572)							fy1 = s;
            						}
            						else {
HXLINE( 572)							fy1 = (s + HX_(".0",42,28,00,00));
            						}
HXDLIN( 572)						fy = ((((HX_("clamp( ",b3,8a,97,65) + fy) + HX_("/",2f,00,00,00)) + fy1) + HX_(", -1.0, 1.0)",24,27,24,ce));
            					}
HXLINE( 575)					return ((((HX_("vec2(",0a,4b,56,34) + fx) + HX_(", ",74,26,00,00)) + fy) + HX_(")",29,00,00,00));
            				}
            				else {
HXLINE( 577)					return null();
            				}
HXLINE( 564)				return null();
            			}
            			HX_END_LOCAL_FUNC4(return)

HXLINE( 545)			 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN( 545)			{
HXLINE( 545)				 ::Dynamic k = this->formula->keys();
HXDLIN( 545)				while(( (bool)(k->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 545)					::String k1 = ( (::String)(k->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 545)					_g->set(k1,this->formula->get(k1));
            				}
            			}
HXDLIN( 545)			 ::haxe::ds::StringMap formulaResolved = _g;
HXLINE( 546)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 546)				::peote::view::utils::Util_obj::resolveFormulaCyclic(formulaResolved);
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g1 = _hx_e;
HXLINE( 546)					{
HXLINE( 546)						null();
            					}
HXDLIN( 546)					 ::Dynamic e = _g1;
HXDLIN( 546)					::String _hx_tmp = ((HX_("Error: cyclic reference of \"",07,aa,27,13) + ::Std_obj::string( ::Dynamic(e->__Field(HX_("errVar",82,7c,55,51),::hx::paccDynamic)))) + HX_("\" inside formula \"",82,b1,58,be));
HXDLIN( 546)					::String _hx_tmp1 = ((_hx_tmp + ::Std_obj::string( ::Dynamic(e->__Field(HX_("formula",66,e7,3d,df),::hx::paccDynamic)))) + HX_("\" for \"",cd,c8,d9,55));
HXDLIN( 546)					HX_STACK_DO_THROW(((_hx_tmp1 + ::Std_obj::string( ::Dynamic(e->__Field(HX_("errKey",3a,27,4d,51),::hx::paccDynamic)))) + HX_("\"",22,00,00,00)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXLINE( 548)			 ::haxe::ds::StringMap formulaResolved1 = formulaResolved;
HXDLIN( 548)			::peote::view::utils::Util_obj::resolveFormulaVars(formulaResolved1,::peote::view::BufferInterface_obj::getAttributes(this->buffer));
HXLINE( 551)			 ::Dynamic formulaTemplateValue =  ::Dynamic(new _hx_Closure_0(_gthis,formulaResolved));
HXLINE( 579)			this->glShaderConfig->__SetField(HX_("SIZE_FORMULA",88,a6,86,1e),formulaTemplateValue(HX_("sizeX",77,08,d9,7c),HX_("sizeY",78,08,d9,7c),HX_("100.0",f3,3e,81,56),HX_("100.0",f3,3e,81,56)),::hx::paccDynamic);
HXLINE( 580)			this->glShaderConfig->__SetField(HX_("POS_FORMULA",3b,a2,8b,99),formulaTemplateValue(HX_("posX",44,84,5c,4a),HX_("posY",45,84,5c,4a),HX_("0.0",72,94,24,00),HX_("0.0",72,94,24,00)),::hx::paccDynamic);
HXLINE( 581)			this->glShaderConfig->__SetField(HX_("ROTZ_FORMULA",4a,8a,0c,ae),formulaTemplateValue(HX_("rotation",3e,3d,86,08),HX_("zIndex",38,10,cc,18),HX_("0.0",72,94,24,00),HX_("0.0",72,94,24,00)),::hx::paccDynamic);
HXLINE( 582)			this->glShaderConfig->__SetField(HX_("PIVOT_FORMULA",69,09,71,fd),formulaTemplateValue(HX_("pivotX",56,1f,5f,8b),HX_("pivotY",57,1f,5f,8b),HX_("0.0",72,94,24,00),HX_("0.0",72,94,24,00)),::hx::paccDynamic);
HXLINE( 585)			{
HXLINE( 585)				int _g2 = 0;
HXDLIN( 585)				::Array< ::String > _g3 = ::peote::view::BufferInterface_obj::getFormulaVaryings(this->buffer);
HXDLIN( 585)				while((_g2 < _g3->length)){
HXLINE( 585)					::String n = _g3->__get(_g2);
HXDLIN( 585)					_g2 = (_g2 + 1);
HXLINE( 586)					::String f = formulaResolved->get_string(n);
HXLINE( 587)					if (::hx::IsNotEq( f,::peote::view::BufferInterface_obj::getFormulas(this->buffer)->get(n) )) {
HXLINE( 589)						if (::hx::IsNull( f )) {
HXLINE( 589)							f = ::peote::view::BufferInterface_obj::getAttributes(this->buffer)->get_string(n);
            						}
HXLINE( 590)						::Reflect_obj::setField( ::Dynamic(this->glShaderConfig->__Field(HX_("FORMULA_VARYINGS",5c,59,a0,f6),::hx::paccDynamic)),n,f);
HXLINE( 591)						::haxe::Log_obj::trace((((HX_(" -- replacing Formula ",49,3a,1e,e1) + n) + HX_(" => ",7f,53,55,15)) + f),::hx::SourceInfo(HX_("peote/view/Program.hx",00,9d,0a,6b),591,HX_("peote.view.Program",de,98,33,0a),HX_("parseAndResolveFormulas",55,c1,01,bb)));
            					}
            					else {
HXLINE( 593)						::Reflect_obj::setField( ::Dynamic(this->glShaderConfig->__Field(HX_("FORMULA_VARYINGS",5c,59,a0,f6),::hx::paccDynamic)),n,null());
            					}
            				}
            			}
HXLINE( 596)			{
HXLINE( 596)				int _g4 = 0;
HXDLIN( 596)				::Array< ::String > _g5 = ::peote::view::BufferInterface_obj::getFormulaConstants(this->buffer);
HXDLIN( 596)				while((_g4 < _g5->length)){
HXLINE( 596)					::String n1 = _g5->__get(_g4);
HXDLIN( 596)					_g4 = (_g4 + 1);
HXLINE( 597)					::String f1 = formulaResolved->get_string(n1);
HXLINE( 598)					bool _hx_tmp2;
HXDLIN( 598)					if (::hx::IsNotNull( f1 )) {
HXLINE( 598)						_hx_tmp2 = ::hx::IsNotEq( f1,::peote::view::BufferInterface_obj::getAttributes(this->buffer)->get(n1) );
            					}
            					else {
HXLINE( 598)						_hx_tmp2 = false;
            					}
HXDLIN( 598)					if (_hx_tmp2) {
HXLINE( 600)						::Reflect_obj::setField( ::Dynamic(this->glShaderConfig->__Field(HX_("FORMULA_CONSTANTS",f6,30,e1,8e),::hx::paccDynamic)),n1,f1);
HXLINE( 601)						::haxe::Log_obj::trace((((HX_(" -- replacing Formula ",49,3a,1e,e1) + n1) + HX_(" => ",7f,53,55,15)) + f1),::hx::SourceInfo(HX_("peote/view/Program.hx",00,9d,0a,6b),601,HX_("peote.view.Program",de,98,33,0a),HX_("parseAndResolveFormulas",55,c1,01,bb)));
            					}
            					else {
HXLINE( 603)						::Reflect_obj::setField( ::Dynamic(this->glShaderConfig->__Field(HX_("FORMULA_CONSTANTS",f6,30,e1,8e),::hx::paccDynamic)),n1,null());
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Program_obj,parseAndResolveFormulas,(void))

void Program_obj::updateTextures(){
            	HX_STACKFRAME(&_hx_pos_2e0c77bf7c76f0ca_787_updateTextures)
HXLINE( 792)		::Array< ::Dynamic> newTextures = ::Array_obj< ::Dynamic>::__new();
HXLINE( 793)		{
HXLINE( 793)			 ::Dynamic layer = this->textureLayers->keys();
HXDLIN( 793)			while(( (bool)(layer->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 793)				int layer1 = ( (int)(layer->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 794)				{
HXLINE( 794)					int _g = 0;
HXDLIN( 794)					::Array< ::Dynamic> _g1 = ( (::Array< ::Dynamic>)(this->textureLayers->get(layer1)) );
HXDLIN( 794)					while((_g < _g1->length)){
HXLINE( 794)						 ::peote::view::Texture t = _g1->__get(_g).StaticCast<  ::peote::view::Texture >();
HXDLIN( 794)						_g = (_g + 1);
HXLINE( 795)						if ((newTextures->indexOf(t,null()) < 0)) {
HXLINE( 795)							newTextures->push(t);
            						}
            					}
            				}
            			}
            		}
HXLINE( 799)		int i = this->activeTextures->length;
HXLINE( 800)		while(true){
HXLINE( 800)			i = (i - 1);
HXDLIN( 800)			if (!(((i + 1) > 0))) {
HXLINE( 800)				goto _hx_goto_37;
            			}
HXLINE( 801)			if ((newTextures->indexOf(this->activeTextures->__get(i).StaticCast<  ::peote::view::Texture >(),null()) < 0)) {
HXLINE( 805)				if (!(this->activeTextures->__get(i).StaticCast<  ::peote::view::Texture >()->programs->remove(::hx::ObjectPtr<OBJ_>(this)))) {
HXLINE( 805)					HX_STACK_DO_THROW(HX_("Error, this texture is not used by program anymore",e7,5d,fa,c2));
            				}
HXLINE( 806)				this->activeTextures->removeRange(i,1);
HXLINE( 807)				this->activeUnits->removeRange(i,1);
            			}
            		}
            		_hx_goto_37:;
HXLINE( 810)		{
HXLINE( 810)			int _g2 = 0;
HXDLIN( 810)			while((_g2 < newTextures->length)){
HXLINE( 810)				 ::peote::view::Texture t1 = newTextures->__get(_g2).StaticCast<  ::peote::view::Texture >();
HXDLIN( 810)				_g2 = (_g2 + 1);
HXLINE( 811)				if ((this->activeTextures->indexOf(t1,null()) < 0)) {
HXLINE( 815)					this->activeTextures->push(t1);
HXLINE( 816)					int unit = 0;
HXLINE( 817)					while((this->activeUnits->indexOf(unit,null()) >= 0)){
HXLINE( 817)						unit = (unit + 1);
            					}
HXLINE( 818)					this->activeUnits->push(unit);
HXLINE( 819)					{
HXLINE( 819)						if ((t1->programs->indexOf(::hx::ObjectPtr<OBJ_>(this),null()) >= 0)) {
HXLINE( 819)							HX_STACK_DO_THROW(HX_("Error, texture is already used by program",c1,8d,b8,88));
            						}
HXDLIN( 819)						{
HXLINE( 819)							 ::lime::_internal::backend::native::NativeOpenGLRenderContext newGl = this->gl;
HXDLIN( 819)							bool _hx_tmp;
HXDLIN( 819)							if (::hx::IsNotNull( newGl )) {
HXLINE( 819)								_hx_tmp = ::hx::IsInstanceNotEq( newGl,t1->gl );
            							}
            							else {
HXLINE( 819)								_hx_tmp = false;
            							}
HXDLIN( 819)							if (_hx_tmp) {
HXLINE( 819)								{
HXLINE( 819)									int _g3 = 0;
HXDLIN( 819)									::Array< ::Dynamic> _g4 = t1->programs;
HXDLIN( 819)									while((_g3 < _g4->length)){
HXLINE( 819)										 ::peote::view::Program p = _g4->__get(_g3).StaticCast<  ::peote::view::Program >();
HXDLIN( 819)										_g3 = (_g3 + 1);
HXDLIN( 819)										bool _hx_tmp1;
HXDLIN( 819)										if (::hx::IsNotNull( p->gl )) {
HXLINE( 819)											_hx_tmp1 = ::hx::IsInstanceNotEq( p->gl,newGl );
            										}
            										else {
HXLINE( 819)											_hx_tmp1 = false;
            										}
HXDLIN( 819)										if (_hx_tmp1) {
HXLINE( 819)											HX_STACK_DO_THROW(HX_("Error, texture can not used inside different gl-contexts",06,26,7d,73));
            										}
            									}
            								}
HXDLIN( 819)								{
HXLINE( 819)									int _g5 = 0;
HXDLIN( 819)									::Array< ::Dynamic> _g6 = t1->displays;
HXDLIN( 819)									while((_g5 < _g6->length)){
HXLINE( 819)										 ::peote::view::Display d = _g6->__get(_g5).StaticCast<  ::peote::view::Display >();
HXDLIN( 819)										_g5 = (_g5 + 1);
HXDLIN( 819)										bool _hx_tmp2;
HXDLIN( 819)										if (::hx::IsNotNull( d->gl )) {
HXLINE( 819)											_hx_tmp2 = ::hx::IsInstanceNotEq( d->gl,newGl );
            										}
            										else {
HXLINE( 819)											_hx_tmp2 = false;
            										}
HXDLIN( 819)										if (_hx_tmp2) {
HXLINE( 819)											HX_STACK_DO_THROW(HX_("Error, texture can not used inside different gl-contexts",06,26,7d,73));
            										}
            									}
            								}
HXDLIN( 819)								if (::hx::IsNotNull( t1->gl )) {
HXLINE( 819)									t1->gl->deleteTexture(t1->glTexture);
HXDLIN( 819)									t1->glTexture = null();
HXDLIN( 819)									bool _hx_tmp3;
HXDLIN( 819)									if ((t1->displays->length == 0)) {
HXLINE( 819)										_hx_tmp3 = ::hx::IsNotNull( t1->framebuffer );
            									}
            									else {
HXLINE( 819)										_hx_tmp3 = false;
            									}
HXDLIN( 819)									if (_hx_tmp3) {
HXLINE( 819)										t1->gl->deleteFramebuffer(t1->framebuffer);
HXDLIN( 819)										t1->framebuffer = null();
HXDLIN( 819)										if (::hx::IsNotNull( t1->glDepthBuffer )) {
HXLINE( 819)											t1->gl->deleteRenderbuffer(t1->glDepthBuffer);
            										}
HXDLIN( 819)										t1->glDepthBuffer = null();
            									}
            								}
HXDLIN( 819)								t1->gl = newGl;
HXDLIN( 819)								{
HXLINE( 819)									bool _hx_tmp4;
HXDLIN( 819)									int t2 = t1->width;
HXDLIN( 819)									if (!(::hx::IsGreater( t2,t1->gl->getParameter(t1->gl->MAX_TEXTURE_SIZE) ))) {
HXLINE( 819)										int t3 = t1->height;
HXDLIN( 819)										_hx_tmp4 = ::hx::IsGreater( t3,t1->gl->getParameter(t1->gl->MAX_TEXTURE_SIZE) );
            									}
            									else {
HXLINE( 819)										_hx_tmp4 = true;
            									}
HXDLIN( 819)									if (_hx_tmp4) {
HXLINE( 819)										HX_STACK_DO_THROW(HX_("Error, texture size is greater then gl.MAX_TEXTURE_SIZE",84,65,32,52));
            									}
HXDLIN( 819)									t1->glTexture = ::peote::view::utils::TexUtils_obj::createEmptyTexture(t1->gl,t1->width,t1->height,t1->colorChannels,t1->createMipmaps,t1->magFilter,t1->minFilter,t1->useFloat);
            								}
HXDLIN( 819)								bool _hx_tmp5;
HXDLIN( 819)								if ((t1->displays->length > 0)) {
HXLINE( 819)									_hx_tmp5 = ::hx::IsNull( t1->framebuffer );
            								}
            								else {
HXLINE( 819)									_hx_tmp5 = false;
            								}
HXDLIN( 819)								if (_hx_tmp5) {
HXLINE( 819)									t1->glDepthBuffer = t1->gl->createRenderbuffer();
HXDLIN( 819)									 ::lime::_internal::backend::native::NativeOpenGLRenderContext gl = t1->gl;
HXDLIN( 819)									 ::lime::graphics::opengl::GLObject texture = t1->glTexture;
HXDLIN( 819)									 ::lime::graphics::opengl::GLObject depthBuffer = t1->glDepthBuffer;
HXDLIN( 819)									int width = t1->width;
HXDLIN( 819)									int height = t1->height;
HXDLIN( 819)									 ::lime::graphics::opengl::GLObject framebuffer = gl->createFramebuffer();
HXDLIN( 819)									gl->bindRenderbuffer(gl->RENDERBUFFER,depthBuffer);
HXDLIN( 819)									::peote::view::utils::GLTool_obj::clearGlErrorQueue(gl);
HXDLIN( 819)									gl->renderbufferStorage(gl->RENDERBUFFER,gl->DEPTH_COMPONENT24,width,height);
HXDLIN( 819)									int _hx_tmp6 = ::peote::view::utils::GLTool_obj::getLastGlError(gl);
HXDLIN( 819)									if ((_hx_tmp6 == gl->INVALID_ENUM)) {
HXLINE( 819)										::haxe::Log_obj::trace(HX_("switching to DEPTH_COMPONENT16 for framebuffer",69,ed,16,03),::hx::SourceInfo(HX_("peote/view/utils/GLTool.hx",3d,2a,d3,ba),41,HX_("peote.view.utils.GLTool",00,20,8a,f7),HX_("createFramebuffer",51,ef,e8,cc)));
HXDLIN( 819)										gl->renderbufferStorage(gl->RENDERBUFFER,gl->DEPTH_COMPONENT16,width,height);
            									}
HXDLIN( 819)									gl->bindFramebuffer(gl->FRAMEBUFFER,framebuffer);
HXDLIN( 819)									gl->framebufferRenderbuffer(gl->FRAMEBUFFER,gl->DEPTH_ATTACHMENT,gl->RENDERBUFFER,depthBuffer);
HXDLIN( 819)									gl->framebufferTexture2D(gl->FRAMEBUFFER,gl->COLOR_ATTACHMENT0,gl->TEXTURE_2D,texture,0);
HXDLIN( 819)									int _hx_tmp7 = gl->checkFramebufferStatus(gl->FRAMEBUFFER);
HXDLIN( 819)									if ((_hx_tmp7 != gl->FRAMEBUFFER_COMPLETE)) {
HXLINE( 819)										HX_STACK_DO_THROW(HX_("Error: Framebuffer not complete!",5a,13,e6,19));
            									}
HXDLIN( 819)									gl->bindFramebuffer(gl->FRAMEBUFFER,null());
HXDLIN( 819)									gl->bindRenderbuffer(gl->RENDERBUFFER,null());
HXDLIN( 819)									t1->framebuffer = framebuffer;
HXDLIN( 819)									t1->updated = true;
            								}
HXDLIN( 819)								{
HXLINE( 819)									 ::Dynamic image = t1->images->keys();
HXDLIN( 819)									while(( (bool)(image->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 819)										 ::peote::view::_TextureData::TextureDataImpl image1 = ( ( ::peote::view::_TextureData::TextureDataImpl)(image->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 819)										t1->bufferImage(image1,t1->images->get(image1));
            									}
            								}
            							}
            						}
HXDLIN( 819)						t1->programs->push(::hx::ObjectPtr<OBJ_>(this));
            					}
            				}
            			}
            		}
HXLINE( 827)		this->parseColorFormula();
HXLINE( 829)		this->glShaderConfig->__SetField(HX_("hasFRAGMENT_INJECTION",22,d1,a9,20),this->hasFragmentInjection,::hx::paccDynamic);
HXLINE( 831)		this->glShaderConfig->__SetField(HX_("FRAGMENT_PROGRAM_UNIFORMS",c9,7d,2b,7c),HX_("",00,00,00,00),::hx::paccDynamic);
HXLINE( 832)		this->glShaderConfig->__SetField(HX_("TEXTURES",38,87,54,bf),::Array_obj< ::Dynamic>::__new(0),::hx::paccDynamic);
HXLINE( 834)		if ((this->activeTextures->length == 0)) {
HXLINE( 835)			this->glShaderConfig->__SetField(HX_("hasTEXTURES",92,b0,59,b8),false,::hx::paccDynamic);
            		}
            		else {
HXLINE( 838)			this->glShaderConfig->__SetField(HX_("hasTEXTURES",92,b0,59,b8),true,::hx::paccDynamic);
HXLINE( 840)			{
HXLINE( 840)				int _g7 = 0;
HXDLIN( 840)				int _g8 = this->activeTextures->length;
HXDLIN( 840)				while((_g7 < _g8)){
HXLINE( 840)					_g7 = (_g7 + 1);
HXDLIN( 840)					int i1 = (_g7 - 1);
HXLINE( 841)					 ::Dynamic fh = this->glShaderConfig;
HXDLIN( 841)					fh->__SetField(HX_("FRAGMENT_PROGRAM_UNIFORMS",c9,7d,2b,7c),(fh->__Field(HX_("FRAGMENT_PROGRAM_UNIFORMS",c9,7d,2b,7c),::hx::paccDynamic) + ((HX_("uniform sampler2D uTexture",58,22,d0,ae) + i1) + HX_(";",3b,00,00,00))),::hx::paccDynamic);
            				}
            			}
HXLINE( 844)			{
HXLINE( 844)				 ::Dynamic layer2 = this->textureLayers->keys();
HXDLIN( 844)				while(( (bool)(layer2->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 844)					int layer3 = ( (int)(layer2->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 846)					::Array< ::Dynamic> units = ::Array_obj< ::Dynamic>::__new();
HXLINE( 852)					::Array< ::Dynamic> textures = ( (::Array< ::Dynamic>)(this->textureLayers->get(layer3)) );
HXLINE( 853)					{
HXLINE( 853)						int _g9 = 0;
HXDLIN( 853)						int _g10 = textures->length;
HXDLIN( 853)						while((_g9 < _g10)){
HXLINE( 853)							_g9 = (_g9 + 1);
HXDLIN( 853)							int i2 = (_g9 - 1);
HXLINE( 856)							::String _hx_tmp8 = (HX_("uTexture",e6,18,40,90) + this->activeTextures->indexOf(textures->__get(i2).StaticCast<  ::peote::view::Texture >(),null()));
HXLINE( 857)							::String _hx_tmp9 = (textures->__get(i2).StaticCast<  ::peote::view::Texture >()->slotsX + HX_(".0",42,28,00,00));
HXLINE( 858)							::String _hx_tmp10 = (textures->__get(i2).StaticCast<  ::peote::view::Texture >()->slotsY + HX_(".0",42,28,00,00));
HXLINE( 859)							::String s = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->slotWidth) ) / ( (Float)(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->width) ))));
HXDLIN( 859)							::String _hx_tmp11;
HXDLIN( 859)							bool _hx_tmp12;
HXDLIN( 859)							if ((s.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 859)								_hx_tmp12 = (s.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            							}
            							else {
HXLINE( 859)								_hx_tmp12 = true;
            							}
HXDLIN( 859)							if (_hx_tmp12) {
HXLINE( 859)								_hx_tmp11 = s;
            							}
            							else {
HXLINE( 859)								_hx_tmp11 = (s + HX_(".0",42,28,00,00));
            							}
HXLINE( 860)							::String s1 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->slotHeight) ) / ( (Float)(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->height) ))));
HXDLIN( 860)							::String _hx_tmp13;
HXDLIN( 860)							bool _hx_tmp14;
HXDLIN( 860)							if ((s1.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 860)								_hx_tmp14 = (s1.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            							}
            							else {
HXLINE( 860)								_hx_tmp14 = true;
            							}
HXDLIN( 860)							if (_hx_tmp14) {
HXLINE( 860)								_hx_tmp13 = s1;
            							}
            							else {
HXLINE( 860)								_hx_tmp13 = (s1 + HX_(".0",42,28,00,00));
            							}
HXLINE( 861)							::String s2 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)((textures->__get(i2).StaticCast<  ::peote::view::Texture >()->slotsX * textures->__get(i2).StaticCast<  ::peote::view::Texture >()->slotWidth)) ) / ( (Float)(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->width) ))));
HXDLIN( 861)							::String _hx_tmp15;
HXDLIN( 861)							bool _hx_tmp16;
HXDLIN( 861)							if ((s2.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 861)								_hx_tmp16 = (s2.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            							}
            							else {
HXLINE( 861)								_hx_tmp16 = true;
            							}
HXDLIN( 861)							if (_hx_tmp16) {
HXLINE( 861)								_hx_tmp15 = s2;
            							}
            							else {
HXLINE( 861)								_hx_tmp15 = (s2 + HX_(".0",42,28,00,00));
            							}
HXLINE( 862)							::String s3 = (HX_("",00,00,00,00) + ::Std_obj::string((( (Float)((textures->__get(i2).StaticCast<  ::peote::view::Texture >()->slotsY * textures->__get(i2).StaticCast<  ::peote::view::Texture >()->slotHeight)) ) / ( (Float)(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->height) ))));
HXDLIN( 862)							::String _hx_tmp17;
HXDLIN( 862)							bool _hx_tmp18;
HXDLIN( 862)							if ((s3.indexOf(HX_(".",2e,00,00,00),null()) == -1)) {
HXLINE( 862)								_hx_tmp18 = (s3.indexOf(HX_("e-",28,58,00,00),null()) != -1);
            							}
            							else {
HXLINE( 862)								_hx_tmp18 = true;
            							}
HXDLIN( 862)							if (_hx_tmp18) {
HXLINE( 862)								_hx_tmp17 = s3;
            							}
            							else {
HXLINE( 862)								_hx_tmp17 = (s3 + HX_(".0",42,28,00,00));
            							}
HXLINE( 867)							bool _hx_tmp19;
HXDLIN( 867)							if ((i2 == 0)) {
HXLINE( 867)								_hx_tmp19 = true;
            							}
            							else {
HXLINE( 867)								_hx_tmp19 = false;
            							}
HXDLIN( 867)							bool _hx_tmp20;
HXDLIN( 867)							if ((i2 == (textures->length - 1))) {
HXLINE( 867)								_hx_tmp20 = true;
            							}
            							else {
HXLINE( 867)								_hx_tmp20 = false;
            							}
HXLINE( 854)							units->push( ::Dynamic(::hx::Anon_obj::Create(14)
            								->setFixed(0,HX_("SLOT_WIDTH",a5,6d,a4,87),_hx_tmp11)
            								->setFixed(1,HX_("TEXTURE_HEIGHT",2b,06,76,88),(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->height + HX_(".0",42,28,00,00)))
            								->setFixed(2,HX_("SLOTS_X",ee,fa,01,93),_hx_tmp9)
            								->setFixed(3,HX_("SLOTS_Y",ef,fa,01,93),_hx_tmp10)
            								->setFixed(4,HX_("UNIT_VALUE",16,4c,43,be),((i2 + 1) + HX_(".0",42,28,00,00)))
            								->setFixed(5,HX_("TILES_X",be,6b,67,c5),(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->tilesX + HX_(".0",42,28,00,00)))
            								->setFixed(6,HX_("TILES_Y",bf,6b,67,c5),(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->tilesY + HX_(".0",42,28,00,00)))
            								->setFixed(7,HX_("SLOTS_HEIGHT",91,99,ea,cf),_hx_tmp17)
            								->setFixed(8,HX_("TEXTURE_WIDTH",22,90,77,d6),(textures->__get(i2).StaticCast<  ::peote::view::Texture >()->width + HX_(".0",42,28,00,00)))
            								->setFixed(9,HX_("SLOT_HEIGHT",48,fb,8a,de),_hx_tmp13)
            								->setFixed(10,HX_("TEXTURE",bb,9c,b4,1e),_hx_tmp8)
            								->setFixed(11,HX_("LAST",56,d2,6d,32),_hx_tmp20)
            								->setFixed(12,HX_("SLOTS_WIDTH",7c,eb,f2,7a),_hx_tmp15)
            								->setFixed(13,HX_("FIRST",10,b0,8b,7e),_hx_tmp19)));
            						}
            					}
HXLINE( 874)					bool used = ((this->used_by_ColorFormula & (1 << layer3)) > 0);
HXLINE( 875)					bool usedID = ((this->usedID_by_ColorFormula & (1 << layer3)) > 0);
HXLINE( 877)					( (::Array< ::Dynamic>)(this->glShaderConfig->__Field(HX_("TEXTURES",38,87,54,bf),::hx::paccDynamic)) )->push( ::Dynamic(::hx::Anon_obj::Create(4)
            						->setFixed(0,HX_("USED_ID",dd,3f,20,e6),usedID)
            						->setFixed(1,HX_("LAYER",b1,b9,ae,ed),layer3)
            						->setFixed(2,HX_("UNITS",4f,a1,d5,24),units)
            						->setFixed(3,HX_("USED",3d,5a,6e,38),used)));
            				}
            			}
            		}
HXLINE( 889)		this->glShaderConfig->__SetField(HX_("TEXTURE_DEFAULTS",d6,cb,f2,92),::Array_obj< ::Dynamic>::__new(0),::hx::paccDynamic);
HXLINE( 890)		{
HXLINE( 890)			int _g11 = 0;
HXDLIN( 890)			::Array< ::Dynamic> _g12 = this->textureID_Defaults;
HXDLIN( 890)			while((_g11 < _g12->length)){
HXLINE( 890)				 ::Dynamic defaults = _g12->__get(_g11);
HXDLIN( 890)				_g11 = (_g11 + 1);
HXLINE( 891)				( (::Array< ::Dynamic>)(this->glShaderConfig->__Field(HX_("TEXTURE_DEFAULTS",d6,cb,f2,92),::hx::paccDynamic)) )->push( ::Dynamic(::hx::Anon_obj::Create(2)
            					->setFixed(0,HX_("DEFAULT_VALUE",f3,59,2e,a5), ::Dynamic(defaults->__Field(HX_("value",71,7f,b8,31),::hx::paccDynamic)))
            					->setFixed(1,HX_("LAYER",b1,b9,ae,ed), ::Dynamic(defaults->__Field(HX_("layer",d1,81,c0,6f),::hx::paccDynamic)))));
            			}
            		}
HXLINE( 893)		bool _hx_tmp21;
HXDLIN( 893)		bool _hx_tmp22;
HXDLIN( 893)		if ((this->usedID_by_ColorFormula == 0)) {
HXLINE( 893)			_hx_tmp22 = (this->textureID_Defaults->length == 0);
            		}
            		else {
HXLINE( 893)			_hx_tmp22 = false;
            		}
HXDLIN( 893)		if (_hx_tmp22) {
HXLINE( 893)			_hx_tmp21 = false;
            		}
            		else {
HXLINE( 893)			_hx_tmp21 = true;
            		}
HXDLIN( 893)		this->glShaderConfig->__SetField(HX_("hasTEXTURE_FUNCTIONS",dd,c5,41,84),_hx_tmp21,::hx::paccDynamic);
HXLINE( 896)		if (::hx::IsNotNull( this->gl )) {
HXLINE( 896)			this->ready = false;
HXDLIN( 896)			{
HXLINE( 896)				this->gl->deleteShader(this->glVertexShader);
HXDLIN( 896)				this->gl->deleteShader(this->glFragmentShader);
HXDLIN( 896)				this->gl->deleteProgram(this->glProgram);
HXDLIN( 896)				if (::peote::view::BufferInterface_obj::hasPicking(this->buffer)) {
HXLINE( 896)					this->gl->deleteShader(this->glVertexShaderPicking);
HXDLIN( 896)					this->gl->deleteShader(this->glFragmentShaderPicking);
HXDLIN( 896)					this->gl->deleteProgram(this->glProgramPicking);
            				}
            			}
HXDLIN( 896)			{
HXLINE( 896)				this->createProg(null());
HXDLIN( 896)				if (::peote::view::BufferInterface_obj::hasPicking(this->buffer)) {
HXLINE( 896)					this->createProg(true);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Program_obj,updateTextures,(void))


::hx::ObjectPtr< Program_obj > Program_obj::__new(::Dynamic buffer) {
	::hx::ObjectPtr< Program_obj > __this = new Program_obj();
	__this->__construct(buffer);
	return __this;
}

::hx::ObjectPtr< Program_obj > Program_obj::__alloc(::hx::Ctx *_hx_ctx,::Dynamic buffer) {
	Program_obj *__this = (Program_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Program_obj), true, "peote.view.Program"));
	*(void **)__this = Program_obj::_hx_vtable;
	__this->__construct(buffer);
	return __this;
}

Program_obj::Program_obj()
{
}

void Program_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Program);
	HX_MARK_MEMBER_NAME(colorEnabled,"colorEnabled");
	HX_MARK_MEMBER_NAME(alphaEnabled,"alphaEnabled");
	HX_MARK_MEMBER_NAME(zIndexEnabled,"zIndexEnabled");
	HX_MARK_MEMBER_NAME(mask,"mask");
	HX_MARK_MEMBER_NAME(clearMask,"clearMask");
	HX_MARK_MEMBER_NAME(autoUpdateTextures,"autoUpdateTextures");
	HX_MARK_MEMBER_NAME(isVisible,"isVisible");
	HX_MARK_MEMBER_NAME(displays,"displays");
	HX_MARK_MEMBER_NAME(gl,"gl");
	HX_MARK_MEMBER_NAME(glProgram,"glProgram");
	HX_MARK_MEMBER_NAME(glProgramPicking,"glProgramPicking");
	HX_MARK_MEMBER_NAME(glVertexShader,"glVertexShader");
	HX_MARK_MEMBER_NAME(glFragmentShader,"glFragmentShader");
	HX_MARK_MEMBER_NAME(glVertexShaderPicking,"glVertexShaderPicking");
	HX_MARK_MEMBER_NAME(glFragmentShaderPicking,"glFragmentShaderPicking");
	HX_MARK_MEMBER_NAME(buffer,"buffer");
	HX_MARK_MEMBER_NAME(glShaderConfig,"glShaderConfig");
	HX_MARK_MEMBER_NAME(textureList,"textureList");
	HX_MARK_MEMBER_NAME(textureListPicking,"textureListPicking");
	HX_MARK_MEMBER_NAME(textureLayers,"textureLayers");
	HX_MARK_MEMBER_NAME(activeTextures,"activeTextures");
	HX_MARK_MEMBER_NAME(activeUnits,"activeUnits");
	HX_MARK_MEMBER_NAME(colorIdentifiers,"colorIdentifiers");
	HX_MARK_MEMBER_NAME(customIdentifiers,"customIdentifiers");
	HX_MARK_MEMBER_NAME(customVaryings,"customVaryings");
	HX_MARK_MEMBER_NAME(textureIdentifiers,"textureIdentifiers");
	HX_MARK_MEMBER_NAME(customTextureIdentifiers,"customTextureIdentifiers");
	HX_MARK_MEMBER_NAME(textureID_Defaults,"textureID_Defaults");
	HX_MARK_MEMBER_NAME(used_by_ColorFormula,"used_by_ColorFormula");
	HX_MARK_MEMBER_NAME(usedID_by_ColorFormula,"usedID_by_ColorFormula");
	HX_MARK_MEMBER_NAME(defaultFormulaVars,"defaultFormulaVars");
	HX_MARK_MEMBER_NAME(defaultColorFormula,"defaultColorFormula");
	HX_MARK_MEMBER_NAME(colorFormula,"colorFormula");
	HX_MARK_MEMBER_NAME(formula,"formula");
	HX_MARK_MEMBER_NAME(formulaHasChanged,"formulaHasChanged");
	HX_MARK_MEMBER_NAME(fragmentFloatPrecision,"fragmentFloatPrecision");
	HX_MARK_MEMBER_NAME(hasFragmentInjection,"hasFragmentInjection");
	HX_MARK_MEMBER_NAME(ready,"ready");
	HX_MARK_MEMBER_NAME(uRESOLUTION,"uRESOLUTION");
	HX_MARK_MEMBER_NAME(uZOOM,"uZOOM");
	HX_MARK_MEMBER_NAME(uOFFSET,"uOFFSET");
	HX_MARK_MEMBER_NAME(uTIME,"uTIME");
	HX_MARK_MEMBER_NAME(uRESOLUTION_PICK,"uRESOLUTION_PICK");
	HX_MARK_MEMBER_NAME(uZOOM_PICK,"uZOOM_PICK");
	HX_MARK_MEMBER_NAME(uOFFSET_PICK,"uOFFSET_PICK");
	HX_MARK_MEMBER_NAME(uTIME_PICK,"uTIME_PICK");
	HX_MARK_MEMBER_NAME(uniformFloatsVertex,"uniformFloatsVertex");
	HX_MARK_MEMBER_NAME(uniformFloatsFragment,"uniformFloatsFragment");
	HX_MARK_MEMBER_NAME(uniformFloats,"uniformFloats");
	HX_MARK_MEMBER_NAME(uniformFloatLocations,"uniformFloatLocations");
	HX_MARK_MEMBER_NAME(uniformFloatPickLocations,"uniformFloatPickLocations");
	HX_MARK_MEMBER_NAME(textureListItem,"textureListItem");
	HX_MARK_END_CLASS();
}

void Program_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(colorEnabled,"colorEnabled");
	HX_VISIT_MEMBER_NAME(alphaEnabled,"alphaEnabled");
	HX_VISIT_MEMBER_NAME(zIndexEnabled,"zIndexEnabled");
	HX_VISIT_MEMBER_NAME(mask,"mask");
	HX_VISIT_MEMBER_NAME(clearMask,"clearMask");
	HX_VISIT_MEMBER_NAME(autoUpdateTextures,"autoUpdateTextures");
	HX_VISIT_MEMBER_NAME(isVisible,"isVisible");
	HX_VISIT_MEMBER_NAME(displays,"displays");
	HX_VISIT_MEMBER_NAME(gl,"gl");
	HX_VISIT_MEMBER_NAME(glProgram,"glProgram");
	HX_VISIT_MEMBER_NAME(glProgramPicking,"glProgramPicking");
	HX_VISIT_MEMBER_NAME(glVertexShader,"glVertexShader");
	HX_VISIT_MEMBER_NAME(glFragmentShader,"glFragmentShader");
	HX_VISIT_MEMBER_NAME(glVertexShaderPicking,"glVertexShaderPicking");
	HX_VISIT_MEMBER_NAME(glFragmentShaderPicking,"glFragmentShaderPicking");
	HX_VISIT_MEMBER_NAME(buffer,"buffer");
	HX_VISIT_MEMBER_NAME(glShaderConfig,"glShaderConfig");
	HX_VISIT_MEMBER_NAME(textureList,"textureList");
	HX_VISIT_MEMBER_NAME(textureListPicking,"textureListPicking");
	HX_VISIT_MEMBER_NAME(textureLayers,"textureLayers");
	HX_VISIT_MEMBER_NAME(activeTextures,"activeTextures");
	HX_VISIT_MEMBER_NAME(activeUnits,"activeUnits");
	HX_VISIT_MEMBER_NAME(colorIdentifiers,"colorIdentifiers");
	HX_VISIT_MEMBER_NAME(customIdentifiers,"customIdentifiers");
	HX_VISIT_MEMBER_NAME(customVaryings,"customVaryings");
	HX_VISIT_MEMBER_NAME(textureIdentifiers,"textureIdentifiers");
	HX_VISIT_MEMBER_NAME(customTextureIdentifiers,"customTextureIdentifiers");
	HX_VISIT_MEMBER_NAME(textureID_Defaults,"textureID_Defaults");
	HX_VISIT_MEMBER_NAME(used_by_ColorFormula,"used_by_ColorFormula");
	HX_VISIT_MEMBER_NAME(usedID_by_ColorFormula,"usedID_by_ColorFormula");
	HX_VISIT_MEMBER_NAME(defaultFormulaVars,"defaultFormulaVars");
	HX_VISIT_MEMBER_NAME(defaultColorFormula,"defaultColorFormula");
	HX_VISIT_MEMBER_NAME(colorFormula,"colorFormula");
	HX_VISIT_MEMBER_NAME(formula,"formula");
	HX_VISIT_MEMBER_NAME(formulaHasChanged,"formulaHasChanged");
	HX_VISIT_MEMBER_NAME(fragmentFloatPrecision,"fragmentFloatPrecision");
	HX_VISIT_MEMBER_NAME(hasFragmentInjection,"hasFragmentInjection");
	HX_VISIT_MEMBER_NAME(ready,"ready");
	HX_VISIT_MEMBER_NAME(uRESOLUTION,"uRESOLUTION");
	HX_VISIT_MEMBER_NAME(uZOOM,"uZOOM");
	HX_VISIT_MEMBER_NAME(uOFFSET,"uOFFSET");
	HX_VISIT_MEMBER_NAME(uTIME,"uTIME");
	HX_VISIT_MEMBER_NAME(uRESOLUTION_PICK,"uRESOLUTION_PICK");
	HX_VISIT_MEMBER_NAME(uZOOM_PICK,"uZOOM_PICK");
	HX_VISIT_MEMBER_NAME(uOFFSET_PICK,"uOFFSET_PICK");
	HX_VISIT_MEMBER_NAME(uTIME_PICK,"uTIME_PICK");
	HX_VISIT_MEMBER_NAME(uniformFloatsVertex,"uniformFloatsVertex");
	HX_VISIT_MEMBER_NAME(uniformFloatsFragment,"uniformFloatsFragment");
	HX_VISIT_MEMBER_NAME(uniformFloats,"uniformFloats");
	HX_VISIT_MEMBER_NAME(uniformFloatLocations,"uniformFloatLocations");
	HX_VISIT_MEMBER_NAME(uniformFloatPickLocations,"uniformFloatPickLocations");
	HX_VISIT_MEMBER_NAME(textureListItem,"textureListItem");
}

::hx::Val Program_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { return ::hx::Val( gl ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"mask") ) { return ::hx::Val( mask ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"ready") ) { return ::hx::Val( ready ); }
		if (HX_FIELD_EQ(inName,"uZOOM") ) { return ::hx::Val( uZOOM ); }
		if (HX_FIELD_EQ(inName,"uTIME") ) { return ::hx::Val( uTIME ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { return ::hx::Val( buffer ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"formula") ) { return ::hx::Val( formula ); }
		if (HX_FIELD_EQ(inName,"uOFFSET") ) { return ::hx::Val( uOFFSET ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"displays") ) { return ::hx::Val( displays ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"clearMask") ) { return ::hx::Val( clearMask ); }
		if (HX_FIELD_EQ(inName,"isVisible") ) { return ::hx::Val( isVisible ); }
		if (HX_FIELD_EQ(inName,"glProgram") ) { return ::hx::Val( glProgram ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"createProg") ) { return ::hx::Val( createProg_dyn() ); }
		if (HX_FIELD_EQ(inName,"uZOOM_PICK") ) { return ::hx::Val( uZOOM_PICK ); }
		if (HX_FIELD_EQ(inName,"uTIME_PICK") ) { return ::hx::Val( uTIME_PICK ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"textureList") ) { return ::hx::Val( textureList ); }
		if (HX_FIELD_EQ(inName,"activeUnits") ) { return ::hx::Val( activeUnits ); }
		if (HX_FIELD_EQ(inName,"uRESOLUTION") ) { return ::hx::Val( uRESOLUTION ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"colorEnabled") ) { return ::hx::Val( colorEnabled ); }
		if (HX_FIELD_EQ(inName,"alphaEnabled") ) { return ::hx::Val( alphaEnabled ); }
		if (HX_FIELD_EQ(inName,"colorFormula") ) { return ::hx::Val( colorFormula ); }
		if (HX_FIELD_EQ(inName,"addToDisplay") ) { return ::hx::Val( addToDisplay_dyn() ); }
		if (HX_FIELD_EQ(inName,"uOFFSET_PICK") ) { return ::hx::Val( uOFFSET_PICK ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"zIndexEnabled") ) { return ::hx::Val( zIndexEnabled ); }
		if (HX_FIELD_EQ(inName,"textureLayers") ) { return ::hx::Val( textureLayers ); }
		if (HX_FIELD_EQ(inName,"uniformFloats") ) { return ::hx::Val( uniformFloats ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"glVertexShader") ) { return ::hx::Val( glVertexShader ); }
		if (HX_FIELD_EQ(inName,"glShaderConfig") ) { return ::hx::Val( glShaderConfig ); }
		if (HX_FIELD_EQ(inName,"activeTextures") ) { return ::hx::Val( activeTextures ); }
		if (HX_FIELD_EQ(inName,"customVaryings") ) { return ::hx::Val( customVaryings ); }
		if (HX_FIELD_EQ(inName,"updateTextures") ) { return ::hx::Val( updateTextures_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"setColorFormula") ) { return ::hx::Val( setColorFormula_dyn() ); }
		if (HX_FIELD_EQ(inName,"textureListItem") ) { return ::hx::Val( textureListItem ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"glProgramPicking") ) { return ::hx::Val( glProgramPicking ); }
		if (HX_FIELD_EQ(inName,"glFragmentShader") ) { return ::hx::Val( glFragmentShader ); }
		if (HX_FIELD_EQ(inName,"colorIdentifiers") ) { return ::hx::Val( colorIdentifiers ); }
		if (HX_FIELD_EQ(inName,"uRESOLUTION_PICK") ) { return ::hx::Val( uRESOLUTION_PICK ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"customIdentifiers") ) { return ::hx::Val( customIdentifiers ); }
		if (HX_FIELD_EQ(inName,"formulaHasChanged") ) { return ::hx::Val( formulaHasChanged ); }
		if (HX_FIELD_EQ(inName,"parseColorFormula") ) { return ::hx::Val( parseColorFormula_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"autoUpdateTextures") ) { return ::hx::Val( autoUpdateTextures ); }
		if (HX_FIELD_EQ(inName,"textureListPicking") ) { return ::hx::Val( textureListPicking ); }
		if (HX_FIELD_EQ(inName,"textureIdentifiers") ) { return ::hx::Val( textureIdentifiers ); }
		if (HX_FIELD_EQ(inName,"textureID_Defaults") ) { return ::hx::Val( textureID_Defaults ); }
		if (HX_FIELD_EQ(inName,"defaultFormulaVars") ) { return ::hx::Val( defaultFormulaVars ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"defaultColorFormula") ) { return ::hx::Val( defaultColorFormula ); }
		if (HX_FIELD_EQ(inName,"uniformFloatsVertex") ) { return ::hx::Val( uniformFloatsVertex ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"used_by_ColorFormula") ) { return ::hx::Val( used_by_ColorFormula ); }
		if (HX_FIELD_EQ(inName,"hasFragmentInjection") ) { return ::hx::Val( hasFragmentInjection ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"glVertexShaderPicking") ) { return ::hx::Val( glVertexShaderPicking ); }
		if (HX_FIELD_EQ(inName,"uniformFloatsFragment") ) { return ::hx::Val( uniformFloatsFragment ); }
		if (HX_FIELD_EQ(inName,"uniformFloatLocations") ) { return ::hx::Val( uniformFloatLocations ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"usedID_by_ColorFormula") ) { return ::hx::Val( usedID_by_ColorFormula ); }
		if (HX_FIELD_EQ(inName,"fragmentFloatPrecision") ) { return ::hx::Val( fragmentFloatPrecision ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"glFragmentShaderPicking") ) { return ::hx::Val( glFragmentShaderPicking ); }
		if (HX_FIELD_EQ(inName,"accumulateUniformsFloat") ) { return ::hx::Val( accumulateUniformsFloat_dyn() ); }
		if (HX_FIELD_EQ(inName,"parseAndResolveFormulas") ) { return ::hx::Val( parseAndResolveFormulas_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"customTextureIdentifiers") ) { return ::hx::Val( customTextureIdentifiers ); }
		if (HX_FIELD_EQ(inName,"injectIntoFragmentShader") ) { return ::hx::Val( injectIntoFragmentShader_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"uniformFloatPickLocations") ) { return ::hx::Val( uniformFloatPickLocations ); }
		if (HX_FIELD_EQ(inName,"generateUniformFloatsGLSL") ) { return ::hx::Val( generateUniformFloatsGLSL_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Program_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { gl=inValue.Cast<  ::lime::_internal::backend::native::NativeOpenGLRenderContext >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"mask") ) { mask=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"ready") ) { ready=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uZOOM") ) { uZOOM=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uTIME") ) { uTIME=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { buffer=inValue.Cast< ::Dynamic >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"formula") ) { formula=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uOFFSET") ) { uOFFSET=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"displays") ) { displays=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"clearMask") ) { clearMask=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"isVisible") ) { isVisible=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"glProgram") ) { glProgram=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"uZOOM_PICK") ) { uZOOM_PICK=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uTIME_PICK") ) { uTIME_PICK=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"textureList") ) { textureList=inValue.Cast<  ::peote::view::utils::RenderList_peote_view_ActiveTexture >(); return inValue; }
		if (HX_FIELD_EQ(inName,"activeUnits") ) { activeUnits=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uRESOLUTION") ) { uRESOLUTION=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"colorEnabled") ) { colorEnabled=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphaEnabled") ) { alphaEnabled=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorFormula") ) { colorFormula=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uOFFSET_PICK") ) { uOFFSET_PICK=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"zIndexEnabled") ) { zIndexEnabled=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textureLayers") ) { textureLayers=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uniformFloats") ) { uniformFloats=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"glVertexShader") ) { glVertexShader=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"glShaderConfig") ) { glShaderConfig=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"activeTextures") ) { activeTextures=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"customVaryings") ) { customVaryings=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"textureListItem") ) { textureListItem=inValue.Cast<  ::peote::view::utils::RenderListItem_peote_view_ActiveTexture >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"glProgramPicking") ) { glProgramPicking=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"glFragmentShader") ) { glFragmentShader=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorIdentifiers") ) { colorIdentifiers=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uRESOLUTION_PICK") ) { uRESOLUTION_PICK=inValue.Cast< int >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"customIdentifiers") ) { customIdentifiers=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"formulaHasChanged") ) { formulaHasChanged=inValue.Cast< bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"autoUpdateTextures") ) { autoUpdateTextures=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textureListPicking") ) { textureListPicking=inValue.Cast<  ::peote::view::utils::RenderList_peote_view_ActiveTexture >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textureIdentifiers") ) { textureIdentifiers=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textureID_Defaults") ) { textureID_Defaults=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"defaultFormulaVars") ) { defaultFormulaVars=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"defaultColorFormula") ) { defaultColorFormula=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uniformFloatsVertex") ) { uniformFloatsVertex=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"used_by_ColorFormula") ) { used_by_ColorFormula=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"hasFragmentInjection") ) { hasFragmentInjection=inValue.Cast< bool >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"glVertexShaderPicking") ) { glVertexShaderPicking=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uniformFloatsFragment") ) { uniformFloatsFragment=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uniformFloatLocations") ) { uniformFloatLocations=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"usedID_by_ColorFormula") ) { usedID_by_ColorFormula=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fragmentFloatPrecision") ) { fragmentFloatPrecision=inValue.Cast< ::String >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"glFragmentShaderPicking") ) { glFragmentShaderPicking=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"customTextureIdentifiers") ) { customTextureIdentifiers=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"uniformFloatPickLocations") ) { uniformFloatPickLocations=inValue.Cast< ::Array< int > >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Program_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("colorEnabled",5e,fd,87,a7));
	outFields->push(HX_("alphaEnabled",c3,4c,a4,11));
	outFields->push(HX_("zIndexEnabled",29,13,61,ce));
	outFields->push(HX_("mask",ec,40,56,48));
	outFields->push(HX_("clearMask",19,29,17,bc));
	outFields->push(HX_("autoUpdateTextures",30,e2,87,f1));
	outFields->push(HX_("isVisible",a8,f5,22,a7));
	outFields->push(HX_("displays",f1,cf,9a,25));
	outFields->push(HX_("gl",25,5a,00,00));
	outFields->push(HX_("glProgram",df,d6,b3,c1));
	outFields->push(HX_("glProgramPicking",82,a1,e7,6a));
	outFields->push(HX_("glVertexShader",6e,7b,39,46));
	outFields->push(HX_("glFragmentShader",1a,d4,b9,e2));
	outFields->push(HX_("glVertexShaderPicking",d3,3c,4c,f5));
	outFields->push(HX_("glFragmentShaderPicking",a7,91,eb,ad));
	outFields->push(HX_("buffer",00,bd,94,d0));
	outFields->push(HX_("glShaderConfig",8c,bd,be,c0));
	outFields->push(HX_("textureList",d9,1a,32,fe));
	outFields->push(HX_("textureListPicking",c8,30,4b,e9));
	outFields->push(HX_("textureLayers",bd,e8,c8,eb));
	outFields->push(HX_("activeTextures",1e,2b,27,7e));
	outFields->push(HX_("activeUnits",c9,69,2c,03));
	outFields->push(HX_("colorIdentifiers",47,bf,c3,c4));
	outFields->push(HX_("customIdentifiers",b9,cf,0c,8b));
	outFields->push(HX_("customVaryings",d4,02,56,c7));
	outFields->push(HX_("textureIdentifiers",cf,2a,bc,56));
	outFields->push(HX_("customTextureIdentifiers",e0,96,09,fa));
	outFields->push(HX_("textureID_Defaults",db,ef,9c,7d));
	outFields->push(HX_("used_by_ColorFormula",c9,2d,bf,23));
	outFields->push(HX_("usedID_by_ColorFormula",e4,5c,0f,98));
	outFields->push(HX_("defaultFormulaVars",f1,4e,de,04));
	outFields->push(HX_("defaultColorFormula",a4,a2,ed,84));
	outFields->push(HX_("colorFormula",43,e0,94,08));
	outFields->push(HX_("formula",66,e7,3d,df));
	outFields->push(HX_("formulaHasChanged",c0,ff,14,87));
	outFields->push(HX_("fragmentFloatPrecision",f2,5b,99,04));
	outFields->push(HX_("hasFragmentInjection",2d,95,d4,d5));
	outFields->push(HX_("ready",63,a0,ba,e6));
	outFields->push(HX_("uRESOLUTION",e1,ad,f9,44));
	outFields->push(HX_("uZOOM",08,4a,9b,99));
	outFields->push(HX_("uOFFSET",c8,89,11,14));
	outFields->push(HX_("uTIME",02,73,9f,95));
	outFields->push(HX_("uRESOLUTION_PICK",3f,2f,49,b0));
	outFields->push(HX_("uZOOM_PICK",b8,25,3d,38));
	outFields->push(HX_("uOFFSET_PICK",f8,cd,47,52));
	outFields->push(HX_("uTIME_PICK",7e,32,60,69));
	outFields->push(HX_("uniformFloatsVertex",6f,99,27,5b));
	outFields->push(HX_("uniformFloatsFragment",9b,f6,b8,6d));
	outFields->push(HX_("uniformFloats",ab,b7,d1,b3));
	outFields->push(HX_("uniformFloatLocations",b6,8f,dc,7d));
	outFields->push(HX_("uniformFloatPickLocations",95,4e,1f,d8));
	outFields->push(HX_("textureListItem",8c,ec,d3,8c));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Program_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(Program_obj,colorEnabled),HX_("colorEnabled",5e,fd,87,a7)},
	{::hx::fsBool,(int)offsetof(Program_obj,alphaEnabled),HX_("alphaEnabled",c3,4c,a4,11)},
	{::hx::fsBool,(int)offsetof(Program_obj,zIndexEnabled),HX_("zIndexEnabled",29,13,61,ce)},
	{::hx::fsInt,(int)offsetof(Program_obj,mask),HX_("mask",ec,40,56,48)},
	{::hx::fsBool,(int)offsetof(Program_obj,clearMask),HX_("clearMask",19,29,17,bc)},
	{::hx::fsBool,(int)offsetof(Program_obj,autoUpdateTextures),HX_("autoUpdateTextures",30,e2,87,f1)},
	{::hx::fsBool,(int)offsetof(Program_obj,isVisible),HX_("isVisible",a8,f5,22,a7)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Program_obj,displays),HX_("displays",f1,cf,9a,25)},
	{::hx::fsObject /*  ::lime::_internal::backend::native::NativeOpenGLRenderContext */ ,(int)offsetof(Program_obj,gl),HX_("gl",25,5a,00,00)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Program_obj,glProgram),HX_("glProgram",df,d6,b3,c1)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Program_obj,glProgramPicking),HX_("glProgramPicking",82,a1,e7,6a)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Program_obj,glVertexShader),HX_("glVertexShader",6e,7b,39,46)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Program_obj,glFragmentShader),HX_("glFragmentShader",1a,d4,b9,e2)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Program_obj,glVertexShaderPicking),HX_("glVertexShaderPicking",d3,3c,4c,f5)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Program_obj,glFragmentShaderPicking),HX_("glFragmentShaderPicking",a7,91,eb,ad)},
	{::hx::fsObject /* ::Dynamic */ ,(int)offsetof(Program_obj,buffer),HX_("buffer",00,bd,94,d0)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Program_obj,glShaderConfig),HX_("glShaderConfig",8c,bd,be,c0)},
	{::hx::fsObject /*  ::peote::view::utils::RenderList_peote_view_ActiveTexture */ ,(int)offsetof(Program_obj,textureList),HX_("textureList",d9,1a,32,fe)},
	{::hx::fsObject /*  ::peote::view::utils::RenderList_peote_view_ActiveTexture */ ,(int)offsetof(Program_obj,textureListPicking),HX_("textureListPicking",c8,30,4b,e9)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(Program_obj,textureLayers),HX_("textureLayers",bd,e8,c8,eb)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Program_obj,activeTextures),HX_("activeTextures",1e,2b,27,7e)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Program_obj,activeUnits),HX_("activeUnits",c9,69,2c,03)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(Program_obj,colorIdentifiers),HX_("colorIdentifiers",47,bf,c3,c4)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(Program_obj,customIdentifiers),HX_("customIdentifiers",b9,cf,0c,8b)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(Program_obj,customVaryings),HX_("customVaryings",d4,02,56,c7)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(Program_obj,textureIdentifiers),HX_("textureIdentifiers",cf,2a,bc,56)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(Program_obj,customTextureIdentifiers),HX_("customTextureIdentifiers",e0,96,09,fa)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Program_obj,textureID_Defaults),HX_("textureID_Defaults",db,ef,9c,7d)},
	{::hx::fsInt,(int)offsetof(Program_obj,used_by_ColorFormula),HX_("used_by_ColorFormula",c9,2d,bf,23)},
	{::hx::fsInt,(int)offsetof(Program_obj,usedID_by_ColorFormula),HX_("usedID_by_ColorFormula",e4,5c,0f,98)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(Program_obj,defaultFormulaVars),HX_("defaultFormulaVars",f1,4e,de,04)},
	{::hx::fsString,(int)offsetof(Program_obj,defaultColorFormula),HX_("defaultColorFormula",a4,a2,ed,84)},
	{::hx::fsString,(int)offsetof(Program_obj,colorFormula),HX_("colorFormula",43,e0,94,08)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(Program_obj,formula),HX_("formula",66,e7,3d,df)},
	{::hx::fsBool,(int)offsetof(Program_obj,formulaHasChanged),HX_("formulaHasChanged",c0,ff,14,87)},
	{::hx::fsString,(int)offsetof(Program_obj,fragmentFloatPrecision),HX_("fragmentFloatPrecision",f2,5b,99,04)},
	{::hx::fsBool,(int)offsetof(Program_obj,hasFragmentInjection),HX_("hasFragmentInjection",2d,95,d4,d5)},
	{::hx::fsBool,(int)offsetof(Program_obj,ready),HX_("ready",63,a0,ba,e6)},
	{::hx::fsInt,(int)offsetof(Program_obj,uRESOLUTION),HX_("uRESOLUTION",e1,ad,f9,44)},
	{::hx::fsInt,(int)offsetof(Program_obj,uZOOM),HX_("uZOOM",08,4a,9b,99)},
	{::hx::fsInt,(int)offsetof(Program_obj,uOFFSET),HX_("uOFFSET",c8,89,11,14)},
	{::hx::fsInt,(int)offsetof(Program_obj,uTIME),HX_("uTIME",02,73,9f,95)},
	{::hx::fsInt,(int)offsetof(Program_obj,uRESOLUTION_PICK),HX_("uRESOLUTION_PICK",3f,2f,49,b0)},
	{::hx::fsInt,(int)offsetof(Program_obj,uZOOM_PICK),HX_("uZOOM_PICK",b8,25,3d,38)},
	{::hx::fsInt,(int)offsetof(Program_obj,uOFFSET_PICK),HX_("uOFFSET_PICK",f8,cd,47,52)},
	{::hx::fsInt,(int)offsetof(Program_obj,uTIME_PICK),HX_("uTIME_PICK",7e,32,60,69)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Program_obj,uniformFloatsVertex),HX_("uniformFloatsVertex",6f,99,27,5b)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Program_obj,uniformFloatsFragment),HX_("uniformFloatsFragment",9b,f6,b8,6d)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Program_obj,uniformFloats),HX_("uniformFloats",ab,b7,d1,b3)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Program_obj,uniformFloatLocations),HX_("uniformFloatLocations",b6,8f,dc,7d)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Program_obj,uniformFloatPickLocations),HX_("uniformFloatPickLocations",95,4e,1f,d8)},
	{::hx::fsObject /*  ::peote::view::utils::RenderListItem_peote_view_ActiveTexture */ ,(int)offsetof(Program_obj,textureListItem),HX_("textureListItem",8c,ec,d3,8c)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Program_obj_sStaticStorageInfo = 0;
#endif

static ::String Program_obj_sMemberFields[] = {
	HX_("colorEnabled",5e,fd,87,a7),
	HX_("alphaEnabled",c3,4c,a4,11),
	HX_("zIndexEnabled",29,13,61,ce),
	HX_("mask",ec,40,56,48),
	HX_("clearMask",19,29,17,bc),
	HX_("autoUpdateTextures",30,e2,87,f1),
	HX_("isVisible",a8,f5,22,a7),
	HX_("displays",f1,cf,9a,25),
	HX_("gl",25,5a,00,00),
	HX_("glProgram",df,d6,b3,c1),
	HX_("glProgramPicking",82,a1,e7,6a),
	HX_("glVertexShader",6e,7b,39,46),
	HX_("glFragmentShader",1a,d4,b9,e2),
	HX_("glVertexShaderPicking",d3,3c,4c,f5),
	HX_("glFragmentShaderPicking",a7,91,eb,ad),
	HX_("buffer",00,bd,94,d0),
	HX_("glShaderConfig",8c,bd,be,c0),
	HX_("textureList",d9,1a,32,fe),
	HX_("textureListPicking",c8,30,4b,e9),
	HX_("textureLayers",bd,e8,c8,eb),
	HX_("activeTextures",1e,2b,27,7e),
	HX_("activeUnits",c9,69,2c,03),
	HX_("colorIdentifiers",47,bf,c3,c4),
	HX_("customIdentifiers",b9,cf,0c,8b),
	HX_("customVaryings",d4,02,56,c7),
	HX_("textureIdentifiers",cf,2a,bc,56),
	HX_("customTextureIdentifiers",e0,96,09,fa),
	HX_("textureID_Defaults",db,ef,9c,7d),
	HX_("used_by_ColorFormula",c9,2d,bf,23),
	HX_("usedID_by_ColorFormula",e4,5c,0f,98),
	HX_("defaultFormulaVars",f1,4e,de,04),
	HX_("defaultColorFormula",a4,a2,ed,84),
	HX_("colorFormula",43,e0,94,08),
	HX_("formula",66,e7,3d,df),
	HX_("formulaHasChanged",c0,ff,14,87),
	HX_("fragmentFloatPrecision",f2,5b,99,04),
	HX_("hasFragmentInjection",2d,95,d4,d5),
	HX_("addToDisplay",a6,83,32,ea),
	HX_("ready",63,a0,ba,e6),
	HX_("createProg",b6,88,ec,5c),
	HX_("uRESOLUTION",e1,ad,f9,44),
	HX_("uZOOM",08,4a,9b,99),
	HX_("uOFFSET",c8,89,11,14),
	HX_("uTIME",02,73,9f,95),
	HX_("uRESOLUTION_PICK",3f,2f,49,b0),
	HX_("uZOOM_PICK",b8,25,3d,38),
	HX_("uOFFSET_PICK",f8,cd,47,52),
	HX_("uTIME_PICK",7e,32,60,69),
	HX_("uniformFloatsVertex",6f,99,27,5b),
	HX_("uniformFloatsFragment",9b,f6,b8,6d),
	HX_("uniformFloats",ab,b7,d1,b3),
	HX_("uniformFloatLocations",b6,8f,dc,7d),
	HX_("uniformFloatPickLocations",95,4e,1f,d8),
	HX_("parseColorFormula",16,bd,6d,e5),
	HX_("setColorFormula",05,b3,4a,27),
	HX_("injectIntoFragmentShader",c6,66,0f,c1),
	HX_("generateUniformFloatsGLSL",34,78,1f,1f),
	HX_("accumulateUniformsFloat",5b,19,33,ac),
	HX_("parseAndResolveFormulas",55,c1,01,bb),
	HX_("updateTextures",61,ea,f8,9a),
	HX_("textureListItem",8c,ec,d3,8c),
	::String(null()) };

::hx::Class Program_obj::__mClass;

void Program_obj::__register()
{
	Program_obj _hx_dummy;
	Program_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("peote.view.Program",de,98,33,0a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Program_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Program_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Program_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Program_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace peote
} // end namespace view
