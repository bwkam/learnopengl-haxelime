// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeOpenGLRenderContext
#include <lime/_internal/backend/native/NativeOpenGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_utils__DataPointer_DataPointer_Impl_
#include <lime/utils/_DataPointer/DataPointer_Impl_.h>
#endif
#ifndef INCLUDED_peote_view_Display
#include <peote/view/Display.h>
#endif
#ifndef INCLUDED_peote_view_Program
#include <peote/view/Program.h>
#endif
#ifndef INCLUDED_peote_view_Texture
#include <peote/view/Texture.h>
#endif
#ifndef INCLUDED_peote_view__TextureData_TextureDataImpl
#include <peote/view/_TextureData/TextureDataImpl.h>
#endif
#ifndef INCLUDED_peote_view_utils_TexUtils
#include <peote/view/utils/TexUtils.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_7b1f727ae22f3e8e_17_new,"peote.view.Texture","new",0xb8eaf6a7,"peote.view.Texture.new","peote/view/Texture.hx",17,0xcce76f09)
HX_LOCAL_STACK_FRAME(_hx_pos_7b1f727ae22f3e8e_254_bufferImage,"peote.view.Texture","bufferImage",0x58d5f782,"peote.view.Texture.bufferImage","peote/view/Texture.hx",254,0xcce76f09)
namespace peote{
namespace view{

void Texture_obj::__construct(int slotWidth,int slotHeight,::hx::Null< int >  __o_imageSlots,::hx::Null< int >  __o_colorChannels,::hx::Null< bool >  __o_createMipmaps,::hx::Null< int >  __o_minFilter,::hx::Null< int >  __o_magFilter,::hx::Null< bool >  __o_useFloat,::hx::Null< int >  __o_maxTextureSize){
            		int imageSlots = __o_imageSlots.Default(1);
            		int colorChannels = __o_colorChannels.Default(4);
            		bool createMipmaps = __o_createMipmaps.Default(false);
            		int minFilter = __o_minFilter.Default(0);
            		int magFilter = __o_magFilter.Default(0);
            		bool useFloat = __o_useFloat.Default(false);
            		int maxTextureSize = __o_maxTextureSize.Default(16384);
            	HX_GC_STACKFRAME(&_hx_pos_7b1f727ae22f3e8e_17_new)
HXLINE(  53)		this->displays = ::Array_obj< ::Dynamic>::__new();
HXLINE(  52)		this->programs = ::Array_obj< ::Dynamic>::__new();
HXLINE(  50)		this->updated = false;
HXLINE(  48)		this->useFloat = false;
HXLINE(  47)		this->minFilter = 0;
HXLINE(  46)		this->magFilter = 0;
HXLINE(  45)		this->createMipmaps = false;
HXLINE(  43)		this->images =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
HXLINE(  41)		this->tilesY = 1;
HXLINE(  40)		this->tilesX = 1;
HXLINE(  36)		this->slotsY = 1;
HXLINE(  35)		this->slotsX = 1;
HXLINE(  33)		this->freeSlots = 1;
HXLINE(  32)		this->imageSlots = 1;
HXLINE(  30)		this->height = 0;
HXLINE(  29)		this->width = 0;
HXLINE(  27)		this->colorChannels = 4;
HXLINE(  25)		this->clearOnRenderInto = true;
HXLINE(  24)		this->glDepthBuffer = null();
HXLINE(  23)		this->framebuffer = null();
HXLINE(  21)		this->glTexture = null();
HXLINE(  19)		this->gl = null();
HXLINE(  58)		this->slotWidth = slotWidth;
HXLINE(  59)		this->slotHeight = slotHeight;
HXLINE(  60)		this->imageSlots = (this->freeSlots = imageSlots);
HXLINE(  61)		this->colorChannels = colorChannels;
HXLINE(  62)		this->createMipmaps = createMipmaps;
HXLINE(  63)		this->magFilter = magFilter;
HXLINE(  64)		this->minFilter = minFilter;
HXLINE(  65)		this->useFloat = useFloat;
HXLINE(  68)		 ::Dynamic p = ::peote::view::utils::TexUtils_obj::optimalTextureSize(imageSlots,slotWidth,slotHeight,maxTextureSize,null(),null());
HXLINE(  69)		this->width = ( (int)(p->__Field(HX_("width",06,b6,62,ca),::hx::paccDynamic)) );
HXLINE(  70)		this->height = ( (int)(p->__Field(HX_("height",e7,07,4c,02),::hx::paccDynamic)) );
HXLINE(  71)		this->slotsX = ( (int)(p->__Field(HX_("slotsX",03,3e,08,74),::hx::paccDynamic)) );
HXLINE(  72)		this->slotsY = ( (int)(p->__Field(HX_("slotsY",04,3e,08,74),::hx::paccDynamic)) );
            	}

Dynamic Texture_obj::__CreateEmpty() { return new Texture_obj; }

void *Texture_obj::_hx_vtable = 0;

Dynamic Texture_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Texture_obj > _hx_result = new Texture_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8]);
	return _hx_result;
}

bool Texture_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x074ad0b7;
}

void Texture_obj::bufferImage( ::peote::view::_TextureData::TextureDataImpl image, ::Dynamic imgProp){
            	HX_GC_STACKFRAME(&_hx_pos_7b1f727ae22f3e8e_254_bufferImage)
HXLINE( 259)		{
HXLINE( 259)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext gl = this->gl;
HXDLIN( 259)			int x = (this->slotWidth * ::hx::Mod(imgProp->__Field(HX_("imageSlot",f9,72,8a,2e),::hx::paccDynamic),this->slotsX));
HXDLIN( 259)			int y = (this->slotHeight * ::Math_obj::floor((( (Float)(imgProp->__Field(HX_("imageSlot",f9,72,8a,2e),::hx::paccDynamic)) ) / ( (Float)(this->slotsX) ))));
HXDLIN( 259)			int w = image->width;
HXDLIN( 259)			int h = image->height;
HXDLIN( 259)			bool createMipmaps = this->createMipmaps;
HXDLIN( 259)			bool useFloat = this->useFloat;
HXDLIN( 259)			gl->bindTexture(gl->TEXTURE_2D,this->glTexture);
HXDLIN( 259)			if (useFloat) {
HXLINE( 259)				int size = (((w * h) * 4) * 4);
HXDLIN( 259)				 ::haxe::io::ArrayBufferViewImpl fa =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 259)				{
HXLINE( 259)					int _g = 0;
HXDLIN( 259)					int _g1 = ((w * h) * 4);
HXDLIN( 259)					while((_g < _g1)){
HXLINE( 259)						_g = (_g + 1);
HXDLIN( 259)						int i = (_g - 1);
HXDLIN( 259)						{
HXLINE( 259)							 ::haxe::io::ArrayBufferViewImpl this1 = image->dataUInt8;
HXDLIN( 259)							Float value = (( (Float)(this1->bytes->b->__get((i + this1->byteOffset))) ) / ( (Float)(255) ));
HXDLIN( 259)							bool _hx_tmp;
HXDLIN( 259)							if ((i >= 0)) {
HXLINE( 259)								_hx_tmp = (i < (fa->byteLength >> 2));
            							}
            							else {
HXLINE( 259)								_hx_tmp = false;
            							}
HXDLIN( 259)							if (_hx_tmp) {
HXLINE( 259)								fa->bytes->setFloat(((i << 2) + fa->byteOffset),value);
            							}
            						}
            					}
            				}
HXDLIN( 259)				{
HXLINE( 259)					int target = gl->TEXTURE_2D;
HXDLIN( 259)					int format = gl->RGBA;
HXDLIN( 259)					int type = gl->FLOAT;
HXDLIN( 259)					gl->texSubImage2D(target,0,x,y,w,h,format,type,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromBytes(fa->bytes));
            				}
            			}
            			else {
HXLINE( 259)				int target1 = gl->TEXTURE_2D;
HXDLIN( 259)				int format1 = gl->RGBA;
HXDLIN( 259)				int type1 = gl->UNSIGNED_BYTE;
HXDLIN( 259)				gl->texSubImage2D(target1,0,x,y,w,h,format1,type1,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromBytes(image->dataUInt8->bytes));
            			}
HXDLIN( 259)			if (createMipmaps) {
HXLINE( 259)				gl->generateMipmap(gl->TEXTURE_2D);
            			}
HXDLIN( 259)			gl->bindTexture(gl->TEXTURE_2D,null());
            		}
HXLINE( 265)		this->updated = true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Texture_obj,bufferImage,(void))


::hx::ObjectPtr< Texture_obj > Texture_obj::__new(int slotWidth,int slotHeight,::hx::Null< int >  __o_imageSlots,::hx::Null< int >  __o_colorChannels,::hx::Null< bool >  __o_createMipmaps,::hx::Null< int >  __o_minFilter,::hx::Null< int >  __o_magFilter,::hx::Null< bool >  __o_useFloat,::hx::Null< int >  __o_maxTextureSize) {
	::hx::ObjectPtr< Texture_obj > __this = new Texture_obj();
	__this->__construct(slotWidth,slotHeight,__o_imageSlots,__o_colorChannels,__o_createMipmaps,__o_minFilter,__o_magFilter,__o_useFloat,__o_maxTextureSize);
	return __this;
}

::hx::ObjectPtr< Texture_obj > Texture_obj::__alloc(::hx::Ctx *_hx_ctx,int slotWidth,int slotHeight,::hx::Null< int >  __o_imageSlots,::hx::Null< int >  __o_colorChannels,::hx::Null< bool >  __o_createMipmaps,::hx::Null< int >  __o_minFilter,::hx::Null< int >  __o_magFilter,::hx::Null< bool >  __o_useFloat,::hx::Null< int >  __o_maxTextureSize) {
	Texture_obj *__this = (Texture_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Texture_obj), true, "peote.view.Texture"));
	*(void **)__this = Texture_obj::_hx_vtable;
	__this->__construct(slotWidth,slotHeight,__o_imageSlots,__o_colorChannels,__o_createMipmaps,__o_minFilter,__o_magFilter,__o_useFloat,__o_maxTextureSize);
	return __this;
}

Texture_obj::Texture_obj()
{
}

void Texture_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Texture);
	HX_MARK_MEMBER_NAME(gl,"gl");
	HX_MARK_MEMBER_NAME(glTexture,"glTexture");
	HX_MARK_MEMBER_NAME(framebuffer,"framebuffer");
	HX_MARK_MEMBER_NAME(glDepthBuffer,"glDepthBuffer");
	HX_MARK_MEMBER_NAME(clearOnRenderInto,"clearOnRenderInto");
	HX_MARK_MEMBER_NAME(colorChannels,"colorChannels");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(imageSlots,"imageSlots");
	HX_MARK_MEMBER_NAME(freeSlots,"freeSlots");
	HX_MARK_MEMBER_NAME(slotsX,"slotsX");
	HX_MARK_MEMBER_NAME(slotsY,"slotsY");
	HX_MARK_MEMBER_NAME(slotWidth,"slotWidth");
	HX_MARK_MEMBER_NAME(slotHeight,"slotHeight");
	HX_MARK_MEMBER_NAME(tilesX,"tilesX");
	HX_MARK_MEMBER_NAME(tilesY,"tilesY");
	HX_MARK_MEMBER_NAME(images,"images");
	HX_MARK_MEMBER_NAME(createMipmaps,"createMipmaps");
	HX_MARK_MEMBER_NAME(magFilter,"magFilter");
	HX_MARK_MEMBER_NAME(minFilter,"minFilter");
	HX_MARK_MEMBER_NAME(useFloat,"useFloat");
	HX_MARK_MEMBER_NAME(updated,"updated");
	HX_MARK_MEMBER_NAME(programs,"programs");
	HX_MARK_MEMBER_NAME(displays,"displays");
	HX_MARK_END_CLASS();
}

void Texture_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(gl,"gl");
	HX_VISIT_MEMBER_NAME(glTexture,"glTexture");
	HX_VISIT_MEMBER_NAME(framebuffer,"framebuffer");
	HX_VISIT_MEMBER_NAME(glDepthBuffer,"glDepthBuffer");
	HX_VISIT_MEMBER_NAME(clearOnRenderInto,"clearOnRenderInto");
	HX_VISIT_MEMBER_NAME(colorChannels,"colorChannels");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(imageSlots,"imageSlots");
	HX_VISIT_MEMBER_NAME(freeSlots,"freeSlots");
	HX_VISIT_MEMBER_NAME(slotsX,"slotsX");
	HX_VISIT_MEMBER_NAME(slotsY,"slotsY");
	HX_VISIT_MEMBER_NAME(slotWidth,"slotWidth");
	HX_VISIT_MEMBER_NAME(slotHeight,"slotHeight");
	HX_VISIT_MEMBER_NAME(tilesX,"tilesX");
	HX_VISIT_MEMBER_NAME(tilesY,"tilesY");
	HX_VISIT_MEMBER_NAME(images,"images");
	HX_VISIT_MEMBER_NAME(createMipmaps,"createMipmaps");
	HX_VISIT_MEMBER_NAME(magFilter,"magFilter");
	HX_VISIT_MEMBER_NAME(minFilter,"minFilter");
	HX_VISIT_MEMBER_NAME(useFloat,"useFloat");
	HX_VISIT_MEMBER_NAME(updated,"updated");
	HX_VISIT_MEMBER_NAME(programs,"programs");
	HX_VISIT_MEMBER_NAME(displays,"displays");
}

::hx::Val Texture_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { return ::hx::Val( gl ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"slotsX") ) { return ::hx::Val( slotsX ); }
		if (HX_FIELD_EQ(inName,"slotsY") ) { return ::hx::Val( slotsY ); }
		if (HX_FIELD_EQ(inName,"tilesX") ) { return ::hx::Val( tilesX ); }
		if (HX_FIELD_EQ(inName,"tilesY") ) { return ::hx::Val( tilesY ); }
		if (HX_FIELD_EQ(inName,"images") ) { return ::hx::Val( images ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"updated") ) { return ::hx::Val( updated ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"useFloat") ) { return ::hx::Val( useFloat ); }
		if (HX_FIELD_EQ(inName,"programs") ) { return ::hx::Val( programs ); }
		if (HX_FIELD_EQ(inName,"displays") ) { return ::hx::Val( displays ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"glTexture") ) { return ::hx::Val( glTexture ); }
		if (HX_FIELD_EQ(inName,"freeSlots") ) { return ::hx::Val( freeSlots ); }
		if (HX_FIELD_EQ(inName,"slotWidth") ) { return ::hx::Val( slotWidth ); }
		if (HX_FIELD_EQ(inName,"magFilter") ) { return ::hx::Val( magFilter ); }
		if (HX_FIELD_EQ(inName,"minFilter") ) { return ::hx::Val( minFilter ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"imageSlots") ) { return ::hx::Val( imageSlots ); }
		if (HX_FIELD_EQ(inName,"slotHeight") ) { return ::hx::Val( slotHeight ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"framebuffer") ) { return ::hx::Val( framebuffer ); }
		if (HX_FIELD_EQ(inName,"bufferImage") ) { return ::hx::Val( bufferImage_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"glDepthBuffer") ) { return ::hx::Val( glDepthBuffer ); }
		if (HX_FIELD_EQ(inName,"colorChannels") ) { return ::hx::Val( colorChannels ); }
		if (HX_FIELD_EQ(inName,"createMipmaps") ) { return ::hx::Val( createMipmaps ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"clearOnRenderInto") ) { return ::hx::Val( clearOnRenderInto ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Texture_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { gl=inValue.Cast<  ::lime::_internal::backend::native::NativeOpenGLRenderContext >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"slotsX") ) { slotsX=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"slotsY") ) { slotsY=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tilesX") ) { tilesX=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tilesY") ) { tilesY=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"images") ) { images=inValue.Cast<  ::haxe::ds::ObjectMap >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"updated") ) { updated=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"useFloat") ) { useFloat=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"programs") ) { programs=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"displays") ) { displays=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"glTexture") ) { glTexture=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"freeSlots") ) { freeSlots=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"slotWidth") ) { slotWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"magFilter") ) { magFilter=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"minFilter") ) { minFilter=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"imageSlots") ) { imageSlots=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"slotHeight") ) { slotHeight=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"framebuffer") ) { framebuffer=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"glDepthBuffer") ) { glDepthBuffer=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorChannels") ) { colorChannels=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"createMipmaps") ) { createMipmaps=inValue.Cast< bool >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"clearOnRenderInto") ) { clearOnRenderInto=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Texture_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("gl",25,5a,00,00));
	outFields->push(HX_("glTexture",36,55,9b,6c));
	outFields->push(HX_("framebuffer",ed,14,48,7a));
	outFields->push(HX_("glDepthBuffer",3e,9c,05,04));
	outFields->push(HX_("clearOnRenderInto",42,3e,61,ca));
	outFields->push(HX_("colorChannels",d3,72,b1,6d));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("imageSlots",5a,27,9a,8a));
	outFields->push(HX_("freeSlots",69,c4,a3,60));
	outFields->push(HX_("slotsX",03,3e,08,74));
	outFields->push(HX_("slotsY",04,3e,08,74));
	outFields->push(HX_("slotWidth",28,cf,7e,aa));
	outFields->push(HX_("slotHeight",85,ec,c5,3a));
	outFields->push(HX_("tilesX",33,d7,28,1e));
	outFields->push(HX_("tilesY",34,d7,28,1e));
	outFields->push(HX_("images",b8,50,92,fe));
	outFields->push(HX_("createMipmaps",4f,82,96,5d));
	outFields->push(HX_("magFilter",ab,4e,d3,f1));
	outFields->push(HX_("minFilter",ea,1e,7d,de));
	outFields->push(HX_("useFloat",d5,27,02,ca));
	outFields->push(HX_("updated",3b,c2,cf,9d));
	outFields->push(HX_("programs",6f,e9,27,86));
	outFields->push(HX_("displays",f1,cf,9a,25));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Texture_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::lime::_internal::backend::native::NativeOpenGLRenderContext */ ,(int)offsetof(Texture_obj,gl),HX_("gl",25,5a,00,00)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Texture_obj,glTexture),HX_("glTexture",36,55,9b,6c)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Texture_obj,framebuffer),HX_("framebuffer",ed,14,48,7a)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Texture_obj,glDepthBuffer),HX_("glDepthBuffer",3e,9c,05,04)},
	{::hx::fsBool,(int)offsetof(Texture_obj,clearOnRenderInto),HX_("clearOnRenderInto",42,3e,61,ca)},
	{::hx::fsInt,(int)offsetof(Texture_obj,colorChannels),HX_("colorChannels",d3,72,b1,6d)},
	{::hx::fsInt,(int)offsetof(Texture_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsInt,(int)offsetof(Texture_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsInt,(int)offsetof(Texture_obj,imageSlots),HX_("imageSlots",5a,27,9a,8a)},
	{::hx::fsInt,(int)offsetof(Texture_obj,freeSlots),HX_("freeSlots",69,c4,a3,60)},
	{::hx::fsInt,(int)offsetof(Texture_obj,slotsX),HX_("slotsX",03,3e,08,74)},
	{::hx::fsInt,(int)offsetof(Texture_obj,slotsY),HX_("slotsY",04,3e,08,74)},
	{::hx::fsInt,(int)offsetof(Texture_obj,slotWidth),HX_("slotWidth",28,cf,7e,aa)},
	{::hx::fsInt,(int)offsetof(Texture_obj,slotHeight),HX_("slotHeight",85,ec,c5,3a)},
	{::hx::fsInt,(int)offsetof(Texture_obj,tilesX),HX_("tilesX",33,d7,28,1e)},
	{::hx::fsInt,(int)offsetof(Texture_obj,tilesY),HX_("tilesY",34,d7,28,1e)},
	{::hx::fsObject /*  ::haxe::ds::ObjectMap */ ,(int)offsetof(Texture_obj,images),HX_("images",b8,50,92,fe)},
	{::hx::fsBool,(int)offsetof(Texture_obj,createMipmaps),HX_("createMipmaps",4f,82,96,5d)},
	{::hx::fsInt,(int)offsetof(Texture_obj,magFilter),HX_("magFilter",ab,4e,d3,f1)},
	{::hx::fsInt,(int)offsetof(Texture_obj,minFilter),HX_("minFilter",ea,1e,7d,de)},
	{::hx::fsBool,(int)offsetof(Texture_obj,useFloat),HX_("useFloat",d5,27,02,ca)},
	{::hx::fsBool,(int)offsetof(Texture_obj,updated),HX_("updated",3b,c2,cf,9d)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Texture_obj,programs),HX_("programs",6f,e9,27,86)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Texture_obj,displays),HX_("displays",f1,cf,9a,25)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Texture_obj_sStaticStorageInfo = 0;
#endif

static ::String Texture_obj_sMemberFields[] = {
	HX_("gl",25,5a,00,00),
	HX_("glTexture",36,55,9b,6c),
	HX_("framebuffer",ed,14,48,7a),
	HX_("glDepthBuffer",3e,9c,05,04),
	HX_("clearOnRenderInto",42,3e,61,ca),
	HX_("colorChannels",d3,72,b1,6d),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("imageSlots",5a,27,9a,8a),
	HX_("freeSlots",69,c4,a3,60),
	HX_("slotsX",03,3e,08,74),
	HX_("slotsY",04,3e,08,74),
	HX_("slotWidth",28,cf,7e,aa),
	HX_("slotHeight",85,ec,c5,3a),
	HX_("tilesX",33,d7,28,1e),
	HX_("tilesY",34,d7,28,1e),
	HX_("images",b8,50,92,fe),
	HX_("createMipmaps",4f,82,96,5d),
	HX_("magFilter",ab,4e,d3,f1),
	HX_("minFilter",ea,1e,7d,de),
	HX_("useFloat",d5,27,02,ca),
	HX_("updated",3b,c2,cf,9d),
	HX_("programs",6f,e9,27,86),
	HX_("displays",f1,cf,9a,25),
	HX_("bufferImage",3b,b2,b4,5a),
	::String(null()) };

::hx::Class Texture_obj::__mClass;

void Texture_obj::__register()
{
	Texture_obj _hx_dummy;
	Texture_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("peote.view.Texture",35,17,1b,b5);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Texture_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Texture_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Texture_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Texture_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace peote
} // end namespace view
