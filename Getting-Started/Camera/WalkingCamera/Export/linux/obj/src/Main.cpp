// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeOpenGLRenderContext
#include <lime/_internal/backend/native/NativeOpenGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_app_Application
#include <lime/app/Application.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_lime_app_Module
#include <lime/app/Module.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_RenderContext
#include <lime/graphics/RenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics__WebGL2RenderContext_WebGL2RenderContext_Impl_
#include <lime/graphics/_WebGL2RenderContext/WebGL2RenderContext_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_math_Vector4
#include <lime/math/Vector4.h>
#endif
#ifndef INCLUDED_lime_math__Matrix4_Matrix4_Impl_
#include <lime/math/_Matrix4/Matrix4_Impl_.h>
#endif
#ifndef INCLUDED_lime_system_System
#include <lime/system/System.h>
#endif
#ifndef INCLUDED_lime_ui_Window
#include <lime/ui/Window.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_Assets
#include <lime/utils/Assets.h>
#endif
#ifndef INCLUDED_lime_utils_BytePointerData
#include <lime/utils/BytePointerData.h>
#endif
#ifndef INCLUDED_lime_utils_Preloader
#include <lime/utils/Preloader.h>
#endif
#ifndef INCLUDED_lime_utils_TAError
#include <lime/utils/TAError.h>
#endif
#ifndef INCLUDED_lime_utils__BytePointer_BytePointer_Impl_
#include <lime/utils/_BytePointer/BytePointer_Impl_.h>
#endif
#ifndef INCLUDED_lime_utils__DataPointer_DataPointer_Impl_
#include <lime/utils/_DataPointer/DataPointer_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e47a9afac0942eb9_22_new,"Main","new",0x6616a5cb,"Main.new","Main.hx",22,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_68_glCreateShader,"Main","glCreateShader",0x572fe57b,"Main.glCreateShader","Main.hx",68,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_88_glCreateProgram,"Main","glCreateProgram",0x872baf6e,"Main.glCreateProgram","Main.hx",88,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_115_initialize,"Main","initialize",0x8442af45,"Main.initialize","Main.hx",115,0x087e5c05)
static const Float _hx_array_data_332f6459_4[] = {
	-0.5,-0.5,-0.5,0.0,0.0,0.5,-0.5,-0.5,1.0,0.0,0.5,0.5,-0.5,1.0,1.0,0.5,0.5,-0.5,1.0,1.0,-0.5,0.5,-0.5,0.0,1.0,-0.5,-0.5,-0.5,0.0,0.0,-0.5,-0.5,0.5,0.0,0.0,0.5,-0.5,0.5,1.0,0.0,0.5,0.5,0.5,1.0,1.0,0.5,0.5,0.5,1.0,1.0,-0.5,0.5,0.5,0.0,1.0,-0.5,-0.5,0.5,0.0,0.0,-0.5,0.5,0.5,1.0,0.0,-0.5,0.5,-0.5,1.0,1.0,-0.5,-0.5,-0.5,0.0,1.0,-0.5,-0.5,-0.5,0.0,1.0,-0.5,-0.5,0.5,0.0,0.0,-0.5,0.5,0.5,1.0,0.0,0.5,0.5,0.5,1.0,0.0,0.5,0.5,-0.5,1.0,1.0,0.5,-0.5,-0.5,0.0,1.0,0.5,-0.5,-0.5,0.0,1.0,0.5,-0.5,0.5,0.0,0.0,0.5,0.5,0.5,1.0,0.0,-0.5,-0.5,-0.5,0.0,1.0,0.5,-0.5,-0.5,1.0,1.0,0.5,-0.5,0.5,1.0,0.0,0.5,-0.5,0.5,1.0,0.0,-0.5,-0.5,0.5,0.0,0.0,-0.5,-0.5,-0.5,0.0,1.0,-0.5,0.5,-0.5,0.0,1.0,0.5,0.5,-0.5,1.0,1.0,0.5,0.5,0.5,1.0,0.0,0.5,0.5,0.5,1.0,0.0,-0.5,0.5,0.5,0.0,0.0,-0.5,0.5,-0.5,0.0,1.0,
};
static const Float _hx_array_data_332f6459_5[] = {
	0.0,0.0,-10.0,
};
static const Float _hx_array_data_332f6459_6[] = {
	2.0,5.0,-15.0,
};
static const Float _hx_array_data_332f6459_7[] = {
	-1.5,-2.2,-2.5,
};
static const Float _hx_array_data_332f6459_8[] = {
	-3.8,-2.0,-12.3,
};
static const Float _hx_array_data_332f6459_9[] = {
	2.4,-0.4,-3.5,
};
static const Float _hx_array_data_332f6459_10[] = {
	-1.7,3.0,-7.5,
};
static const Float _hx_array_data_332f6459_11[] = {
	1.3,-2.0,-2.5,
};
static const Float _hx_array_data_332f6459_12[] = {
	1.5,2.0,-2.5,
};
static const Float _hx_array_data_332f6459_13[] = {
	1.5,0.2,-1.5,
};
static const Float _hx_array_data_332f6459_14[] = {
	-1.3,1.0,-1.5,
};
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_270_createPerspectiveZO,"Main","createPerspectiveZO",0x51106200,"Main.createPerspectiveZO","Main.hx",270,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_296_createLookAtMatrix,"Main","createLookAtMatrix",0x283d4924,"Main.createLookAtMatrix","Main.hx",296,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_325_moveCamera,"Main","moveCamera",0x9f423e8b,"Main.moveCamera","Main.hx",325,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_353_update,"Main","update",0xb7afa57e,"Main.update","Main.hx",353,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_372_onKeyDown,"Main","onKeyDown",0x547b59ed,"Main.onKeyDown","Main.hx",372,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_386_onKeyUp,"Main","onKeyUp",0xd96dbf26,"Main.onKeyUp","Main.hx",386,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_400_render,"Main","render",0x35d38acb,"Main.render","Main.hx",400,0x087e5c05)

void Main_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_22_new)
HXLINE(  49)		this->moveBackward = false;
HXLINE(  48)		this->moveForward = false;
HXLINE(  47)		this->moveRight = false;
HXLINE(  46)		this->moveLeft = false;
HXLINE(  55)		super::__construct();
HXLINE(  57)		this->initialized = false;
            	}

Dynamic Main_obj::__CreateEmpty() { return new Main_obj; }

void *Main_obj::_hx_vtable = 0;

Dynamic Main_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Main_obj > _hx_result = new Main_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Main_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x431bf104) {
		if (inClassId<=(int)0x07825a7d) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x07825a7d;
		} else {
			return inClassId==(int)0x431bf104;
		}
	} else {
		return inClassId==(int)0x7f8386d8;
	}
}

 ::lime::graphics::opengl::GLObject Main_obj::glCreateShader( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl,::String source,int type){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_68_glCreateShader)
HXLINE(  69)		 ::lime::graphics::opengl::GLObject shader = gl->createShader(type);
HXLINE(  70)		gl->shaderSource(shader,source);
HXLINE(  71)		gl->compileShader(shader);
HXLINE(  73)		if (::hx::IsEq( gl->getShaderParameter(shader,gl->COMPILE_STATUS),0 )) {
HXLINE(  74)			 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN(  74)			::String _hx_tmp1 = gl->getShaderInfoLog(shader);
HXDLIN(  74)			_hx_tmp(_hx_tmp1,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),74,HX_("Main",59,64,2f,33),HX_("glCreateShader",06,c9,79,c8)));
HXLINE(  75)			return null();
            		}
HXLINE(  78)		return shader;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Main_obj,glCreateShader,return )

 ::lime::graphics::opengl::GLObject Main_obj::glCreateProgram( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl,::String vertexSource,::String fragmentSource){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_88_glCreateProgram)
HXLINE(  89)		 ::lime::graphics::opengl::GLObject vs = this->glCreateShader(gl,vertexSource,gl->VERTEX_SHADER);
HXLINE(  90)		 ::lime::graphics::opengl::GLObject fs = this->glCreateShader(gl,fragmentSource,gl->FRAGMENT_SHADER);
HXLINE(  92)		bool _hx_tmp;
HXDLIN(  92)		if (::hx::IsNotNull( vs )) {
HXLINE(  92)			_hx_tmp = ::hx::IsNull( fs );
            		}
            		else {
HXLINE(  92)			_hx_tmp = true;
            		}
HXDLIN(  92)		if (_hx_tmp) {
HXLINE(  93)			return null();
            		}
HXLINE(  96)		 ::lime::graphics::opengl::GLObject program = gl->createProgram();
HXLINE(  97)		gl->attachShader(program,vs);
HXLINE(  98)		gl->attachShader(program,fs);
HXLINE( 100)		gl->deleteShader(vs);
HXLINE( 101)		gl->deleteShader(fs);
HXLINE( 103)		gl->linkProgram(program);
HXLINE( 105)		if (::hx::IsEq( gl->getProgramParameter(program,gl->LINK_STATUS),0 )) {
HXLINE( 106)			 ::Dynamic _hx_tmp1 = ::haxe::Log_obj::trace;
HXDLIN( 106)			::String _hx_tmp2 = gl->getProgramInfoLog(program);
HXDLIN( 106)			_hx_tmp1(_hx_tmp2,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),106,HX_("Main",59,64,2f,33),HX_("glCreateProgram",83,e5,88,36)));
HXLINE( 107)			 ::Dynamic _hx_tmp3 = ::haxe::Log_obj::trace;
HXDLIN( 107)			::String _hx_tmp4 = (HX_("VALIDATE_STATUS: ",61,4a,52,b0) + ::Std_obj::string(gl->getProgramParameter(program,gl->VALIDATE_STATUS)));
HXDLIN( 107)			_hx_tmp3(_hx_tmp4,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),107,HX_("Main",59,64,2f,33),HX_("glCreateProgram",83,e5,88,36)));
HXLINE( 108)			 ::Dynamic _hx_tmp5 = ::haxe::Log_obj::trace;
HXDLIN( 108)			::String _hx_tmp6 = (HX_("ERROR: ",4e,70,de,69) + gl->getError());
HXDLIN( 108)			_hx_tmp5(_hx_tmp6,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),108,HX_("Main",59,64,2f,33),HX_("glCreateProgram",83,e5,88,36)));
HXLINE( 109)			return null();
            		}
HXLINE( 112)		return program;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Main_obj,glCreateProgram,return )

void Main_obj::initialize( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_115_initialize)
HXLINE( 116)		this->deltaTime = ((Float)0.0);
HXLINE( 117)		this->lastFrame = ((Float)0.0);
HXLINE( 119)		::Array< Float > vertices = ::Array_obj< Float >::fromData( _hx_array_data_332f6459_4,180);
HXLINE( 163)		 ::Dynamic elements = null();
HXDLIN( 163)		 ::haxe::io::Bytes buffer = null();
HXDLIN( 163)		 ::lime::utils::ArrayBufferView view = null();
HXDLIN( 163)		 ::Dynamic len = null();
HXDLIN( 163)		 ::lime::utils::ArrayBufferView this1;
HXDLIN( 163)		if (::hx::IsNotNull( elements )) {
HXLINE( 163)			this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,8);
            		}
            		else {
HXLINE( 163)			if (::hx::IsNotNull( vertices )) {
HXLINE( 163)				 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN( 163)				_this->byteOffset = 0;
HXDLIN( 163)				_this->length = vertices->length;
HXDLIN( 163)				_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN( 163)				_this->buffer = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN( 163)				_this->copyFromArray(vertices,null());
HXDLIN( 163)				this1 = _this;
            			}
            			else {
HXLINE( 163)				if (::hx::IsNotNull( view )) {
HXLINE( 163)					 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN( 163)					 ::haxe::io::Bytes srcData = view->buffer;
HXDLIN( 163)					int srcLength = view->length;
HXDLIN( 163)					int srcByteOffset = view->byteOffset;
HXDLIN( 163)					int srcElementSize = view->bytesPerElement;
HXDLIN( 163)					int elementSize = _this1->bytesPerElement;
HXDLIN( 163)					if ((view->type == _this1->type)) {
HXLINE( 163)						int srcLength1 = srcData->length;
HXDLIN( 163)						int cloneLength = (srcLength1 - srcByteOffset);
HXDLIN( 163)						_this1->buffer = ::haxe::io::Bytes_obj::alloc(cloneLength);
HXDLIN( 163)						_this1->buffer->blit(0,srcData,srcByteOffset,cloneLength);
            					}
            					else {
HXLINE( 163)						HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            					}
HXDLIN( 163)					_this1->byteLength = (_this1->bytesPerElement * srcLength);
HXDLIN( 163)					_this1->byteOffset = 0;
HXDLIN( 163)					_this1->length = srcLength;
HXDLIN( 163)					this1 = _this1;
            				}
            				else {
HXLINE( 163)					if (::hx::IsNotNull( buffer )) {
HXLINE( 163)						 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN( 163)						int in_byteOffset = 0;
HXDLIN( 163)						if ((in_byteOffset < 0)) {
HXLINE( 163)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 163)						if ((::hx::Mod(in_byteOffset,_this2->bytesPerElement) != 0)) {
HXLINE( 163)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 163)						int bufferByteLength = buffer->length;
HXDLIN( 163)						int elementSize1 = _this2->bytesPerElement;
HXDLIN( 163)						int newByteLength = bufferByteLength;
HXDLIN( 163)						if (::hx::IsNull( len )) {
HXLINE( 163)							newByteLength = (bufferByteLength - in_byteOffset);
HXDLIN( 163)							if ((::hx::Mod(bufferByteLength,_this2->bytesPerElement) != 0)) {
HXLINE( 163)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 163)							if ((newByteLength < 0)) {
HXLINE( 163)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 163)							newByteLength = (( (int)(len) ) * _this2->bytesPerElement);
HXDLIN( 163)							int newRange = (in_byteOffset + newByteLength);
HXDLIN( 163)							if ((newRange > bufferByteLength)) {
HXLINE( 163)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 163)						_this2->buffer = buffer;
HXDLIN( 163)						_this2->byteOffset = in_byteOffset;
HXDLIN( 163)						_this2->byteLength = newByteLength;
HXDLIN( 163)						_this2->length = ::Std_obj::_hx_int((( (Float)(newByteLength) ) / ( (Float)(_this2->bytesPerElement) )));
HXDLIN( 163)						this1 = _this2;
            					}
            					else {
HXLINE( 163)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            					}
            				}
            			}
            		}
HXDLIN( 163)		 ::lime::utils::ArrayBufferView verticesData = this1;
HXLINE( 165)		this->cubePositions = ::Array_obj< ::Dynamic>::__new(10)->init(0,::Array_obj< Float >::fromData( _hx_array_data_332f6459_5,3))->init(1,::Array_obj< Float >::fromData( _hx_array_data_332f6459_6,3))->init(2,::Array_obj< Float >::fromData( _hx_array_data_332f6459_7,3))->init(3,::Array_obj< Float >::fromData( _hx_array_data_332f6459_8,3))->init(4,::Array_obj< Float >::fromData( _hx_array_data_332f6459_9,3))->init(5,::Array_obj< Float >::fromData( _hx_array_data_332f6459_10,3))->init(6,::Array_obj< Float >::fromData( _hx_array_data_332f6459_11,3))->init(7,::Array_obj< Float >::fromData( _hx_array_data_332f6459_12,3))->init(8,::Array_obj< Float >::fromData( _hx_array_data_332f6459_13,3))->init(9,::Array_obj< Float >::fromData( _hx_array_data_332f6459_14,3));
HXLINE( 169)		gl->enable(gl->DEPTH_TEST);
HXLINE( 172)		::String vs = HX_("#version 300 es\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec2 aTexCoord; \nout vec2 TexCoord;\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 proj;\nvoid main()\n{\n\tgl_Position =  proj * view * model * vec4(aPos, 1.0);\n\tTexCoord = aTexCoord;\n}\n",97,ab,7b,af);
HXLINE( 187)		::String fs = HX_("#version 300 es\nprecision mediump float;\nout vec4 FragColor;\nin vec2 TexCoord;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nvoid main() \n{\n    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);\n}\n",08,4d,ec,a4);
HXLINE( 199)		this->cameraPos =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)0.0),((Float)10.0),((Float)1.0));
HXLINE( 200)		this->cameraFront =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)0.0),((Float)-1.0),((Float)1.0));
HXLINE( 201)		this->cameraUp =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)1.0),((Float)0.0),((Float)1.0));
HXLINE( 204)		this->program = this->glCreateProgram(gl,vs,fs);
HXLINE( 207)		this->vbo = gl->createBuffer();
HXLINE( 210)		gl->bindBuffer(gl->ARRAY_BUFFER,this->vbo);
HXLINE( 211)		::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::bufferData(gl,gl->ARRAY_BUFFER,verticesData,gl->STATIC_DRAW,null(),null());
HXLINE( 213)		{
HXLINE( 213)			 ::lime::graphics::opengl::GLObject buffer1 = null();
HXDLIN( 213)			gl->bindBuffer(gl->ARRAY_BUFFER,buffer1);
            		}
HXLINE( 216)		{
HXLINE( 216)			int type = gl->FLOAT;
HXDLIN( 216)			gl->vertexAttribPointer(0,3,type,false,20,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt(0));
            		}
HXLINE( 217)		gl->enableVertexAttribArray(0);
HXLINE( 219)		bool _hx_tmp;
HXDLIN( 219)		if (::hx::IsNull( this->image )) {
HXLINE( 219)			_hx_tmp = this->_hx___preloader->complete;
            		}
            		else {
HXLINE( 219)			_hx_tmp = false;
            		}
HXDLIN( 219)		if (_hx_tmp) {
HXLINE( 220)			this->image = ::lime::utils::Assets_obj::getImage(HX_("assets/container.jpg",68,a1,5c,4d),null());
HXLINE( 223)			this->texture = gl->createTexture();
HXLINE( 224)			gl->activeTexture(gl->TEXTURE0);
HXLINE( 225)			gl->bindTexture(gl->TEXTURE_2D,this->texture);
HXLINE( 228)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_WRAP_S,gl->REPEAT);
HXLINE( 229)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_WRAP_T,gl->REPEAT);
HXLINE( 231)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_MIN_FILTER,gl->LINEAR_MIPMAP_LINEAR);
HXLINE( 232)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_MAG_FILTER,gl->LINEAR);
HXLINE( 233)			{
HXLINE( 233)				int target = gl->TEXTURE_2D;
HXDLIN( 233)				int internalformat = gl->RGB;
HXDLIN( 233)				int width = this->image->width;
HXDLIN( 233)				int height = this->image->height;
HXDLIN( 233)				int format = gl->RGB;
HXDLIN( 233)				int type1 = gl->UNSIGNED_BYTE;
HXDLIN( 233)				 ::lime::utils::ArrayBufferView srcData1 = ( ( ::lime::utils::ArrayBufferView)(this->image->get_src()) );
HXDLIN( 233)				::lime::utils::_BytePointer::BytePointer_Impl__obj::set(::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::_hx___tempPointer,null(),srcData1,null(),0);
HXDLIN( 233)				gl->texImage2D(target,0,internalformat,width,height,0,format,type1,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromBytesPointer(::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::_hx___tempPointer));
            			}
HXLINE( 235)			gl->generateMipmap(gl->TEXTURE_2D);
            		}
HXLINE( 238)		bool _hx_tmp1;
HXDLIN( 238)		if (::hx::IsNull( this->image2 )) {
HXLINE( 238)			_hx_tmp1 = this->_hx___preloader->complete;
            		}
            		else {
HXLINE( 238)			_hx_tmp1 = false;
            		}
HXDLIN( 238)		if (_hx_tmp1) {
HXLINE( 239)			this->image2 = ::lime::utils::Assets_obj::getImage(HX_("assets/awesomeface.png",af,43,32,4a),null());
HXLINE( 242)			this->texture2 = gl->createTexture();
HXLINE( 243)			gl->activeTexture(gl->TEXTURE0);
HXLINE( 244)			gl->bindTexture(gl->TEXTURE_2D,this->texture2);
HXLINE( 247)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_WRAP_S,gl->REPEAT);
HXLINE( 248)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_WRAP_T,gl->REPEAT);
HXLINE( 250)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_MIN_FILTER,gl->LINEAR_MIPMAP_LINEAR);
HXLINE( 251)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_MAG_FILTER,gl->LINEAR);
HXLINE( 252)			{
HXLINE( 252)				int target1 = gl->TEXTURE_2D;
HXDLIN( 252)				int internalformat1 = gl->RGBA;
HXDLIN( 252)				int width1 = this->image2->width;
HXDLIN( 252)				int height1 = this->image2->height;
HXDLIN( 252)				int format1 = gl->RGBA;
HXDLIN( 252)				int type2 = gl->UNSIGNED_BYTE;
HXDLIN( 252)				 ::lime::utils::ArrayBufferView srcData2 = ( ( ::lime::utils::ArrayBufferView)(this->image2->get_src()) );
HXDLIN( 252)				::lime::utils::_BytePointer::BytePointer_Impl__obj::set(::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::_hx___tempPointer,null(),srcData2,null(),0);
HXDLIN( 252)				gl->texImage2D(target1,0,internalformat1,width1,height1,0,format1,type2,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromBytesPointer(::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::_hx___tempPointer));
            			}
HXLINE( 254)			gl->generateMipmap(gl->TEXTURE_2D);
HXLINE( 256)			this->initialized = true;
            		}
HXLINE( 259)		gl->useProgram(this->program);
HXLINE( 261)		gl->uniform1i(gl->getUniformLocation(this->program,HX_("texture1",f6,f6,ce,65)),0);
HXLINE( 262)		gl->uniform1i(gl->getUniformLocation(this->program,HX_("texture2",f7,f6,ce,65)),1);
HXLINE( 264)		this->proj = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 265)		::lime::math::_Matrix4::Matrix4_Impl__obj::identity(this->proj);
HXLINE( 266)		this->createPerspectiveZO(this->proj,((((Float)45.0) * ::Math_obj::PI) / ( (Float)(180) )),(( (Float)(::lime::app::Application_obj::current->_hx___window->_hx___width) ) / ( (Float)(::lime::app::Application_obj::current->_hx___window->_hx___height) )),((Float)0.1),((Float)100.0));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,initialize,(void))

void Main_obj::createPerspectiveZO( ::lime::utils::ArrayBufferView mat,Float fovy,Float aspect,Float zNear,Float zFar){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_270_createPerspectiveZO)
HXDLIN( 270)		if ((::Math_obj::abs((aspect - ::Math_obj::pow(( (Float)(2) ),( (Float)(-23) )))) > ((Float)0.0))) {
HXLINE( 271)			Float top = (::Math_obj::tan(fovy) * zNear);
HXLINE( 272)			Float bottom = -(top);
HXLINE( 273)			Float right = (top * aspect);
HXLINE( 274)			Float left = -(right);
HXLINE( 276)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,0,((((Float)2.0) * zNear) / (right - left)));
HXLINE( 277)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,5,((((Float)2.0) * zNear) / (top - bottom)));
HXLINE( 278)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,8,((right + left) / (right - left)));
HXLINE( 279)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,9,((top + bottom) / (top - bottom)));
HXLINE( 280)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,10,(-((zFar + zNear)) / (zFar - zNear)));
HXLINE( 281)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,11,((Float)-1.0));
HXLINE( 282)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,14,(((( (Float)(-2) ) * zFar) * zNear) / (zFar - zNear)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Main_obj,createPerspectiveZO,(void))

 ::lime::utils::ArrayBufferView Main_obj::createLookAtMatrix( ::lime::math::Vector4 cameraPos, ::lime::math::Vector4 target, ::lime::math::Vector4 up){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_296_createLookAtMatrix)
HXLINE( 297)		 ::lime::math::Vector4 result = null();
HXDLIN( 297)		if (::hx::IsNull( result )) {
HXLINE( 297)			result =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXDLIN( 297)		{
HXLINE( 297)			result->x = (cameraPos->x - target->x);
HXDLIN( 297)			result->y = (cameraPos->y - target->y);
HXDLIN( 297)			result->z = (cameraPos->z - target->z);
            		}
HXDLIN( 297)		 ::lime::math::Vector4 cameraDir = result;
HXLINE( 298)		{
HXLINE( 298)			Float l = ::Math_obj::sqrt((((cameraDir->x * cameraDir->x) + (cameraDir->y * cameraDir->y)) + (cameraDir->z * cameraDir->z)));
HXDLIN( 298)			if ((l != 0)) {
HXLINE( 298)				 ::lime::math::Vector4 cameraDir1 = cameraDir;
HXDLIN( 298)				cameraDir1->x = (cameraDir1->x / l);
HXDLIN( 298)				 ::lime::math::Vector4 cameraDir2 = cameraDir;
HXDLIN( 298)				cameraDir2->y = (cameraDir2->y / l);
HXDLIN( 298)				 ::lime::math::Vector4 cameraDir3 = cameraDir;
HXDLIN( 298)				cameraDir3->z = (cameraDir3->z / l);
            			}
            		}
HXLINE( 299)		 ::lime::math::Vector4 result1 = null();
HXDLIN( 299)		if (::hx::IsNull( result1 )) {
HXLINE( 299)			result1 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXDLIN( 299)		{
HXLINE( 299)			Float ya = ((up->z * cameraDir->x) - (up->x * cameraDir->z));
HXDLIN( 299)			Float za = ((up->x * cameraDir->y) - (up->y * cameraDir->x));
HXDLIN( 299)			result1->x = ((up->y * cameraDir->z) - (up->z * cameraDir->y));
HXDLIN( 299)			result1->y = ya;
HXDLIN( 299)			result1->z = za;
            		}
HXDLIN( 299)		result1->w = ( (Float)(1) );
HXDLIN( 299)		 ::lime::math::Vector4 cameraRight = result1;
HXLINE( 300)		{
HXLINE( 300)			Float l1 = ::Math_obj::sqrt((((cameraRight->x * cameraRight->x) + (cameraRight->y * cameraRight->y)) + (cameraRight->z * cameraRight->z)));
HXDLIN( 300)			if ((l1 != 0)) {
HXLINE( 300)				 ::lime::math::Vector4 cameraRight1 = cameraRight;
HXDLIN( 300)				cameraRight1->x = (cameraRight1->x / l1);
HXDLIN( 300)				 ::lime::math::Vector4 cameraRight2 = cameraRight;
HXDLIN( 300)				cameraRight2->y = (cameraRight2->y / l1);
HXDLIN( 300)				 ::lime::math::Vector4 cameraRight3 = cameraRight;
HXDLIN( 300)				cameraRight3->z = (cameraRight3->z / l1);
            			}
            		}
HXLINE( 301)		 ::lime::math::Vector4 result2 = null();
HXDLIN( 301)		if (::hx::IsNull( result2 )) {
HXLINE( 301)			result2 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXDLIN( 301)		{
HXLINE( 301)			Float ya1 = ((cameraDir->z * cameraRight->x) - (cameraDir->x * cameraRight->z));
HXDLIN( 301)			Float za1 = ((cameraDir->x * cameraRight->y) - (cameraDir->y * cameraRight->x));
HXDLIN( 301)			result2->x = ((cameraDir->y * cameraRight->z) - (cameraDir->z * cameraRight->y));
HXDLIN( 301)			result2->y = ya1;
HXDLIN( 301)			result2->z = za1;
            		}
HXDLIN( 301)		result2->w = ( (Float)(1) );
HXDLIN( 301)		 ::lime::math::Vector4 cameraUp = result2;
HXLINE( 302)		{
HXLINE( 302)			Float l2 = ::Math_obj::sqrt((((cameraUp->x * cameraUp->x) + (cameraUp->y * cameraUp->y)) + (cameraUp->z * cameraUp->z)));
HXDLIN( 302)			if ((l2 != 0)) {
HXLINE( 302)				 ::lime::math::Vector4 cameraUp1 = cameraUp;
HXDLIN( 302)				cameraUp1->x = (cameraUp1->x / l2);
HXDLIN( 302)				 ::lime::math::Vector4 cameraUp2 = cameraUp;
HXDLIN( 302)				cameraUp2->y = (cameraUp2->y / l2);
HXDLIN( 302)				 ::lime::math::Vector4 cameraUp3 = cameraUp;
HXDLIN( 302)				cameraUp3->z = (cameraUp3->z / l2);
            			}
            		}
HXLINE( 303)		 ::lime::utils::ArrayBufferView cameraMat = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 305)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,0,cameraRight->x);
HXLINE( 306)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,1,cameraUp->x);
HXLINE( 307)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,2,cameraDir->x);
HXLINE( 308)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,3,((Float)0.0));
HXLINE( 309)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,4,cameraRight->y);
HXLINE( 310)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,5,cameraUp->y);
HXLINE( 311)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,6,cameraDir->y);
HXLINE( 312)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,7,((Float)0.0));
HXLINE( 313)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,8,cameraRight->z);
HXLINE( 314)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,9,cameraUp->z);
HXLINE( 315)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,10,cameraDir->z);
HXLINE( 316)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,11,((Float)0.0));
HXLINE( 317)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,12,-(cameraPos->x));
HXLINE( 318)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,13,-(cameraPos->y));
HXLINE( 319)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,14,-(cameraPos->z));
HXLINE( 320)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,15,((Float)1.0));
HXLINE( 322)		return cameraMat;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Main_obj,createLookAtMatrix,return )

void Main_obj::moveCamera(){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_325_moveCamera)
HXLINE( 326)		Float camSpeed = (( (Float)(10) ) * this->deltaTime);
HXLINE( 327)		if (this->moveForward) {
HXLINE( 328)			 ::lime::math::Vector4 _this = this->cameraFront;
HXDLIN( 328)			 ::lime::math::Vector4 tgt =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,_this->x,_this->y,_this->z,_this->w);
HXLINE( 329)			{
HXLINE( 329)				Float l = ::Math_obj::sqrt((((tgt->x * tgt->x) + (tgt->y * tgt->y)) + (tgt->z * tgt->z)));
HXDLIN( 329)				if ((l != 0)) {
HXLINE( 329)					 ::lime::math::Vector4 tgt1 = tgt;
HXDLIN( 329)					tgt1->x = (tgt1->x / l);
HXDLIN( 329)					 ::lime::math::Vector4 tgt2 = tgt;
HXDLIN( 329)					tgt2->y = (tgt2->y / l);
HXDLIN( 329)					 ::lime::math::Vector4 tgt3 = tgt;
HXDLIN( 329)					tgt3->z = (tgt3->z / l);
            				}
            			}
HXLINE( 330)			{
HXLINE( 330)				 ::lime::math::Vector4 tgt4 = tgt;
HXDLIN( 330)				tgt4->x = (tgt4->x * camSpeed);
HXDLIN( 330)				 ::lime::math::Vector4 tgt5 = tgt;
HXDLIN( 330)				tgt5->y = (tgt5->y * camSpeed);
HXDLIN( 330)				 ::lime::math::Vector4 tgt6 = tgt;
HXDLIN( 330)				tgt6->z = (tgt6->z * camSpeed);
            			}
HXLINE( 331)			 ::lime::math::Vector4 _this1 = this->cameraPos;
HXDLIN( 331)			 ::lime::math::Vector4 result = null();
HXDLIN( 331)			if (::hx::IsNull( result )) {
HXLINE( 331)				result =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 331)			{
HXLINE( 331)				result->x = (_this1->x + tgt->x);
HXDLIN( 331)				result->y = (_this1->y + tgt->y);
HXDLIN( 331)				result->z = (_this1->z + tgt->z);
            			}
HXDLIN( 331)			this->cameraPos = result;
            		}
HXLINE( 333)		if (this->moveBackward) {
HXLINE( 334)			 ::lime::math::Vector4 _this2 = this->cameraFront;
HXDLIN( 334)			 ::lime::math::Vector4 tgt7 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,_this2->x,_this2->y,_this2->z,_this2->w);
HXLINE( 335)			{
HXLINE( 335)				Float l1 = ::Math_obj::sqrt((((tgt7->x * tgt7->x) + (tgt7->y * tgt7->y)) + (tgt7->z * tgt7->z)));
HXDLIN( 335)				if ((l1 != 0)) {
HXLINE( 335)					 ::lime::math::Vector4 tgt8 = tgt7;
HXDLIN( 335)					tgt8->x = (tgt8->x / l1);
HXDLIN( 335)					 ::lime::math::Vector4 tgt9 = tgt7;
HXDLIN( 335)					tgt9->y = (tgt9->y / l1);
HXDLIN( 335)					 ::lime::math::Vector4 tgt10 = tgt7;
HXDLIN( 335)					tgt10->z = (tgt10->z / l1);
            				}
            			}
HXLINE( 336)			{
HXLINE( 336)				 ::lime::math::Vector4 tgt11 = tgt7;
HXDLIN( 336)				tgt11->x = (tgt11->x * camSpeed);
HXDLIN( 336)				 ::lime::math::Vector4 tgt12 = tgt7;
HXDLIN( 336)				tgt12->y = (tgt12->y * camSpeed);
HXDLIN( 336)				 ::lime::math::Vector4 tgt13 = tgt7;
HXDLIN( 336)				tgt13->z = (tgt13->z * camSpeed);
            			}
HXLINE( 337)			 ::lime::math::Vector4 _this3 = this->cameraPos;
HXDLIN( 337)			 ::lime::math::Vector4 result1 = null();
HXDLIN( 337)			if (::hx::IsNull( result1 )) {
HXLINE( 337)				result1 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 337)			{
HXLINE( 337)				result1->x = (_this3->x - tgt7->x);
HXDLIN( 337)				result1->y = (_this3->y - tgt7->y);
HXDLIN( 337)				result1->z = (_this3->z - tgt7->z);
            			}
HXDLIN( 337)			this->cameraPos = result1;
            		}
HXLINE( 339)		if (this->moveLeft) {
HXLINE( 340)			 ::lime::math::Vector4 _this4 = this->cameraFront;
HXDLIN( 340)			 ::lime::math::Vector4 a = this->cameraUp;
HXDLIN( 340)			 ::lime::math::Vector4 result2 = null();
HXDLIN( 340)			if (::hx::IsNull( result2 )) {
HXLINE( 340)				result2 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 340)			{
HXLINE( 340)				Float ya = ((_this4->z * a->x) - (_this4->x * a->z));
HXDLIN( 340)				Float za = ((_this4->x * a->y) - (_this4->y * a->x));
HXDLIN( 340)				result2->x = ((_this4->y * a->z) - (_this4->z * a->y));
HXDLIN( 340)				result2->y = ya;
HXDLIN( 340)				result2->z = za;
            			}
HXDLIN( 340)			result2->w = ( (Float)(1) );
HXDLIN( 340)			 ::lime::math::Vector4 m = result2;
HXLINE( 341)			{
HXLINE( 341)				Float l2 = ::Math_obj::sqrt((((m->x * m->x) + (m->y * m->y)) + (m->z * m->z)));
HXDLIN( 341)				if ((l2 != 0)) {
HXLINE( 341)					 ::lime::math::Vector4 m1 = m;
HXDLIN( 341)					m1->x = (m1->x / l2);
HXDLIN( 341)					 ::lime::math::Vector4 m2 = m;
HXDLIN( 341)					m2->y = (m2->y / l2);
HXDLIN( 341)					 ::lime::math::Vector4 m3 = m;
HXDLIN( 341)					m3->z = (m3->z / l2);
            				}
            			}
HXLINE( 342)			{
HXLINE( 342)				 ::lime::math::Vector4 m4 = m;
HXDLIN( 342)				m4->x = (m4->x * camSpeed);
HXDLIN( 342)				 ::lime::math::Vector4 m5 = m;
HXDLIN( 342)				m5->y = (m5->y * camSpeed);
HXDLIN( 342)				 ::lime::math::Vector4 m6 = m;
HXDLIN( 342)				m6->z = (m6->z * camSpeed);
            			}
HXLINE( 343)			 ::lime::math::Vector4 _this5 = this->cameraPos;
HXDLIN( 343)			 ::lime::math::Vector4 result3 = null();
HXDLIN( 343)			if (::hx::IsNull( result3 )) {
HXLINE( 343)				result3 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 343)			{
HXLINE( 343)				result3->x = (_this5->x - m->x);
HXDLIN( 343)				result3->y = (_this5->y - m->y);
HXDLIN( 343)				result3->z = (_this5->z - m->z);
            			}
HXDLIN( 343)			this->cameraPos = result3;
            		}
HXLINE( 345)		if (this->moveRight) {
HXLINE( 346)			 ::lime::math::Vector4 _this6 = this->cameraFront;
HXDLIN( 346)			 ::lime::math::Vector4 a1 = this->cameraUp;
HXDLIN( 346)			 ::lime::math::Vector4 result4 = null();
HXDLIN( 346)			if (::hx::IsNull( result4 )) {
HXLINE( 346)				result4 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 346)			{
HXLINE( 346)				Float ya1 = ((_this6->z * a1->x) - (_this6->x * a1->z));
HXDLIN( 346)				Float za1 = ((_this6->x * a1->y) - (_this6->y * a1->x));
HXDLIN( 346)				result4->x = ((_this6->y * a1->z) - (_this6->z * a1->y));
HXDLIN( 346)				result4->y = ya1;
HXDLIN( 346)				result4->z = za1;
            			}
HXDLIN( 346)			result4->w = ( (Float)(1) );
HXDLIN( 346)			 ::lime::math::Vector4 m7 = result4;
HXLINE( 347)			{
HXLINE( 347)				Float l3 = ::Math_obj::sqrt((((m7->x * m7->x) + (m7->y * m7->y)) + (m7->z * m7->z)));
HXDLIN( 347)				if ((l3 != 0)) {
HXLINE( 347)					 ::lime::math::Vector4 m8 = m7;
HXDLIN( 347)					m8->x = (m8->x / l3);
HXDLIN( 347)					 ::lime::math::Vector4 m9 = m7;
HXDLIN( 347)					m9->y = (m9->y / l3);
HXDLIN( 347)					 ::lime::math::Vector4 m10 = m7;
HXDLIN( 347)					m10->z = (m10->z / l3);
            				}
            			}
HXLINE( 348)			{
HXLINE( 348)				 ::lime::math::Vector4 m11 = m7;
HXDLIN( 348)				m11->x = (m11->x * camSpeed);
HXDLIN( 348)				 ::lime::math::Vector4 m12 = m7;
HXDLIN( 348)				m12->y = (m12->y * camSpeed);
HXDLIN( 348)				 ::lime::math::Vector4 m13 = m7;
HXDLIN( 348)				m13->z = (m13->z * camSpeed);
            			}
HXLINE( 349)			 ::lime::math::Vector4 _this7 = this->cameraPos;
HXDLIN( 349)			 ::lime::math::Vector4 result5 = null();
HXDLIN( 349)			if (::hx::IsNull( result5 )) {
HXLINE( 349)				result5 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 349)			{
HXLINE( 349)				result5->x = (_this7->x + m7->x);
HXDLIN( 349)				result5->y = (_this7->y + m7->y);
HXDLIN( 349)				result5->z = (_this7->z + m7->z);
            			}
HXDLIN( 349)			this->cameraPos = result5;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,moveCamera,(void))

void Main_obj::update(int deltaTime){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_353_update)
HXLINE( 354)		this->deltaTime = ((( (Float)(deltaTime) ) * ((Float)1.0)) / ((Float)1000.0));
HXLINE( 355)		bool _hx_tmp;
HXDLIN( 355)		bool _hx_tmp1;
HXDLIN( 355)		bool _hx_tmp2;
HXDLIN( 355)		if (!(this->moveLeft)) {
HXLINE( 355)			_hx_tmp2 = this->moveRight;
            		}
            		else {
HXLINE( 355)			_hx_tmp2 = true;
            		}
HXDLIN( 355)		if (!(_hx_tmp2)) {
HXLINE( 355)			_hx_tmp1 = this->moveForward;
            		}
            		else {
HXLINE( 355)			_hx_tmp1 = true;
            		}
HXDLIN( 355)		if (!(_hx_tmp1)) {
HXLINE( 355)			_hx_tmp = this->moveBackward;
            		}
            		else {
HXLINE( 355)			_hx_tmp = true;
            		}
HXDLIN( 355)		if (_hx_tmp) {
HXLINE( 356)			this->moveCamera();
            		}
            	}


void Main_obj::onKeyDown(int key,int modifier){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_372_onKeyDown)
HXDLIN( 372)		switch((int)(key)){
            			case (int)1073741903: {
HXLINE( 376)				this->moveRight = true;
            			}
            			break;
            			case (int)1073741904: {
HXLINE( 374)				this->moveLeft = true;
            			}
            			break;
            			case (int)1073741905: {
HXLINE( 380)				this->moveBackward = true;
            			}
            			break;
            			case (int)1073741906: {
HXLINE( 378)				this->moveForward = true;
            			}
            			break;
            			default:{
            			}
            		}
            	}


void Main_obj::onKeyUp(int key,int modifier){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_386_onKeyUp)
HXDLIN( 386)		switch((int)(key)){
            			case (int)1073741903: {
HXLINE( 390)				this->moveRight = false;
            			}
            			break;
            			case (int)1073741904: {
HXLINE( 388)				this->moveLeft = false;
            			}
            			break;
            			case (int)1073741905: {
HXLINE( 394)				this->moveBackward = false;
            			}
            			break;
            			case (int)1073741906: {
HXLINE( 392)				this->moveForward = false;
            			}
            			break;
            			default:{
            			}
            		}
            	}


void Main_obj::render( ::lime::graphics::RenderContext context){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_400_render)
HXDLIN( 400)		::String _hx_switch_0 = context->type;
            		if (  (_hx_switch_0==HX_("opengl",6f,64,94,21)) ||  (_hx_switch_0==HX_("opengles",9d,f6,c9,fa)) ||  (_hx_switch_0==HX_("webgl",b9,4b,bc,c7)) ){
HXLINE( 402)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext gl = context->webgl2;
HXLINE( 404)			if (!(this->initialized)) {
HXLINE( 405)				this->initialize(gl);
            			}
HXLINE( 408)			gl->clearColor(((Float)0.75),( (Float)(1) ),( (Float)(0) ),( (Float)(1) ));
HXLINE( 409)			gl->clear((gl->COLOR_BUFFER_BIT | gl->DEPTH_BUFFER_BIT));
HXLINE( 411)			int timer = ::lime::_hx_system::System_obj::getTimer();
HXDLIN( 411)			Float _hx_tmp;
HXDLIN( 411)			if ((timer > 0)) {
HXLINE( 411)				_hx_tmp = (( (Float)(timer) ) / ( (Float)(1000) ));
            			}
            			else {
HXLINE( 411)				_hx_tmp = ( (Float)(0) );
            			}
HXDLIN( 411)			this->currentFrame = _hx_tmp;
HXLINE( 413)			this->lastFrame = this->currentFrame;
HXLINE( 415)			gl->useProgram(this->program);
HXLINE( 417)			gl->bindBuffer(gl->ARRAY_BUFFER,this->vbo);
HXLINE( 420)			{
HXLINE( 420)				int type = gl->FLOAT;
HXDLIN( 420)				gl->vertexAttribPointer(0,3,type,false,20,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt(0));
            			}
HXLINE( 421)			gl->enableVertexAttribArray(0);
HXLINE( 424)			{
HXLINE( 424)				int type1 = gl->FLOAT;
HXDLIN( 424)				gl->vertexAttribPointer(1,2,type1,false,20,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt(12));
            			}
HXLINE( 425)			gl->enableVertexAttribArray(1);
HXLINE( 428)			gl->activeTexture(gl->TEXTURE0);
HXLINE( 429)			gl->bindTexture(gl->TEXTURE_2D,this->texture);
HXLINE( 431)			gl->activeTexture(gl->TEXTURE1);
HXLINE( 432)			gl->bindTexture(gl->TEXTURE_2D,this->texture2);
HXLINE( 434)			this->view = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 435)			::lime::math::_Matrix4::Matrix4_Impl__obj::identity(this->view);
HXLINE( 439)			 ::lime::math::Vector4 _hx_tmp1 = this->cameraPos;
HXDLIN( 439)			 ::lime::math::Vector4 _this = this->cameraPos;
HXDLIN( 439)			 ::lime::math::Vector4 a = this->cameraFront;
HXDLIN( 439)			 ::lime::math::Vector4 result = null();
HXDLIN( 439)			if (::hx::IsNull( result )) {
HXLINE( 439)				result =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 439)			{
HXLINE( 439)				result->x = (_this->x + a->x);
HXDLIN( 439)				result->y = (_this->y + a->y);
HXDLIN( 439)				result->z = (_this->z + a->z);
            			}
HXDLIN( 439)			this->view = this->createLookAtMatrix(_hx_tmp1,result, ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)1.0),((Float)0.0),null()));
HXLINE( 441)			int _hx_tmp2 = gl->getUniformLocation(this->program,HX_("view",65,32,4f,4e));
HXDLIN( 441)			::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::uniformMatrix4fv(gl,_hx_tmp2,false,this->view,null(),null());
HXLINE( 442)			int _hx_tmp3 = gl->getUniformLocation(this->program,HX_("proj",9d,c7,5e,4a));
HXDLIN( 442)			::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::uniformMatrix4fv(gl,_hx_tmp3,false,this->proj,null(),null());
HXLINE( 445)			{
HXLINE( 445)				int _g = 0;
HXDLIN( 445)				int _g1 = this->cubePositions->length;
HXDLIN( 445)				while((_g < _g1)){
HXLINE( 445)					_g = (_g + 1);
HXDLIN( 445)					int i = (_g - 1);
HXLINE( 446)					Float angle = (((Float)20.0) * ( (Float)(i) ));
HXLINE( 447)					 ::lime::utils::ArrayBufferView model = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 448)					::lime::math::_Matrix4::Matrix4_Impl__obj::identity(model);
HXLINE( 449)					::lime::math::_Matrix4::Matrix4_Impl__obj::appendTranslation(model,this->cubePositions->__get(i).StaticCast< ::Array< Float > >()->__get(0),this->cubePositions->__get(i).StaticCast< ::Array< Float > >()->__get(1),this->cubePositions->__get(i).StaticCast< ::Array< Float > >()->__get(2));
HXLINE( 450)					::lime::math::_Matrix4::Matrix4_Impl__obj::appendRotation(model,angle, ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)1.0),((Float)0.3),((Float)0.5),((Float)1.0)),null());
HXLINE( 451)					::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::uniformMatrix4fv(gl,gl->getUniformLocation(this->program,HX_("model",a9,23,58,0c)),false,model,null(),null());
HXLINE( 452)					gl->drawArrays(gl->TRIANGLES,0,36);
            				}
            			}
HXLINE( 401)			goto _hx_goto_21;
            		}
            		/* default */{
            		}
            		_hx_goto_21:;
            	}



::hx::ObjectPtr< Main_obj > Main_obj::__new() {
	::hx::ObjectPtr< Main_obj > __this = new Main_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Main_obj > Main_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Main_obj *__this = (Main_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Main_obj), true, "Main"));
	*(void **)__this = Main_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Main_obj::Main_obj()
{
}

void Main_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Main);
	HX_MARK_MEMBER_NAME(vbo,"vbo");
	HX_MARK_MEMBER_NAME(ebo,"ebo");
	HX_MARK_MEMBER_NAME(texture,"texture");
	HX_MARK_MEMBER_NAME(texture2,"texture2");
	HX_MARK_MEMBER_NAME(program,"program");
	HX_MARK_MEMBER_NAME(image,"image");
	HX_MARK_MEMBER_NAME(image2,"image2");
	HX_MARK_MEMBER_NAME(trans,"trans");
	HX_MARK_MEMBER_NAME(vec,"vec");
	HX_MARK_MEMBER_NAME(model,"model");
	HX_MARK_MEMBER_NAME(view,"view");
	HX_MARK_MEMBER_NAME(proj,"proj");
	HX_MARK_MEMBER_NAME(transMat,"transMat");
	HX_MARK_MEMBER_NAME(cubePositions,"cubePositions");
	HX_MARK_MEMBER_NAME(cameraPos,"cameraPos");
	HX_MARK_MEMBER_NAME(cameraFront,"cameraFront");
	HX_MARK_MEMBER_NAME(cameraUp,"cameraUp");
	HX_MARK_MEMBER_NAME(deltaTime,"deltaTime");
	HX_MARK_MEMBER_NAME(currentFrame,"currentFrame");
	HX_MARK_MEMBER_NAME(lastFrame,"lastFrame");
	HX_MARK_MEMBER_NAME(moveLeft,"moveLeft");
	HX_MARK_MEMBER_NAME(moveRight,"moveRight");
	HX_MARK_MEMBER_NAME(moveForward,"moveForward");
	HX_MARK_MEMBER_NAME(moveBackward,"moveBackward");
	HX_MARK_MEMBER_NAME(initialized,"initialized");
	 ::lime::app::Application_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Main_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(vbo,"vbo");
	HX_VISIT_MEMBER_NAME(ebo,"ebo");
	HX_VISIT_MEMBER_NAME(texture,"texture");
	HX_VISIT_MEMBER_NAME(texture2,"texture2");
	HX_VISIT_MEMBER_NAME(program,"program");
	HX_VISIT_MEMBER_NAME(image,"image");
	HX_VISIT_MEMBER_NAME(image2,"image2");
	HX_VISIT_MEMBER_NAME(trans,"trans");
	HX_VISIT_MEMBER_NAME(vec,"vec");
	HX_VISIT_MEMBER_NAME(model,"model");
	HX_VISIT_MEMBER_NAME(view,"view");
	HX_VISIT_MEMBER_NAME(proj,"proj");
	HX_VISIT_MEMBER_NAME(transMat,"transMat");
	HX_VISIT_MEMBER_NAME(cubePositions,"cubePositions");
	HX_VISIT_MEMBER_NAME(cameraPos,"cameraPos");
	HX_VISIT_MEMBER_NAME(cameraFront,"cameraFront");
	HX_VISIT_MEMBER_NAME(cameraUp,"cameraUp");
	HX_VISIT_MEMBER_NAME(deltaTime,"deltaTime");
	HX_VISIT_MEMBER_NAME(currentFrame,"currentFrame");
	HX_VISIT_MEMBER_NAME(lastFrame,"lastFrame");
	HX_VISIT_MEMBER_NAME(moveLeft,"moveLeft");
	HX_VISIT_MEMBER_NAME(moveRight,"moveRight");
	HX_VISIT_MEMBER_NAME(moveForward,"moveForward");
	HX_VISIT_MEMBER_NAME(moveBackward,"moveBackward");
	HX_VISIT_MEMBER_NAME(initialized,"initialized");
	 ::lime::app::Application_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Main_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"vbo") ) { return ::hx::Val( vbo ); }
		if (HX_FIELD_EQ(inName,"ebo") ) { return ::hx::Val( ebo ); }
		if (HX_FIELD_EQ(inName,"vec") ) { return ::hx::Val( vec ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"view") ) { return ::hx::Val( view ); }
		if (HX_FIELD_EQ(inName,"proj") ) { return ::hx::Val( proj ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"image") ) { return ::hx::Val( image ); }
		if (HX_FIELD_EQ(inName,"trans") ) { return ::hx::Val( trans ); }
		if (HX_FIELD_EQ(inName,"model") ) { return ::hx::Val( model ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"image2") ) { return ::hx::Val( image2 ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { return ::hx::Val( texture ); }
		if (HX_FIELD_EQ(inName,"program") ) { return ::hx::Val( program ); }
		if (HX_FIELD_EQ(inName,"onKeyUp") ) { return ::hx::Val( onKeyUp_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"texture2") ) { return ::hx::Val( texture2 ); }
		if (HX_FIELD_EQ(inName,"transMat") ) { return ::hx::Val( transMat ); }
		if (HX_FIELD_EQ(inName,"cameraUp") ) { return ::hx::Val( cameraUp ); }
		if (HX_FIELD_EQ(inName,"moveLeft") ) { return ::hx::Val( moveLeft ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"cameraPos") ) { return ::hx::Val( cameraPos ); }
		if (HX_FIELD_EQ(inName,"deltaTime") ) { return ::hx::Val( deltaTime ); }
		if (HX_FIELD_EQ(inName,"lastFrame") ) { return ::hx::Val( lastFrame ); }
		if (HX_FIELD_EQ(inName,"moveRight") ) { return ::hx::Val( moveRight ); }
		if (HX_FIELD_EQ(inName,"onKeyDown") ) { return ::hx::Val( onKeyDown_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"initialize") ) { return ::hx::Val( initialize_dyn() ); }
		if (HX_FIELD_EQ(inName,"moveCamera") ) { return ::hx::Val( moveCamera_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"cameraFront") ) { return ::hx::Val( cameraFront ); }
		if (HX_FIELD_EQ(inName,"moveForward") ) { return ::hx::Val( moveForward ); }
		if (HX_FIELD_EQ(inName,"initialized") ) { return ::hx::Val( initialized ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentFrame") ) { return ::hx::Val( currentFrame ); }
		if (HX_FIELD_EQ(inName,"moveBackward") ) { return ::hx::Val( moveBackward ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"cubePositions") ) { return ::hx::Val( cubePositions ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"glCreateShader") ) { return ::hx::Val( glCreateShader_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"glCreateProgram") ) { return ::hx::Val( glCreateProgram_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"createLookAtMatrix") ) { return ::hx::Val( createLookAtMatrix_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"createPerspectiveZO") ) { return ::hx::Val( createPerspectiveZO_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Main_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"vbo") ) { vbo=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ebo") ) { ebo=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vec") ) { vec=inValue.Cast<  ::lime::math::Vector4 >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"view") ) { view=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"proj") ) { proj=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"image") ) { image=inValue.Cast<  ::lime::graphics::Image >(); return inValue; }
		if (HX_FIELD_EQ(inName,"trans") ) { trans=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"model") ) { model=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"image2") ) { image2=inValue.Cast<  ::lime::graphics::Image >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { texture=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"program") ) { program=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"texture2") ) { texture2=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"transMat") ) { transMat=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cameraUp") ) { cameraUp=inValue.Cast<  ::lime::math::Vector4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moveLeft") ) { moveLeft=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"cameraPos") ) { cameraPos=inValue.Cast<  ::lime::math::Vector4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"deltaTime") ) { deltaTime=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastFrame") ) { lastFrame=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moveRight") ) { moveRight=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"cameraFront") ) { cameraFront=inValue.Cast<  ::lime::math::Vector4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moveForward") ) { moveForward=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"initialized") ) { initialized=inValue.Cast< bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentFrame") ) { currentFrame=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moveBackward") ) { moveBackward=inValue.Cast< bool >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"cubePositions") ) { cubePositions=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Main_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("vbo",c3,df,59,00));
	outFields->push(HX_("ebo",72,f9,4c,00));
	outFields->push(HX_("texture",db,c8,e0,9e));
	outFields->push(HX_("texture2",f7,f6,ce,65));
	outFields->push(HX_("program",84,4a,f9,f3));
	outFields->push(HX_("image",5b,1f,69,bd));
	outFields->push(HX_("image2",77,50,92,fe));
	outFields->push(HX_("trans",28,98,1f,16));
	outFields->push(HX_("vec",54,e2,59,00));
	outFields->push(HX_("model",a9,23,58,0c));
	outFields->push(HX_("view",65,32,4f,4e));
	outFields->push(HX_("proj",9d,c7,5e,4a));
	outFields->push(HX_("transMat",58,b3,5a,da));
	outFields->push(HX_("cubePositions",f5,cf,98,aa));
	outFields->push(HX_("cameraPos",ef,c3,30,3a));
	outFields->push(HX_("cameraFront",c4,0b,d4,fa));
	outFields->push(HX_("cameraUp",60,44,27,e8));
	outFields->push(HX_("deltaTime",25,3c,5c,f5));
	outFields->push(HX_("currentFrame",34,5d,8f,4d));
	outFields->push(HX_("lastFrame",f7,a5,30,53));
	outFields->push(HX_("moveLeft",b8,73,67,ea));
	outFields->push(HX_("moveRight",0b,db,2a,a7));
	outFields->push(HX_("moveForward",b4,1a,47,be));
	outFields->push(HX_("moveBackward",14,74,4e,bb));
	outFields->push(HX_("initialized",14,f5,0f,37));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Main_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,vbo),HX_("vbo",c3,df,59,00)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,ebo),HX_("ebo",72,f9,4c,00)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,texture),HX_("texture",db,c8,e0,9e)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,texture2),HX_("texture2",f7,f6,ce,65)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,program),HX_("program",84,4a,f9,f3)},
	{::hx::fsObject /*  ::lime::graphics::Image */ ,(int)offsetof(Main_obj,image),HX_("image",5b,1f,69,bd)},
	{::hx::fsObject /*  ::lime::graphics::Image */ ,(int)offsetof(Main_obj,image2),HX_("image2",77,50,92,fe)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(int)offsetof(Main_obj,trans),HX_("trans",28,98,1f,16)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(int)offsetof(Main_obj,vec),HX_("vec",54,e2,59,00)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(int)offsetof(Main_obj,model),HX_("model",a9,23,58,0c)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(int)offsetof(Main_obj,view),HX_("view",65,32,4f,4e)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(int)offsetof(Main_obj,proj),HX_("proj",9d,c7,5e,4a)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Main_obj,transMat),HX_("transMat",58,b3,5a,da)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Main_obj,cubePositions),HX_("cubePositions",f5,cf,98,aa)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(int)offsetof(Main_obj,cameraPos),HX_("cameraPos",ef,c3,30,3a)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(int)offsetof(Main_obj,cameraFront),HX_("cameraFront",c4,0b,d4,fa)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(int)offsetof(Main_obj,cameraUp),HX_("cameraUp",60,44,27,e8)},
	{::hx::fsFloat,(int)offsetof(Main_obj,deltaTime),HX_("deltaTime",25,3c,5c,f5)},
	{::hx::fsFloat,(int)offsetof(Main_obj,currentFrame),HX_("currentFrame",34,5d,8f,4d)},
	{::hx::fsFloat,(int)offsetof(Main_obj,lastFrame),HX_("lastFrame",f7,a5,30,53)},
	{::hx::fsBool,(int)offsetof(Main_obj,moveLeft),HX_("moveLeft",b8,73,67,ea)},
	{::hx::fsBool,(int)offsetof(Main_obj,moveRight),HX_("moveRight",0b,db,2a,a7)},
	{::hx::fsBool,(int)offsetof(Main_obj,moveForward),HX_("moveForward",b4,1a,47,be)},
	{::hx::fsBool,(int)offsetof(Main_obj,moveBackward),HX_("moveBackward",14,74,4e,bb)},
	{::hx::fsBool,(int)offsetof(Main_obj,initialized),HX_("initialized",14,f5,0f,37)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Main_obj_sStaticStorageInfo = 0;
#endif

static ::String Main_obj_sMemberFields[] = {
	HX_("vbo",c3,df,59,00),
	HX_("ebo",72,f9,4c,00),
	HX_("texture",db,c8,e0,9e),
	HX_("texture2",f7,f6,ce,65),
	HX_("program",84,4a,f9,f3),
	HX_("image",5b,1f,69,bd),
	HX_("image2",77,50,92,fe),
	HX_("trans",28,98,1f,16),
	HX_("vec",54,e2,59,00),
	HX_("model",a9,23,58,0c),
	HX_("view",65,32,4f,4e),
	HX_("proj",9d,c7,5e,4a),
	HX_("transMat",58,b3,5a,da),
	HX_("cubePositions",f5,cf,98,aa),
	HX_("cameraPos",ef,c3,30,3a),
	HX_("cameraFront",c4,0b,d4,fa),
	HX_("cameraUp",60,44,27,e8),
	HX_("deltaTime",25,3c,5c,f5),
	HX_("currentFrame",34,5d,8f,4d),
	HX_("lastFrame",f7,a5,30,53),
	HX_("moveLeft",b8,73,67,ea),
	HX_("moveRight",0b,db,2a,a7),
	HX_("moveForward",b4,1a,47,be),
	HX_("moveBackward",14,74,4e,bb),
	HX_("initialized",14,f5,0f,37),
	HX_("glCreateShader",06,c9,79,c8),
	HX_("glCreateProgram",83,e5,88,36),
	HX_("initialize",50,31,bb,ec),
	HX_("createPerspectiveZO",95,c6,aa,2d),
	HX_("createLookAtMatrix",2f,4e,67,70),
	HX_("moveCamera",96,c0,ba,07),
	HX_("update",09,86,05,87),
	HX_("onKeyDown",42,22,f2,73),
	HX_("onKeyUp",3b,58,3c,75),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class Main_obj::__mClass;

void Main_obj::__register()
{
	Main_obj _hx_dummy;
	Main_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Main",59,64,2f,33);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Main_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Main_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Main_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Main_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

