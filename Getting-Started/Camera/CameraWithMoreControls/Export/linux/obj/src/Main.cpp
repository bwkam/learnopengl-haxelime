// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeOpenGLRenderContext
#include <lime/_internal/backend/native/NativeOpenGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_app_Application
#include <lime/app/Application.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_lime_app_Module
#include <lime/app/Module.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_RenderContext
#include <lime/graphics/RenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics__WebGL2RenderContext_WebGL2RenderContext_Impl_
#include <lime/graphics/_WebGL2RenderContext/WebGL2RenderContext_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_math_Vector4
#include <lime/math/Vector4.h>
#endif
#ifndef INCLUDED_lime_math__Matrix4_Matrix4_Impl_
#include <lime/math/_Matrix4/Matrix4_Impl_.h>
#endif
#ifndef INCLUDED_lime_system_System
#include <lime/system/System.h>
#endif
#ifndef INCLUDED_lime_ui_MouseWheelMode
#include <lime/ui/MouseWheelMode.h>
#endif
#ifndef INCLUDED_lime_ui_Window
#include <lime/ui/Window.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_Assets
#include <lime/utils/Assets.h>
#endif
#ifndef INCLUDED_lime_utils_BytePointerData
#include <lime/utils/BytePointerData.h>
#endif
#ifndef INCLUDED_lime_utils_Preloader
#include <lime/utils/Preloader.h>
#endif
#ifndef INCLUDED_lime_utils_TAError
#include <lime/utils/TAError.h>
#endif
#ifndef INCLUDED_lime_utils__BytePointer_BytePointer_Impl_
#include <lime/utils/_BytePointer/BytePointer_Impl_.h>
#endif
#ifndef INCLUDED_lime_utils__DataPointer_DataPointer_Impl_
#include <lime/utils/_DataPointer/DataPointer_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e47a9afac0942eb9_26_new,"Main","new",0x6616a5cb,"Main.new","Main.hx",26,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_81_glCreateShader,"Main","glCreateShader",0x572fe57b,"Main.glCreateShader","Main.hx",81,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_101_glCreateProgram,"Main","glCreateProgram",0x872baf6e,"Main.glCreateProgram","Main.hx",101,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_128_initialize,"Main","initialize",0x8442af45,"Main.initialize","Main.hx",128,0x087e5c05)
static const Float _hx_array_data_332f6459_4[] = {
	-0.5,-0.5,-0.5,0.0,0.0,0.5,-0.5,-0.5,1.0,0.0,0.5,0.5,-0.5,1.0,1.0,0.5,0.5,-0.5,1.0,1.0,-0.5,0.5,-0.5,0.0,1.0,-0.5,-0.5,-0.5,0.0,0.0,-0.5,-0.5,0.5,0.0,0.0,0.5,-0.5,0.5,1.0,0.0,0.5,0.5,0.5,1.0,1.0,0.5,0.5,0.5,1.0,1.0,-0.5,0.5,0.5,0.0,1.0,-0.5,-0.5,0.5,0.0,0.0,-0.5,0.5,0.5,1.0,0.0,-0.5,0.5,-0.5,1.0,1.0,-0.5,-0.5,-0.5,0.0,1.0,-0.5,-0.5,-0.5,0.0,1.0,-0.5,-0.5,0.5,0.0,0.0,-0.5,0.5,0.5,1.0,0.0,0.5,0.5,0.5,1.0,0.0,0.5,0.5,-0.5,1.0,1.0,0.5,-0.5,-0.5,0.0,1.0,0.5,-0.5,-0.5,0.0,1.0,0.5,-0.5,0.5,0.0,0.0,0.5,0.5,0.5,1.0,0.0,-0.5,-0.5,-0.5,0.0,1.0,0.5,-0.5,-0.5,1.0,1.0,0.5,-0.5,0.5,1.0,0.0,0.5,-0.5,0.5,1.0,0.0,-0.5,-0.5,0.5,0.0,0.0,-0.5,-0.5,-0.5,0.0,1.0,-0.5,0.5,-0.5,0.0,1.0,0.5,0.5,-0.5,1.0,1.0,0.5,0.5,0.5,1.0,0.0,0.5,0.5,0.5,1.0,0.0,-0.5,0.5,0.5,0.0,0.0,-0.5,0.5,-0.5,0.0,1.0,
};
static const Float _hx_array_data_332f6459_5[] = {
	0.0,0.0,-10.0,
};
static const Float _hx_array_data_332f6459_6[] = {
	2.0,5.0,-15.0,
};
static const Float _hx_array_data_332f6459_7[] = {
	-1.5,-2.2,-2.5,
};
static const Float _hx_array_data_332f6459_8[] = {
	-3.8,-2.0,-12.3,
};
static const Float _hx_array_data_332f6459_9[] = {
	2.4,-0.4,-3.5,
};
static const Float _hx_array_data_332f6459_10[] = {
	-1.7,3.0,-7.5,
};
static const Float _hx_array_data_332f6459_11[] = {
	1.3,-2.0,-2.5,
};
static const Float _hx_array_data_332f6459_12[] = {
	1.5,2.0,-2.5,
};
static const Float _hx_array_data_332f6459_13[] = {
	1.5,0.2,-1.5,
};
static const Float _hx_array_data_332f6459_14[] = {
	-1.3,1.0,-1.5,
};
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_288_createPerspectiveZO,"Main","createPerspectiveZO",0x51106200,"Main.createPerspectiveZO","Main.hx",288,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_314_createLookAtMatrix,"Main","createLookAtMatrix",0x283d4924,"Main.createLookAtMatrix","Main.hx",314,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_343_moveCamera,"Main","moveCamera",0x9f423e8b,"Main.moveCamera","Main.hx",343,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_371_update,"Main","update",0xb7afa57e,"Main.update","Main.hx",371,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_390_onKeyDown,"Main","onKeyDown",0x547b59ed,"Main.onKeyDown","Main.hx",390,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_404_onKeyUp,"Main","onKeyUp",0xd96dbf26,"Main.onKeyUp","Main.hx",404,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_422_onMouseMove,"Main","onMouseMove",0x15ff3722,"Main.onMouseMove","Main.hx",422,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_451_onMouseWheel,"Main","onMouseWheel",0xe6a56f6a,"Main.onMouseWheel","Main.hx",451,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_462_render,"Main","render",0x35d38acb,"Main.render","Main.hx",462,0x087e5c05)

void Main_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_26_new)
HXLINE(  62)		this->moveBackward = false;
HXLINE(  61)		this->moveForward = false;
HXLINE(  60)		this->moveRight = false;
HXLINE(  59)		this->moveLeft = false;
HXLINE(  68)		super::__construct();
HXLINE(  70)		this->initialized = false;
            	}

Dynamic Main_obj::__CreateEmpty() { return new Main_obj; }

void *Main_obj::_hx_vtable = 0;

Dynamic Main_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Main_obj > _hx_result = new Main_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Main_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x431bf104) {
		if (inClassId<=(int)0x07825a7d) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x07825a7d;
		} else {
			return inClassId==(int)0x431bf104;
		}
	} else {
		return inClassId==(int)0x7f8386d8;
	}
}

 ::lime::graphics::opengl::GLObject Main_obj::glCreateShader( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl,::String source,int type){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_81_glCreateShader)
HXLINE(  82)		 ::lime::graphics::opengl::GLObject shader = gl->createShader(type);
HXLINE(  83)		gl->shaderSource(shader,source);
HXLINE(  84)		gl->compileShader(shader);
HXLINE(  86)		if (::hx::IsEq( gl->getShaderParameter(shader,gl->COMPILE_STATUS),0 )) {
HXLINE(  87)			 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN(  87)			::String _hx_tmp1 = gl->getShaderInfoLog(shader);
HXDLIN(  87)			_hx_tmp(_hx_tmp1,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),87,HX_("Main",59,64,2f,33),HX_("glCreateShader",06,c9,79,c8)));
HXLINE(  88)			return null();
            		}
HXLINE(  91)		return shader;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Main_obj,glCreateShader,return )

 ::lime::graphics::opengl::GLObject Main_obj::glCreateProgram( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl,::String vertexSource,::String fragmentSource){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_101_glCreateProgram)
HXLINE( 102)		 ::lime::graphics::opengl::GLObject vs = this->glCreateShader(gl,vertexSource,gl->VERTEX_SHADER);
HXLINE( 103)		 ::lime::graphics::opengl::GLObject fs = this->glCreateShader(gl,fragmentSource,gl->FRAGMENT_SHADER);
HXLINE( 105)		bool _hx_tmp;
HXDLIN( 105)		if (::hx::IsNotNull( vs )) {
HXLINE( 105)			_hx_tmp = ::hx::IsNull( fs );
            		}
            		else {
HXLINE( 105)			_hx_tmp = true;
            		}
HXDLIN( 105)		if (_hx_tmp) {
HXLINE( 106)			return null();
            		}
HXLINE( 109)		 ::lime::graphics::opengl::GLObject program = gl->createProgram();
HXLINE( 110)		gl->attachShader(program,vs);
HXLINE( 111)		gl->attachShader(program,fs);
HXLINE( 113)		gl->deleteShader(vs);
HXLINE( 114)		gl->deleteShader(fs);
HXLINE( 116)		gl->linkProgram(program);
HXLINE( 118)		if (::hx::IsEq( gl->getProgramParameter(program,gl->LINK_STATUS),0 )) {
HXLINE( 119)			 ::Dynamic _hx_tmp1 = ::haxe::Log_obj::trace;
HXDLIN( 119)			::String _hx_tmp2 = gl->getProgramInfoLog(program);
HXDLIN( 119)			_hx_tmp1(_hx_tmp2,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),119,HX_("Main",59,64,2f,33),HX_("glCreateProgram",83,e5,88,36)));
HXLINE( 120)			 ::Dynamic _hx_tmp3 = ::haxe::Log_obj::trace;
HXDLIN( 120)			::String _hx_tmp4 = (HX_("VALIDATE_STATUS: ",61,4a,52,b0) + ::Std_obj::string(gl->getProgramParameter(program,gl->VALIDATE_STATUS)));
HXDLIN( 120)			_hx_tmp3(_hx_tmp4,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),120,HX_("Main",59,64,2f,33),HX_("glCreateProgram",83,e5,88,36)));
HXLINE( 121)			 ::Dynamic _hx_tmp5 = ::haxe::Log_obj::trace;
HXDLIN( 121)			::String _hx_tmp6 = (HX_("ERROR: ",4e,70,de,69) + gl->getError());
HXDLIN( 121)			_hx_tmp5(_hx_tmp6,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),121,HX_("Main",59,64,2f,33),HX_("glCreateProgram",83,e5,88,36)));
HXLINE( 122)			return null();
            		}
HXLINE( 125)		return program;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Main_obj,glCreateProgram,return )

void Main_obj::initialize( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_128_initialize)
HXLINE( 129)		this->deltaTime = ((Float)0.0);
HXLINE( 130)		this->lastFrame = ((Float)0.0);
HXLINE( 132)		this->firstMouse = true;
HXLINE( 134)		::Array< Float > vertices = ::Array_obj< Float >::fromData( _hx_array_data_332f6459_4,180);
HXLINE( 178)		 ::Dynamic elements = null();
HXDLIN( 178)		 ::haxe::io::Bytes buffer = null();
HXDLIN( 178)		 ::lime::utils::ArrayBufferView view = null();
HXDLIN( 178)		 ::Dynamic len = null();
HXDLIN( 178)		 ::lime::utils::ArrayBufferView this1;
HXDLIN( 178)		if (::hx::IsNotNull( elements )) {
HXLINE( 178)			this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,8);
            		}
            		else {
HXLINE( 178)			if (::hx::IsNotNull( vertices )) {
HXLINE( 178)				 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN( 178)				_this->byteOffset = 0;
HXDLIN( 178)				_this->length = vertices->length;
HXDLIN( 178)				_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN( 178)				_this->buffer = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN( 178)				_this->copyFromArray(vertices,null());
HXDLIN( 178)				this1 = _this;
            			}
            			else {
HXLINE( 178)				if (::hx::IsNotNull( view )) {
HXLINE( 178)					 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN( 178)					 ::haxe::io::Bytes srcData = view->buffer;
HXDLIN( 178)					int srcLength = view->length;
HXDLIN( 178)					int srcByteOffset = view->byteOffset;
HXDLIN( 178)					int srcElementSize = view->bytesPerElement;
HXDLIN( 178)					int elementSize = _this1->bytesPerElement;
HXDLIN( 178)					if ((view->type == _this1->type)) {
HXLINE( 178)						int srcLength1 = srcData->length;
HXDLIN( 178)						int cloneLength = (srcLength1 - srcByteOffset);
HXDLIN( 178)						_this1->buffer = ::haxe::io::Bytes_obj::alloc(cloneLength);
HXDLIN( 178)						_this1->buffer->blit(0,srcData,srcByteOffset,cloneLength);
            					}
            					else {
HXLINE( 178)						HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            					}
HXDLIN( 178)					_this1->byteLength = (_this1->bytesPerElement * srcLength);
HXDLIN( 178)					_this1->byteOffset = 0;
HXDLIN( 178)					_this1->length = srcLength;
HXDLIN( 178)					this1 = _this1;
            				}
            				else {
HXLINE( 178)					if (::hx::IsNotNull( buffer )) {
HXLINE( 178)						 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN( 178)						int in_byteOffset = 0;
HXDLIN( 178)						if ((in_byteOffset < 0)) {
HXLINE( 178)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 178)						if ((::hx::Mod(in_byteOffset,_this2->bytesPerElement) != 0)) {
HXLINE( 178)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 178)						int bufferByteLength = buffer->length;
HXDLIN( 178)						int elementSize1 = _this2->bytesPerElement;
HXDLIN( 178)						int newByteLength = bufferByteLength;
HXDLIN( 178)						if (::hx::IsNull( len )) {
HXLINE( 178)							newByteLength = (bufferByteLength - in_byteOffset);
HXDLIN( 178)							if ((::hx::Mod(bufferByteLength,_this2->bytesPerElement) != 0)) {
HXLINE( 178)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 178)							if ((newByteLength < 0)) {
HXLINE( 178)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 178)							newByteLength = (( (int)(len) ) * _this2->bytesPerElement);
HXDLIN( 178)							int newRange = (in_byteOffset + newByteLength);
HXDLIN( 178)							if ((newRange > bufferByteLength)) {
HXLINE( 178)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 178)						_this2->buffer = buffer;
HXDLIN( 178)						_this2->byteOffset = in_byteOffset;
HXDLIN( 178)						_this2->byteLength = newByteLength;
HXDLIN( 178)						_this2->length = ::Std_obj::_hx_int((( (Float)(newByteLength) ) / ( (Float)(_this2->bytesPerElement) )));
HXDLIN( 178)						this1 = _this2;
            					}
            					else {
HXLINE( 178)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            					}
            				}
            			}
            		}
HXDLIN( 178)		 ::lime::utils::ArrayBufferView verticesData = this1;
HXLINE( 180)		this->cubePositions = ::Array_obj< ::Dynamic>::__new(10)->init(0,::Array_obj< Float >::fromData( _hx_array_data_332f6459_5,3))->init(1,::Array_obj< Float >::fromData( _hx_array_data_332f6459_6,3))->init(2,::Array_obj< Float >::fromData( _hx_array_data_332f6459_7,3))->init(3,::Array_obj< Float >::fromData( _hx_array_data_332f6459_8,3))->init(4,::Array_obj< Float >::fromData( _hx_array_data_332f6459_9,3))->init(5,::Array_obj< Float >::fromData( _hx_array_data_332f6459_10,3))->init(6,::Array_obj< Float >::fromData( _hx_array_data_332f6459_11,3))->init(7,::Array_obj< Float >::fromData( _hx_array_data_332f6459_12,3))->init(8,::Array_obj< Float >::fromData( _hx_array_data_332f6459_13,3))->init(9,::Array_obj< Float >::fromData( _hx_array_data_332f6459_14,3));
HXLINE( 184)		gl->enable(gl->DEPTH_TEST);
HXLINE( 187)		::String vs = HX_("#version 300 es\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec2 aTexCoord; \nout vec2 TexCoord;\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 proj;\nvoid main()\n{\n\tgl_Position =  proj * view * model * vec4(aPos, 1.0);\n\tTexCoord = aTexCoord;\n}\n",97,ab,7b,af);
HXLINE( 202)		::String fs = HX_("#version 300 es\nprecision mediump float;\nout vec4 FragColor;\nin vec2 TexCoord;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nvoid main() \n{\n    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);\n}\n",08,4d,ec,a4);
HXLINE( 214)		this->cameraPos =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)0.0),((Float)10.0),((Float)1.0));
HXLINE( 215)		this->cameraFront =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)0.0),((Float)-1.0),((Float)1.0));
HXLINE( 216)		this->cameraUp =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)1.0),((Float)0.0),((Float)1.0));
HXLINE( 219)		this->program = this->glCreateProgram(gl,vs,fs);
HXLINE( 221)		this->lastX = (( (Float)(::lime::app::Application_obj::current->_hx___window->_hx___width) ) / ( (Float)(2) ));
HXLINE( 222)		this->lastY = (( (Float)(::lime::app::Application_obj::current->_hx___window->_hx___height) ) / ( (Float)(2) ));
HXLINE( 224)		this->pitch = ((Float)0.0);
HXLINE( 225)		this->yaw = ((Float)-90.0);
HXLINE( 226)		this->fov = ((Float)45.0);
HXLINE( 229)		this->vbo = gl->createBuffer();
HXLINE( 232)		gl->bindBuffer(gl->ARRAY_BUFFER,this->vbo);
HXLINE( 233)		::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::bufferData(gl,gl->ARRAY_BUFFER,verticesData,gl->STATIC_DRAW,null(),null());
HXLINE( 235)		{
HXLINE( 235)			 ::lime::graphics::opengl::GLObject buffer1 = null();
HXDLIN( 235)			gl->bindBuffer(gl->ARRAY_BUFFER,buffer1);
            		}
HXLINE( 238)		{
HXLINE( 238)			int type = gl->FLOAT;
HXDLIN( 238)			gl->vertexAttribPointer(0,3,type,false,20,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt(0));
            		}
HXLINE( 239)		gl->enableVertexAttribArray(0);
HXLINE( 241)		bool _hx_tmp;
HXDLIN( 241)		if (::hx::IsNull( this->image )) {
HXLINE( 241)			_hx_tmp = this->_hx___preloader->complete;
            		}
            		else {
HXLINE( 241)			_hx_tmp = false;
            		}
HXDLIN( 241)		if (_hx_tmp) {
HXLINE( 242)			this->image = ::lime::utils::Assets_obj::getImage(HX_("assets/container.jpg",68,a1,5c,4d),null());
HXLINE( 245)			this->texture = gl->createTexture();
HXLINE( 246)			gl->activeTexture(gl->TEXTURE0);
HXLINE( 247)			gl->bindTexture(gl->TEXTURE_2D,this->texture);
HXLINE( 250)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_WRAP_S,gl->REPEAT);
HXLINE( 251)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_WRAP_T,gl->REPEAT);
HXLINE( 253)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_MIN_FILTER,gl->LINEAR_MIPMAP_LINEAR);
HXLINE( 254)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_MAG_FILTER,gl->LINEAR);
HXLINE( 255)			{
HXLINE( 255)				int target = gl->TEXTURE_2D;
HXDLIN( 255)				int internalformat = gl->RGB;
HXDLIN( 255)				int width = this->image->width;
HXDLIN( 255)				int height = this->image->height;
HXDLIN( 255)				int format = gl->RGB;
HXDLIN( 255)				int type1 = gl->UNSIGNED_BYTE;
HXDLIN( 255)				 ::lime::utils::ArrayBufferView srcData1 = ( ( ::lime::utils::ArrayBufferView)(this->image->get_src()) );
HXDLIN( 255)				::lime::utils::_BytePointer::BytePointer_Impl__obj::set(::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::_hx___tempPointer,null(),srcData1,null(),0);
HXDLIN( 255)				gl->texImage2D(target,0,internalformat,width,height,0,format,type1,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromBytesPointer(::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::_hx___tempPointer));
            			}
HXLINE( 257)			gl->generateMipmap(gl->TEXTURE_2D);
            		}
HXLINE( 260)		bool _hx_tmp1;
HXDLIN( 260)		if (::hx::IsNull( this->image2 )) {
HXLINE( 260)			_hx_tmp1 = this->_hx___preloader->complete;
            		}
            		else {
HXLINE( 260)			_hx_tmp1 = false;
            		}
HXDLIN( 260)		if (_hx_tmp1) {
HXLINE( 261)			this->image2 = ::lime::utils::Assets_obj::getImage(HX_("assets/awesomeface.png",af,43,32,4a),null());
HXLINE( 264)			this->texture2 = gl->createTexture();
HXLINE( 265)			gl->activeTexture(gl->TEXTURE0);
HXLINE( 266)			gl->bindTexture(gl->TEXTURE_2D,this->texture2);
HXLINE( 269)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_WRAP_S,gl->REPEAT);
HXLINE( 270)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_WRAP_T,gl->REPEAT);
HXLINE( 272)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_MIN_FILTER,gl->LINEAR_MIPMAP_LINEAR);
HXLINE( 273)			gl->texParameteri(gl->TEXTURE_2D,gl->TEXTURE_MAG_FILTER,gl->LINEAR);
HXLINE( 274)			{
HXLINE( 274)				int target1 = gl->TEXTURE_2D;
HXDLIN( 274)				int internalformat1 = gl->RGBA;
HXDLIN( 274)				int width1 = this->image2->width;
HXDLIN( 274)				int height1 = this->image2->height;
HXDLIN( 274)				int format1 = gl->RGBA;
HXDLIN( 274)				int type2 = gl->UNSIGNED_BYTE;
HXDLIN( 274)				 ::lime::utils::ArrayBufferView srcData2 = ( ( ::lime::utils::ArrayBufferView)(this->image2->get_src()) );
HXDLIN( 274)				::lime::utils::_BytePointer::BytePointer_Impl__obj::set(::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::_hx___tempPointer,null(),srcData2,null(),0);
HXDLIN( 274)				gl->texImage2D(target1,0,internalformat1,width1,height1,0,format1,type2,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromBytesPointer(::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::_hx___tempPointer));
            			}
HXLINE( 276)			gl->generateMipmap(gl->TEXTURE_2D);
HXLINE( 278)			this->initialized = true;
            		}
HXLINE( 281)		gl->useProgram(this->program);
HXLINE( 283)		gl->uniform1i(gl->getUniformLocation(this->program,HX_("texture1",f6,f6,ce,65)),0);
HXLINE( 284)		gl->uniform1i(gl->getUniformLocation(this->program,HX_("texture2",f7,f6,ce,65)),1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,initialize,(void))

void Main_obj::createPerspectiveZO( ::lime::utils::ArrayBufferView mat,Float fovy,Float aspect,Float zNear,Float zFar){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_288_createPerspectiveZO)
HXDLIN( 288)		if ((::Math_obj::abs((aspect - ::Math_obj::pow(( (Float)(2) ),( (Float)(-23) )))) > ((Float)0.0))) {
HXLINE( 289)			Float top = (::Math_obj::tan(fovy) * zNear);
HXLINE( 290)			Float bottom = -(top);
HXLINE( 291)			Float right = (top * aspect);
HXLINE( 292)			Float left = -(right);
HXLINE( 294)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,0,((((Float)2.0) * zNear) / (right - left)));
HXLINE( 295)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,5,((((Float)2.0) * zNear) / (top - bottom)));
HXLINE( 296)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,8,((right + left) / (right - left)));
HXLINE( 297)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,9,((top + bottom) / (top - bottom)));
HXLINE( 298)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,10,(-((zFar + zNear)) / (zFar - zNear)));
HXLINE( 299)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,11,((Float)-1.0));
HXLINE( 300)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(mat,14,(((( (Float)(-2) ) * zFar) * zNear) / (zFar - zNear)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Main_obj,createPerspectiveZO,(void))

 ::lime::utils::ArrayBufferView Main_obj::createLookAtMatrix( ::lime::math::Vector4 cameraPos, ::lime::math::Vector4 target, ::lime::math::Vector4 up){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_314_createLookAtMatrix)
HXLINE( 315)		 ::lime::math::Vector4 result = null();
HXDLIN( 315)		if (::hx::IsNull( result )) {
HXLINE( 315)			result =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXDLIN( 315)		{
HXLINE( 315)			result->x = (cameraPos->x - target->x);
HXDLIN( 315)			result->y = (cameraPos->y - target->y);
HXDLIN( 315)			result->z = (cameraPos->z - target->z);
            		}
HXDLIN( 315)		 ::lime::math::Vector4 cameraDir = result;
HXLINE( 316)		{
HXLINE( 316)			Float l = ::Math_obj::sqrt((((cameraDir->x * cameraDir->x) + (cameraDir->y * cameraDir->y)) + (cameraDir->z * cameraDir->z)));
HXDLIN( 316)			if ((l != 0)) {
HXLINE( 316)				 ::lime::math::Vector4 cameraDir1 = cameraDir;
HXDLIN( 316)				cameraDir1->x = (cameraDir1->x / l);
HXDLIN( 316)				 ::lime::math::Vector4 cameraDir2 = cameraDir;
HXDLIN( 316)				cameraDir2->y = (cameraDir2->y / l);
HXDLIN( 316)				 ::lime::math::Vector4 cameraDir3 = cameraDir;
HXDLIN( 316)				cameraDir3->z = (cameraDir3->z / l);
            			}
            		}
HXLINE( 317)		 ::lime::math::Vector4 result1 = null();
HXDLIN( 317)		if (::hx::IsNull( result1 )) {
HXLINE( 317)			result1 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXDLIN( 317)		{
HXLINE( 317)			Float ya = ((up->z * cameraDir->x) - (up->x * cameraDir->z));
HXDLIN( 317)			Float za = ((up->x * cameraDir->y) - (up->y * cameraDir->x));
HXDLIN( 317)			result1->x = ((up->y * cameraDir->z) - (up->z * cameraDir->y));
HXDLIN( 317)			result1->y = ya;
HXDLIN( 317)			result1->z = za;
            		}
HXDLIN( 317)		result1->w = ( (Float)(1) );
HXDLIN( 317)		 ::lime::math::Vector4 cameraRight = result1;
HXLINE( 318)		{
HXLINE( 318)			Float l1 = ::Math_obj::sqrt((((cameraRight->x * cameraRight->x) + (cameraRight->y * cameraRight->y)) + (cameraRight->z * cameraRight->z)));
HXDLIN( 318)			if ((l1 != 0)) {
HXLINE( 318)				 ::lime::math::Vector4 cameraRight1 = cameraRight;
HXDLIN( 318)				cameraRight1->x = (cameraRight1->x / l1);
HXDLIN( 318)				 ::lime::math::Vector4 cameraRight2 = cameraRight;
HXDLIN( 318)				cameraRight2->y = (cameraRight2->y / l1);
HXDLIN( 318)				 ::lime::math::Vector4 cameraRight3 = cameraRight;
HXDLIN( 318)				cameraRight3->z = (cameraRight3->z / l1);
            			}
            		}
HXLINE( 319)		 ::lime::math::Vector4 result2 = null();
HXDLIN( 319)		if (::hx::IsNull( result2 )) {
HXLINE( 319)			result2 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXDLIN( 319)		{
HXLINE( 319)			Float ya1 = ((cameraDir->z * cameraRight->x) - (cameraDir->x * cameraRight->z));
HXDLIN( 319)			Float za1 = ((cameraDir->x * cameraRight->y) - (cameraDir->y * cameraRight->x));
HXDLIN( 319)			result2->x = ((cameraDir->y * cameraRight->z) - (cameraDir->z * cameraRight->y));
HXDLIN( 319)			result2->y = ya1;
HXDLIN( 319)			result2->z = za1;
            		}
HXDLIN( 319)		result2->w = ( (Float)(1) );
HXDLIN( 319)		 ::lime::math::Vector4 cameraUp = result2;
HXLINE( 320)		{
HXLINE( 320)			Float l2 = ::Math_obj::sqrt((((cameraUp->x * cameraUp->x) + (cameraUp->y * cameraUp->y)) + (cameraUp->z * cameraUp->z)));
HXDLIN( 320)			if ((l2 != 0)) {
HXLINE( 320)				 ::lime::math::Vector4 cameraUp1 = cameraUp;
HXDLIN( 320)				cameraUp1->x = (cameraUp1->x / l2);
HXDLIN( 320)				 ::lime::math::Vector4 cameraUp2 = cameraUp;
HXDLIN( 320)				cameraUp2->y = (cameraUp2->y / l2);
HXDLIN( 320)				 ::lime::math::Vector4 cameraUp3 = cameraUp;
HXDLIN( 320)				cameraUp3->z = (cameraUp3->z / l2);
            			}
            		}
HXLINE( 321)		 ::lime::utils::ArrayBufferView cameraMat = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 323)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,0,cameraRight->x);
HXLINE( 324)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,1,cameraUp->x);
HXLINE( 325)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,2,cameraDir->x);
HXLINE( 326)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,3,((Float)0.0));
HXLINE( 327)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,4,cameraRight->y);
HXLINE( 328)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,5,cameraUp->y);
HXLINE( 329)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,6,cameraDir->y);
HXLINE( 330)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,7,((Float)0.0));
HXLINE( 331)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,8,cameraRight->z);
HXLINE( 332)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,9,cameraUp->z);
HXLINE( 333)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,10,cameraDir->z);
HXLINE( 334)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,11,((Float)0.0));
HXLINE( 335)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,12,-(cameraPos->x));
HXLINE( 336)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,13,-(cameraPos->y));
HXLINE( 337)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,14,-(cameraPos->z));
HXLINE( 338)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(cameraMat,15,((Float)1.0));
HXLINE( 340)		return cameraMat;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Main_obj,createLookAtMatrix,return )

void Main_obj::moveCamera(){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_343_moveCamera)
HXLINE( 344)		Float camSpeed = (( (Float)(10) ) * this->deltaTime);
HXLINE( 345)		if (this->moveForward) {
HXLINE( 346)			 ::lime::math::Vector4 _this = this->cameraFront;
HXDLIN( 346)			 ::lime::math::Vector4 tgt =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,_this->x,_this->y,_this->z,_this->w);
HXLINE( 347)			{
HXLINE( 347)				Float l = ::Math_obj::sqrt((((tgt->x * tgt->x) + (tgt->y * tgt->y)) + (tgt->z * tgt->z)));
HXDLIN( 347)				if ((l != 0)) {
HXLINE( 347)					 ::lime::math::Vector4 tgt1 = tgt;
HXDLIN( 347)					tgt1->x = (tgt1->x / l);
HXDLIN( 347)					 ::lime::math::Vector4 tgt2 = tgt;
HXDLIN( 347)					tgt2->y = (tgt2->y / l);
HXDLIN( 347)					 ::lime::math::Vector4 tgt3 = tgt;
HXDLIN( 347)					tgt3->z = (tgt3->z / l);
            				}
            			}
HXLINE( 348)			{
HXLINE( 348)				 ::lime::math::Vector4 tgt4 = tgt;
HXDLIN( 348)				tgt4->x = (tgt4->x * camSpeed);
HXDLIN( 348)				 ::lime::math::Vector4 tgt5 = tgt;
HXDLIN( 348)				tgt5->y = (tgt5->y * camSpeed);
HXDLIN( 348)				 ::lime::math::Vector4 tgt6 = tgt;
HXDLIN( 348)				tgt6->z = (tgt6->z * camSpeed);
            			}
HXLINE( 349)			 ::lime::math::Vector4 _this1 = this->cameraPos;
HXDLIN( 349)			 ::lime::math::Vector4 result = null();
HXDLIN( 349)			if (::hx::IsNull( result )) {
HXLINE( 349)				result =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 349)			{
HXLINE( 349)				result->x = (_this1->x + tgt->x);
HXDLIN( 349)				result->y = (_this1->y + tgt->y);
HXDLIN( 349)				result->z = (_this1->z + tgt->z);
            			}
HXDLIN( 349)			this->cameraPos = result;
            		}
HXLINE( 351)		if (this->moveBackward) {
HXLINE( 352)			 ::lime::math::Vector4 _this2 = this->cameraFront;
HXDLIN( 352)			 ::lime::math::Vector4 tgt7 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,_this2->x,_this2->y,_this2->z,_this2->w);
HXLINE( 353)			{
HXLINE( 353)				Float l1 = ::Math_obj::sqrt((((tgt7->x * tgt7->x) + (tgt7->y * tgt7->y)) + (tgt7->z * tgt7->z)));
HXDLIN( 353)				if ((l1 != 0)) {
HXLINE( 353)					 ::lime::math::Vector4 tgt8 = tgt7;
HXDLIN( 353)					tgt8->x = (tgt8->x / l1);
HXDLIN( 353)					 ::lime::math::Vector4 tgt9 = tgt7;
HXDLIN( 353)					tgt9->y = (tgt9->y / l1);
HXDLIN( 353)					 ::lime::math::Vector4 tgt10 = tgt7;
HXDLIN( 353)					tgt10->z = (tgt10->z / l1);
            				}
            			}
HXLINE( 354)			{
HXLINE( 354)				 ::lime::math::Vector4 tgt11 = tgt7;
HXDLIN( 354)				tgt11->x = (tgt11->x * camSpeed);
HXDLIN( 354)				 ::lime::math::Vector4 tgt12 = tgt7;
HXDLIN( 354)				tgt12->y = (tgt12->y * camSpeed);
HXDLIN( 354)				 ::lime::math::Vector4 tgt13 = tgt7;
HXDLIN( 354)				tgt13->z = (tgt13->z * camSpeed);
            			}
HXLINE( 355)			 ::lime::math::Vector4 _this3 = this->cameraPos;
HXDLIN( 355)			 ::lime::math::Vector4 result1 = null();
HXDLIN( 355)			if (::hx::IsNull( result1 )) {
HXLINE( 355)				result1 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 355)			{
HXLINE( 355)				result1->x = (_this3->x - tgt7->x);
HXDLIN( 355)				result1->y = (_this3->y - tgt7->y);
HXDLIN( 355)				result1->z = (_this3->z - tgt7->z);
            			}
HXDLIN( 355)			this->cameraPos = result1;
            		}
HXLINE( 357)		if (this->moveLeft) {
HXLINE( 358)			 ::lime::math::Vector4 _this4 = this->cameraFront;
HXDLIN( 358)			 ::lime::math::Vector4 a = this->cameraUp;
HXDLIN( 358)			 ::lime::math::Vector4 result2 = null();
HXDLIN( 358)			if (::hx::IsNull( result2 )) {
HXLINE( 358)				result2 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 358)			{
HXLINE( 358)				Float ya = ((_this4->z * a->x) - (_this4->x * a->z));
HXDLIN( 358)				Float za = ((_this4->x * a->y) - (_this4->y * a->x));
HXDLIN( 358)				result2->x = ((_this4->y * a->z) - (_this4->z * a->y));
HXDLIN( 358)				result2->y = ya;
HXDLIN( 358)				result2->z = za;
            			}
HXDLIN( 358)			result2->w = ( (Float)(1) );
HXDLIN( 358)			 ::lime::math::Vector4 m = result2;
HXLINE( 359)			{
HXLINE( 359)				Float l2 = ::Math_obj::sqrt((((m->x * m->x) + (m->y * m->y)) + (m->z * m->z)));
HXDLIN( 359)				if ((l2 != 0)) {
HXLINE( 359)					 ::lime::math::Vector4 m1 = m;
HXDLIN( 359)					m1->x = (m1->x / l2);
HXDLIN( 359)					 ::lime::math::Vector4 m2 = m;
HXDLIN( 359)					m2->y = (m2->y / l2);
HXDLIN( 359)					 ::lime::math::Vector4 m3 = m;
HXDLIN( 359)					m3->z = (m3->z / l2);
            				}
            			}
HXLINE( 360)			{
HXLINE( 360)				 ::lime::math::Vector4 m4 = m;
HXDLIN( 360)				m4->x = (m4->x * camSpeed);
HXDLIN( 360)				 ::lime::math::Vector4 m5 = m;
HXDLIN( 360)				m5->y = (m5->y * camSpeed);
HXDLIN( 360)				 ::lime::math::Vector4 m6 = m;
HXDLIN( 360)				m6->z = (m6->z * camSpeed);
            			}
HXLINE( 361)			 ::lime::math::Vector4 _this5 = this->cameraPos;
HXDLIN( 361)			 ::lime::math::Vector4 result3 = null();
HXDLIN( 361)			if (::hx::IsNull( result3 )) {
HXLINE( 361)				result3 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 361)			{
HXLINE( 361)				result3->x = (_this5->x - m->x);
HXDLIN( 361)				result3->y = (_this5->y - m->y);
HXDLIN( 361)				result3->z = (_this5->z - m->z);
            			}
HXDLIN( 361)			this->cameraPos = result3;
            		}
HXLINE( 363)		if (this->moveRight) {
HXLINE( 364)			 ::lime::math::Vector4 _this6 = this->cameraFront;
HXDLIN( 364)			 ::lime::math::Vector4 a1 = this->cameraUp;
HXDLIN( 364)			 ::lime::math::Vector4 result4 = null();
HXDLIN( 364)			if (::hx::IsNull( result4 )) {
HXLINE( 364)				result4 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 364)			{
HXLINE( 364)				Float ya1 = ((_this6->z * a1->x) - (_this6->x * a1->z));
HXDLIN( 364)				Float za1 = ((_this6->x * a1->y) - (_this6->y * a1->x));
HXDLIN( 364)				result4->x = ((_this6->y * a1->z) - (_this6->z * a1->y));
HXDLIN( 364)				result4->y = ya1;
HXDLIN( 364)				result4->z = za1;
            			}
HXDLIN( 364)			result4->w = ( (Float)(1) );
HXDLIN( 364)			 ::lime::math::Vector4 m7 = result4;
HXLINE( 365)			{
HXLINE( 365)				Float l3 = ::Math_obj::sqrt((((m7->x * m7->x) + (m7->y * m7->y)) + (m7->z * m7->z)));
HXDLIN( 365)				if ((l3 != 0)) {
HXLINE( 365)					 ::lime::math::Vector4 m8 = m7;
HXDLIN( 365)					m8->x = (m8->x / l3);
HXDLIN( 365)					 ::lime::math::Vector4 m9 = m7;
HXDLIN( 365)					m9->y = (m9->y / l3);
HXDLIN( 365)					 ::lime::math::Vector4 m10 = m7;
HXDLIN( 365)					m10->z = (m10->z / l3);
            				}
            			}
HXLINE( 366)			{
HXLINE( 366)				 ::lime::math::Vector4 m11 = m7;
HXDLIN( 366)				m11->x = (m11->x * camSpeed);
HXDLIN( 366)				 ::lime::math::Vector4 m12 = m7;
HXDLIN( 366)				m12->y = (m12->y * camSpeed);
HXDLIN( 366)				 ::lime::math::Vector4 m13 = m7;
HXDLIN( 366)				m13->z = (m13->z * camSpeed);
            			}
HXLINE( 367)			 ::lime::math::Vector4 _this7 = this->cameraPos;
HXDLIN( 367)			 ::lime::math::Vector4 result5 = null();
HXDLIN( 367)			if (::hx::IsNull( result5 )) {
HXLINE( 367)				result5 =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 367)			{
HXLINE( 367)				result5->x = (_this7->x + m7->x);
HXDLIN( 367)				result5->y = (_this7->y + m7->y);
HXDLIN( 367)				result5->z = (_this7->z + m7->z);
            			}
HXDLIN( 367)			this->cameraPos = result5;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,moveCamera,(void))

void Main_obj::update(int deltaTime){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_371_update)
HXLINE( 372)		this->deltaTime = ((( (Float)(deltaTime) ) * ((Float)1.0)) / ((Float)1000.0));
HXLINE( 373)		bool _hx_tmp;
HXDLIN( 373)		bool _hx_tmp1;
HXDLIN( 373)		bool _hx_tmp2;
HXDLIN( 373)		if (!(this->moveLeft)) {
HXLINE( 373)			_hx_tmp2 = this->moveRight;
            		}
            		else {
HXLINE( 373)			_hx_tmp2 = true;
            		}
HXDLIN( 373)		if (!(_hx_tmp2)) {
HXLINE( 373)			_hx_tmp1 = this->moveForward;
            		}
            		else {
HXLINE( 373)			_hx_tmp1 = true;
            		}
HXDLIN( 373)		if (!(_hx_tmp1)) {
HXLINE( 373)			_hx_tmp = this->moveBackward;
            		}
            		else {
HXLINE( 373)			_hx_tmp = true;
            		}
HXDLIN( 373)		if (_hx_tmp) {
HXLINE( 374)			this->moveCamera();
            		}
            	}


void Main_obj::onKeyDown(int key,int modifier){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_390_onKeyDown)
HXDLIN( 390)		switch((int)(key)){
            			case (int)1073741903: {
HXLINE( 394)				this->moveRight = true;
            			}
            			break;
            			case (int)1073741904: {
HXLINE( 392)				this->moveLeft = true;
            			}
            			break;
            			case (int)1073741905: {
HXLINE( 398)				this->moveBackward = true;
            			}
            			break;
            			case (int)1073741906: {
HXLINE( 396)				this->moveForward = true;
            			}
            			break;
            			default:{
            			}
            		}
            	}


void Main_obj::onKeyUp(int key,int modifier){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_404_onKeyUp)
HXDLIN( 404)		switch((int)(key)){
            			case (int)1073741903: {
HXLINE( 408)				this->moveRight = false;
            			}
            			break;
            			case (int)1073741904: {
HXLINE( 406)				this->moveLeft = false;
            			}
            			break;
            			case (int)1073741905: {
HXLINE( 412)				this->moveBackward = false;
            			}
            			break;
            			case (int)1073741906: {
HXLINE( 410)				this->moveForward = false;
            			}
            			break;
            			default:{
            			}
            		}
            	}


void Main_obj::onMouseMove(Float x,Float y){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_422_onMouseMove)
HXLINE( 423)		::haxe::Log_obj::trace(HX_("hi",01,5b,00,00),::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),423,HX_("Main",59,64,2f,33),HX_("onMouseMove",b7,7e,f8,16)));
HXLINE( 425)		if (this->firstMouse) {
HXLINE( 426)			this->lastX = x;
HXLINE( 427)			this->lastY = y;
HXLINE( 428)			this->firstMouse = false;
            		}
HXLINE( 430)		this->sensitivity = ((Float)0.1);
HXLINE( 431)		this->xOffset = (x - this->lastX);
HXLINE( 432)		this->yOffset = (this->lastY - y);
HXLINE( 433)		this->lastX = x;
HXLINE( 434)		this->lastY = y;
HXLINE( 435)		 ::Main _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 435)		_hx_tmp->xOffset = (_hx_tmp->xOffset * this->sensitivity);
HXLINE( 436)		 ::Main _hx_tmp1 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 436)		_hx_tmp1->yOffset = (_hx_tmp1->yOffset * this->sensitivity);
HXLINE( 437)		 ::Main _hx_tmp2 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 437)		_hx_tmp2->yaw = (_hx_tmp2->yaw + this->xOffset);
HXLINE( 438)		 ::Main _hx_tmp3 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 438)		_hx_tmp3->pitch = (_hx_tmp3->pitch + this->yOffset);
HXLINE( 439)		if ((this->pitch > ((Float)89.0))) {
HXLINE( 440)			this->pitch = ((Float)89.0);
            		}
HXLINE( 441)		if ((this->pitch < ((Float)-89.0))) {
HXLINE( 442)			this->pitch = ((Float)-89.0);
            		}
HXLINE( 443)		 ::lime::math::Vector4 direction =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 444)		direction->x = (::Math_obj::cos(((this->yaw * ::Math_obj::PI) / ( (Float)(180) ))) * ::Math_obj::cos(((this->pitch * ::Math_obj::PI) / ( (Float)(180) ))));
HXLINE( 445)		direction->y = ::Math_obj::sin(((this->pitch * ::Math_obj::PI) / ( (Float)(180) )));
HXLINE( 446)		direction->z = (::Math_obj::sin(((this->yaw * ::Math_obj::PI) / ( (Float)(180) ))) * ::Math_obj::cos(((this->pitch * ::Math_obj::PI) / ( (Float)(180) ))));
HXLINE( 447)		{
HXLINE( 447)			Float l = ::Math_obj::sqrt((((direction->x * direction->x) + (direction->y * direction->y)) + (direction->z * direction->z)));
HXDLIN( 447)			if ((l != 0)) {
HXLINE( 447)				 ::lime::math::Vector4 direction1 = direction;
HXDLIN( 447)				direction1->x = (direction1->x / l);
HXDLIN( 447)				 ::lime::math::Vector4 direction2 = direction;
HXDLIN( 447)				direction2->y = (direction2->y / l);
HXDLIN( 447)				 ::lime::math::Vector4 direction3 = direction;
HXDLIN( 447)				direction3->z = (direction3->z / l);
            			}
            		}
HXLINE( 448)		this->cameraFront = direction;
            	}


void Main_obj::onMouseWheel(Float deltaX,Float deltaY, ::lime::ui::MouseWheelMode deltaMode){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_451_onMouseWheel)
HXLINE( 452)		 ::Main _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 452)		_hx_tmp->fov = (_hx_tmp->fov - deltaY);
HXLINE( 453)		if ((this->fov > ((Float)45.0))) {
HXLINE( 454)			this->fov = ((Float)45.0);
            		}
HXLINE( 456)		if ((this->fov < ((Float)1.0))) {
HXLINE( 457)			this->fov = ((Float)1.0);
            		}
            	}


void Main_obj::render( ::lime::graphics::RenderContext context){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_462_render)
HXDLIN( 462)		::String _hx_switch_0 = context->type;
            		if (  (_hx_switch_0==HX_("opengl",6f,64,94,21)) ||  (_hx_switch_0==HX_("opengles",9d,f6,c9,fa)) ||  (_hx_switch_0==HX_("webgl",b9,4b,bc,c7)) ){
HXLINE( 464)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext gl = context->webgl2;
HXLINE( 466)			if (!(this->initialized)) {
HXLINE( 467)				this->initialize(gl);
            			}
HXLINE( 470)			gl->clearColor(((Float)0.75),( (Float)(1) ),( (Float)(0) ),( (Float)(1) ));
HXLINE( 471)			gl->clear((gl->COLOR_BUFFER_BIT | gl->DEPTH_BUFFER_BIT));
HXLINE( 473)			int timer = ::lime::_hx_system::System_obj::getTimer();
HXDLIN( 473)			Float _hx_tmp;
HXDLIN( 473)			if ((timer > 0)) {
HXLINE( 473)				_hx_tmp = (( (Float)(timer) ) / ( (Float)(1000) ));
            			}
            			else {
HXLINE( 473)				_hx_tmp = ( (Float)(0) );
            			}
HXDLIN( 473)			this->currentFrame = _hx_tmp;
HXLINE( 475)			this->lastFrame = this->currentFrame;
HXLINE( 477)			gl->useProgram(this->program);
HXLINE( 479)			gl->bindBuffer(gl->ARRAY_BUFFER,this->vbo);
HXLINE( 482)			{
HXLINE( 482)				int type = gl->FLOAT;
HXDLIN( 482)				gl->vertexAttribPointer(0,3,type,false,20,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt(0));
            			}
HXLINE( 483)			gl->enableVertexAttribArray(0);
HXLINE( 486)			{
HXLINE( 486)				int type1 = gl->FLOAT;
HXDLIN( 486)				gl->vertexAttribPointer(1,2,type1,false,20,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt(12));
            			}
HXLINE( 487)			gl->enableVertexAttribArray(1);
HXLINE( 490)			gl->activeTexture(gl->TEXTURE0);
HXLINE( 491)			gl->bindTexture(gl->TEXTURE_2D,this->texture);
HXLINE( 493)			gl->activeTexture(gl->TEXTURE1);
HXLINE( 494)			gl->bindTexture(gl->TEXTURE_2D,this->texture2);
HXLINE( 496)			this->view = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 497)			::lime::math::_Matrix4::Matrix4_Impl__obj::identity(this->view);
HXLINE( 501)			 ::lime::math::Vector4 _hx_tmp1 = this->cameraPos;
HXDLIN( 501)			 ::lime::math::Vector4 _this = this->cameraPos;
HXDLIN( 501)			 ::lime::math::Vector4 a = this->cameraFront;
HXDLIN( 501)			 ::lime::math::Vector4 result = null();
HXDLIN( 501)			if (::hx::IsNull( result )) {
HXLINE( 501)				result =  ::lime::math::Vector4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 501)			{
HXLINE( 501)				result->x = (_this->x + a->x);
HXDLIN( 501)				result->y = (_this->y + a->y);
HXDLIN( 501)				result->z = (_this->z + a->z);
            			}
HXDLIN( 501)			this->view = this->createLookAtMatrix(_hx_tmp1,result, ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)0.0),((Float)1.0),((Float)0.0),null()));
HXLINE( 503)			this->proj = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 504)			::lime::math::_Matrix4::Matrix4_Impl__obj::identity(this->proj);
HXLINE( 505)			this->createPerspectiveZO(this->proj,((this->fov * ::Math_obj::PI) / ( (Float)(180) )),(( (Float)(::lime::app::Application_obj::current->_hx___window->_hx___width) ) / ( (Float)(::lime::app::Application_obj::current->_hx___window->_hx___height) )),((Float)0.1),((Float)100.0));
HXLINE( 507)			int _hx_tmp2 = gl->getUniformLocation(this->program,HX_("view",65,32,4f,4e));
HXDLIN( 507)			::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::uniformMatrix4fv(gl,_hx_tmp2,false,this->view,null(),null());
HXLINE( 508)			int _hx_tmp3 = gl->getUniformLocation(this->program,HX_("proj",9d,c7,5e,4a));
HXDLIN( 508)			::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::uniformMatrix4fv(gl,_hx_tmp3,false,this->proj,null(),null());
HXLINE( 511)			{
HXLINE( 511)				int _g = 0;
HXDLIN( 511)				int _g1 = this->cubePositions->length;
HXDLIN( 511)				while((_g < _g1)){
HXLINE( 511)					_g = (_g + 1);
HXDLIN( 511)					int i = (_g - 1);
HXLINE( 512)					Float angle = (((Float)20.0) * ( (Float)(i) ));
HXLINE( 513)					 ::lime::utils::ArrayBufferView model = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 514)					::lime::math::_Matrix4::Matrix4_Impl__obj::identity(model);
HXLINE( 515)					::lime::math::_Matrix4::Matrix4_Impl__obj::appendTranslation(model,this->cubePositions->__get(i).StaticCast< ::Array< Float > >()->__get(0),this->cubePositions->__get(i).StaticCast< ::Array< Float > >()->__get(1),this->cubePositions->__get(i).StaticCast< ::Array< Float > >()->__get(2));
HXLINE( 516)					::lime::math::_Matrix4::Matrix4_Impl__obj::appendRotation(model,angle, ::lime::math::Vector4_obj::__alloc( HX_CTX ,((Float)1.0),((Float)0.3),((Float)0.5),((Float)1.0)),null());
HXLINE( 517)					::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::uniformMatrix4fv(gl,gl->getUniformLocation(this->program,HX_("model",a9,23,58,0c)),false,model,null(),null());
HXLINE( 518)					gl->drawArrays(gl->TRIANGLES,0,36);
            				}
            			}
HXLINE( 463)			goto _hx_goto_23;
            		}
            		/* default */{
            		}
            		_hx_goto_23:;
            	}



::hx::ObjectPtr< Main_obj > Main_obj::__new() {
	::hx::ObjectPtr< Main_obj > __this = new Main_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Main_obj > Main_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Main_obj *__this = (Main_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Main_obj), true, "Main"));
	*(void **)__this = Main_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Main_obj::Main_obj()
{
}

void Main_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Main);
	HX_MARK_MEMBER_NAME(vbo,"vbo");
	HX_MARK_MEMBER_NAME(ebo,"ebo");
	HX_MARK_MEMBER_NAME(texture,"texture");
	HX_MARK_MEMBER_NAME(texture2,"texture2");
	HX_MARK_MEMBER_NAME(program,"program");
	HX_MARK_MEMBER_NAME(image,"image");
	HX_MARK_MEMBER_NAME(image2,"image2");
	HX_MARK_MEMBER_NAME(trans,"trans");
	HX_MARK_MEMBER_NAME(vec,"vec");
	HX_MARK_MEMBER_NAME(model,"model");
	HX_MARK_MEMBER_NAME(view,"view");
	HX_MARK_MEMBER_NAME(proj,"proj");
	HX_MARK_MEMBER_NAME(transMat,"transMat");
	HX_MARK_MEMBER_NAME(cubePositions,"cubePositions");
	HX_MARK_MEMBER_NAME(cameraPos,"cameraPos");
	HX_MARK_MEMBER_NAME(cameraFront,"cameraFront");
	HX_MARK_MEMBER_NAME(cameraUp,"cameraUp");
	HX_MARK_MEMBER_NAME(deltaTime,"deltaTime");
	HX_MARK_MEMBER_NAME(currentFrame,"currentFrame");
	HX_MARK_MEMBER_NAME(lastFrame,"lastFrame");
	HX_MARK_MEMBER_NAME(firstMouse,"firstMouse");
	HX_MARK_MEMBER_NAME(lastX,"lastX");
	HX_MARK_MEMBER_NAME(lastY,"lastY");
	HX_MARK_MEMBER_NAME(xOffset,"xOffset");
	HX_MARK_MEMBER_NAME(yOffset,"yOffset");
	HX_MARK_MEMBER_NAME(sensitivity,"sensitivity");
	HX_MARK_MEMBER_NAME(yaw,"yaw");
	HX_MARK_MEMBER_NAME(pitch,"pitch");
	HX_MARK_MEMBER_NAME(fov,"fov");
	HX_MARK_MEMBER_NAME(moveLeft,"moveLeft");
	HX_MARK_MEMBER_NAME(moveRight,"moveRight");
	HX_MARK_MEMBER_NAME(moveForward,"moveForward");
	HX_MARK_MEMBER_NAME(moveBackward,"moveBackward");
	HX_MARK_MEMBER_NAME(initialized,"initialized");
	 ::lime::app::Application_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Main_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(vbo,"vbo");
	HX_VISIT_MEMBER_NAME(ebo,"ebo");
	HX_VISIT_MEMBER_NAME(texture,"texture");
	HX_VISIT_MEMBER_NAME(texture2,"texture2");
	HX_VISIT_MEMBER_NAME(program,"program");
	HX_VISIT_MEMBER_NAME(image,"image");
	HX_VISIT_MEMBER_NAME(image2,"image2");
	HX_VISIT_MEMBER_NAME(trans,"trans");
	HX_VISIT_MEMBER_NAME(vec,"vec");
	HX_VISIT_MEMBER_NAME(model,"model");
	HX_VISIT_MEMBER_NAME(view,"view");
	HX_VISIT_MEMBER_NAME(proj,"proj");
	HX_VISIT_MEMBER_NAME(transMat,"transMat");
	HX_VISIT_MEMBER_NAME(cubePositions,"cubePositions");
	HX_VISIT_MEMBER_NAME(cameraPos,"cameraPos");
	HX_VISIT_MEMBER_NAME(cameraFront,"cameraFront");
	HX_VISIT_MEMBER_NAME(cameraUp,"cameraUp");
	HX_VISIT_MEMBER_NAME(deltaTime,"deltaTime");
	HX_VISIT_MEMBER_NAME(currentFrame,"currentFrame");
	HX_VISIT_MEMBER_NAME(lastFrame,"lastFrame");
	HX_VISIT_MEMBER_NAME(firstMouse,"firstMouse");
	HX_VISIT_MEMBER_NAME(lastX,"lastX");
	HX_VISIT_MEMBER_NAME(lastY,"lastY");
	HX_VISIT_MEMBER_NAME(xOffset,"xOffset");
	HX_VISIT_MEMBER_NAME(yOffset,"yOffset");
	HX_VISIT_MEMBER_NAME(sensitivity,"sensitivity");
	HX_VISIT_MEMBER_NAME(yaw,"yaw");
	HX_VISIT_MEMBER_NAME(pitch,"pitch");
	HX_VISIT_MEMBER_NAME(fov,"fov");
	HX_VISIT_MEMBER_NAME(moveLeft,"moveLeft");
	HX_VISIT_MEMBER_NAME(moveRight,"moveRight");
	HX_VISIT_MEMBER_NAME(moveForward,"moveForward");
	HX_VISIT_MEMBER_NAME(moveBackward,"moveBackward");
	HX_VISIT_MEMBER_NAME(initialized,"initialized");
	 ::lime::app::Application_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Main_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"vbo") ) { return ::hx::Val( vbo ); }
		if (HX_FIELD_EQ(inName,"ebo") ) { return ::hx::Val( ebo ); }
		if (HX_FIELD_EQ(inName,"vec") ) { return ::hx::Val( vec ); }
		if (HX_FIELD_EQ(inName,"yaw") ) { return ::hx::Val( yaw ); }
		if (HX_FIELD_EQ(inName,"fov") ) { return ::hx::Val( fov ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"view") ) { return ::hx::Val( view ); }
		if (HX_FIELD_EQ(inName,"proj") ) { return ::hx::Val( proj ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"image") ) { return ::hx::Val( image ); }
		if (HX_FIELD_EQ(inName,"trans") ) { return ::hx::Val( trans ); }
		if (HX_FIELD_EQ(inName,"model") ) { return ::hx::Val( model ); }
		if (HX_FIELD_EQ(inName,"lastX") ) { return ::hx::Val( lastX ); }
		if (HX_FIELD_EQ(inName,"lastY") ) { return ::hx::Val( lastY ); }
		if (HX_FIELD_EQ(inName,"pitch") ) { return ::hx::Val( pitch ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"image2") ) { return ::hx::Val( image2 ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { return ::hx::Val( texture ); }
		if (HX_FIELD_EQ(inName,"program") ) { return ::hx::Val( program ); }
		if (HX_FIELD_EQ(inName,"xOffset") ) { return ::hx::Val( xOffset ); }
		if (HX_FIELD_EQ(inName,"yOffset") ) { return ::hx::Val( yOffset ); }
		if (HX_FIELD_EQ(inName,"onKeyUp") ) { return ::hx::Val( onKeyUp_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"texture2") ) { return ::hx::Val( texture2 ); }
		if (HX_FIELD_EQ(inName,"transMat") ) { return ::hx::Val( transMat ); }
		if (HX_FIELD_EQ(inName,"cameraUp") ) { return ::hx::Val( cameraUp ); }
		if (HX_FIELD_EQ(inName,"moveLeft") ) { return ::hx::Val( moveLeft ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"cameraPos") ) { return ::hx::Val( cameraPos ); }
		if (HX_FIELD_EQ(inName,"deltaTime") ) { return ::hx::Val( deltaTime ); }
		if (HX_FIELD_EQ(inName,"lastFrame") ) { return ::hx::Val( lastFrame ); }
		if (HX_FIELD_EQ(inName,"moveRight") ) { return ::hx::Val( moveRight ); }
		if (HX_FIELD_EQ(inName,"onKeyDown") ) { return ::hx::Val( onKeyDown_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"firstMouse") ) { return ::hx::Val( firstMouse ); }
		if (HX_FIELD_EQ(inName,"initialize") ) { return ::hx::Val( initialize_dyn() ); }
		if (HX_FIELD_EQ(inName,"moveCamera") ) { return ::hx::Val( moveCamera_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"cameraFront") ) { return ::hx::Val( cameraFront ); }
		if (HX_FIELD_EQ(inName,"sensitivity") ) { return ::hx::Val( sensitivity ); }
		if (HX_FIELD_EQ(inName,"moveForward") ) { return ::hx::Val( moveForward ); }
		if (HX_FIELD_EQ(inName,"initialized") ) { return ::hx::Val( initialized ); }
		if (HX_FIELD_EQ(inName,"onMouseMove") ) { return ::hx::Val( onMouseMove_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentFrame") ) { return ::hx::Val( currentFrame ); }
		if (HX_FIELD_EQ(inName,"moveBackward") ) { return ::hx::Val( moveBackward ); }
		if (HX_FIELD_EQ(inName,"onMouseWheel") ) { return ::hx::Val( onMouseWheel_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"cubePositions") ) { return ::hx::Val( cubePositions ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"glCreateShader") ) { return ::hx::Val( glCreateShader_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"glCreateProgram") ) { return ::hx::Val( glCreateProgram_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"createLookAtMatrix") ) { return ::hx::Val( createLookAtMatrix_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"createPerspectiveZO") ) { return ::hx::Val( createPerspectiveZO_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Main_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"vbo") ) { vbo=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ebo") ) { ebo=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vec") ) { vec=inValue.Cast<  ::lime::math::Vector4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"yaw") ) { yaw=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fov") ) { fov=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"view") ) { view=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"proj") ) { proj=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"image") ) { image=inValue.Cast<  ::lime::graphics::Image >(); return inValue; }
		if (HX_FIELD_EQ(inName,"trans") ) { trans=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"model") ) { model=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastX") ) { lastX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastY") ) { lastY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pitch") ) { pitch=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"image2") ) { image2=inValue.Cast<  ::lime::graphics::Image >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { texture=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"program") ) { program=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"xOffset") ) { xOffset=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"yOffset") ) { yOffset=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"texture2") ) { texture2=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"transMat") ) { transMat=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cameraUp") ) { cameraUp=inValue.Cast<  ::lime::math::Vector4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moveLeft") ) { moveLeft=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"cameraPos") ) { cameraPos=inValue.Cast<  ::lime::math::Vector4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"deltaTime") ) { deltaTime=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastFrame") ) { lastFrame=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moveRight") ) { moveRight=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"firstMouse") ) { firstMouse=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"cameraFront") ) { cameraFront=inValue.Cast<  ::lime::math::Vector4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sensitivity") ) { sensitivity=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moveForward") ) { moveForward=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"initialized") ) { initialized=inValue.Cast< bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentFrame") ) { currentFrame=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moveBackward") ) { moveBackward=inValue.Cast< bool >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"cubePositions") ) { cubePositions=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Main_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("vbo",c3,df,59,00));
	outFields->push(HX_("ebo",72,f9,4c,00));
	outFields->push(HX_("texture",db,c8,e0,9e));
	outFields->push(HX_("texture2",f7,f6,ce,65));
	outFields->push(HX_("program",84,4a,f9,f3));
	outFields->push(HX_("image",5b,1f,69,bd));
	outFields->push(HX_("image2",77,50,92,fe));
	outFields->push(HX_("trans",28,98,1f,16));
	outFields->push(HX_("vec",54,e2,59,00));
	outFields->push(HX_("model",a9,23,58,0c));
	outFields->push(HX_("view",65,32,4f,4e));
	outFields->push(HX_("proj",9d,c7,5e,4a));
	outFields->push(HX_("transMat",58,b3,5a,da));
	outFields->push(HX_("cubePositions",f5,cf,98,aa));
	outFields->push(HX_("cameraPos",ef,c3,30,3a));
	outFields->push(HX_("cameraFront",c4,0b,d4,fa));
	outFields->push(HX_("cameraUp",60,44,27,e8));
	outFields->push(HX_("deltaTime",25,3c,5c,f5));
	outFields->push(HX_("currentFrame",34,5d,8f,4d));
	outFields->push(HX_("lastFrame",f7,a5,30,53));
	outFields->push(HX_("firstMouse",d5,5f,43,4a));
	outFields->push(HX_("lastX",42,01,bc,6f));
	outFields->push(HX_("lastY",43,01,bc,6f));
	outFields->push(HX_("xOffset",2b,b6,e3,12));
	outFields->push(HX_("yOffset",ec,2c,79,3c));
	outFields->push(HX_("sensitivity",1f,94,c5,49));
	outFields->push(HX_("yaw",af,25,5c,00));
	outFields->push(HX_("pitch",c0,bb,a0,c2));
	outFields->push(HX_("fov",0d,c7,4d,00));
	outFields->push(HX_("moveLeft",b8,73,67,ea));
	outFields->push(HX_("moveRight",0b,db,2a,a7));
	outFields->push(HX_("moveForward",b4,1a,47,be));
	outFields->push(HX_("moveBackward",14,74,4e,bb));
	outFields->push(HX_("initialized",14,f5,0f,37));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Main_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,vbo),HX_("vbo",c3,df,59,00)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,ebo),HX_("ebo",72,f9,4c,00)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,texture),HX_("texture",db,c8,e0,9e)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,texture2),HX_("texture2",f7,f6,ce,65)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,program),HX_("program",84,4a,f9,f3)},
	{::hx::fsObject /*  ::lime::graphics::Image */ ,(int)offsetof(Main_obj,image),HX_("image",5b,1f,69,bd)},
	{::hx::fsObject /*  ::lime::graphics::Image */ ,(int)offsetof(Main_obj,image2),HX_("image2",77,50,92,fe)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(int)offsetof(Main_obj,trans),HX_("trans",28,98,1f,16)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(int)offsetof(Main_obj,vec),HX_("vec",54,e2,59,00)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(int)offsetof(Main_obj,model),HX_("model",a9,23,58,0c)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(int)offsetof(Main_obj,view),HX_("view",65,32,4f,4e)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(int)offsetof(Main_obj,proj),HX_("proj",9d,c7,5e,4a)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Main_obj,transMat),HX_("transMat",58,b3,5a,da)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Main_obj,cubePositions),HX_("cubePositions",f5,cf,98,aa)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(int)offsetof(Main_obj,cameraPos),HX_("cameraPos",ef,c3,30,3a)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(int)offsetof(Main_obj,cameraFront),HX_("cameraFront",c4,0b,d4,fa)},
	{::hx::fsObject /*  ::lime::math::Vector4 */ ,(int)offsetof(Main_obj,cameraUp),HX_("cameraUp",60,44,27,e8)},
	{::hx::fsFloat,(int)offsetof(Main_obj,deltaTime),HX_("deltaTime",25,3c,5c,f5)},
	{::hx::fsFloat,(int)offsetof(Main_obj,currentFrame),HX_("currentFrame",34,5d,8f,4d)},
	{::hx::fsFloat,(int)offsetof(Main_obj,lastFrame),HX_("lastFrame",f7,a5,30,53)},
	{::hx::fsBool,(int)offsetof(Main_obj,firstMouse),HX_("firstMouse",d5,5f,43,4a)},
	{::hx::fsFloat,(int)offsetof(Main_obj,lastX),HX_("lastX",42,01,bc,6f)},
	{::hx::fsFloat,(int)offsetof(Main_obj,lastY),HX_("lastY",43,01,bc,6f)},
	{::hx::fsFloat,(int)offsetof(Main_obj,xOffset),HX_("xOffset",2b,b6,e3,12)},
	{::hx::fsFloat,(int)offsetof(Main_obj,yOffset),HX_("yOffset",ec,2c,79,3c)},
	{::hx::fsFloat,(int)offsetof(Main_obj,sensitivity),HX_("sensitivity",1f,94,c5,49)},
	{::hx::fsFloat,(int)offsetof(Main_obj,yaw),HX_("yaw",af,25,5c,00)},
	{::hx::fsFloat,(int)offsetof(Main_obj,pitch),HX_("pitch",c0,bb,a0,c2)},
	{::hx::fsFloat,(int)offsetof(Main_obj,fov),HX_("fov",0d,c7,4d,00)},
	{::hx::fsBool,(int)offsetof(Main_obj,moveLeft),HX_("moveLeft",b8,73,67,ea)},
	{::hx::fsBool,(int)offsetof(Main_obj,moveRight),HX_("moveRight",0b,db,2a,a7)},
	{::hx::fsBool,(int)offsetof(Main_obj,moveForward),HX_("moveForward",b4,1a,47,be)},
	{::hx::fsBool,(int)offsetof(Main_obj,moveBackward),HX_("moveBackward",14,74,4e,bb)},
	{::hx::fsBool,(int)offsetof(Main_obj,initialized),HX_("initialized",14,f5,0f,37)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Main_obj_sStaticStorageInfo = 0;
#endif

static ::String Main_obj_sMemberFields[] = {
	HX_("vbo",c3,df,59,00),
	HX_("ebo",72,f9,4c,00),
	HX_("texture",db,c8,e0,9e),
	HX_("texture2",f7,f6,ce,65),
	HX_("program",84,4a,f9,f3),
	HX_("image",5b,1f,69,bd),
	HX_("image2",77,50,92,fe),
	HX_("trans",28,98,1f,16),
	HX_("vec",54,e2,59,00),
	HX_("model",a9,23,58,0c),
	HX_("view",65,32,4f,4e),
	HX_("proj",9d,c7,5e,4a),
	HX_("transMat",58,b3,5a,da),
	HX_("cubePositions",f5,cf,98,aa),
	HX_("cameraPos",ef,c3,30,3a),
	HX_("cameraFront",c4,0b,d4,fa),
	HX_("cameraUp",60,44,27,e8),
	HX_("deltaTime",25,3c,5c,f5),
	HX_("currentFrame",34,5d,8f,4d),
	HX_("lastFrame",f7,a5,30,53),
	HX_("firstMouse",d5,5f,43,4a),
	HX_("lastX",42,01,bc,6f),
	HX_("lastY",43,01,bc,6f),
	HX_("xOffset",2b,b6,e3,12),
	HX_("yOffset",ec,2c,79,3c),
	HX_("sensitivity",1f,94,c5,49),
	HX_("yaw",af,25,5c,00),
	HX_("pitch",c0,bb,a0,c2),
	HX_("fov",0d,c7,4d,00),
	HX_("moveLeft",b8,73,67,ea),
	HX_("moveRight",0b,db,2a,a7),
	HX_("moveForward",b4,1a,47,be),
	HX_("moveBackward",14,74,4e,bb),
	HX_("initialized",14,f5,0f,37),
	HX_("glCreateShader",06,c9,79,c8),
	HX_("glCreateProgram",83,e5,88,36),
	HX_("initialize",50,31,bb,ec),
	HX_("createPerspectiveZO",95,c6,aa,2d),
	HX_("createLookAtMatrix",2f,4e,67,70),
	HX_("moveCamera",96,c0,ba,07),
	HX_("update",09,86,05,87),
	HX_("onKeyDown",42,22,f2,73),
	HX_("onKeyUp",3b,58,3c,75),
	HX_("onMouseMove",b7,7e,f8,16),
	HX_("onMouseWheel",35,ca,ca,bf),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class Main_obj::__mClass;

void Main_obj::__register()
{
	Main_obj _hx_dummy;
	Main_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Main",59,64,2f,33);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Main_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Main_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Main_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Main_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

