// Generated by Haxe 5.0.0-alpha.1+2f4b99d
#include <hxcpp.h>

#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeOpenGLRenderContext
#include <lime/_internal/backend/native/NativeOpenGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_app_Application
#include <lime/app/Application.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_lime_app_Module
#include <lime/app/Module.h>
#endif
#ifndef INCLUDED_lime_graphics_RenderContext
#include <lime/graphics/RenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics__WebGL2RenderContext_WebGL2RenderContext_Impl_
#include <lime/graphics/_WebGL2RenderContext/WebGL2RenderContext_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_TAError
#include <lime/utils/TAError.h>
#endif
#ifndef INCLUDED_lime_utils__DataPointer_DataPointer_Impl_
#include <lime/utils/_DataPointer/DataPointer_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e47a9afac0942eb9_24_new,"Main","new",0x6616a5cb,"Main.new","Main.hx",24,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_40_glCreateShader,"Main","glCreateShader",0x572fe57b,"Main.glCreateShader","Main.hx",40,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_62_glCreateProgram,"Main","glCreateProgram",0x872baf6e,"Main.glCreateProgram","Main.hx",62,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_91_initialize,"Main","initialize",0x8442af45,"Main.initialize","Main.hx",91,0x087e5c05)
static const Float _hx_array_data_332f6459_4[] = {
	-0.5,-0.5,0.0,0.5,-0.5,0.0,0.0,0.5,0.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_131_render,"Main","render",0x35d38acb,"Main.render","Main.hx",131,0x087e5c05)

void Main_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_24_new)
HXLINE(  26)		super::__construct();
HXLINE(  28)		this->initialized = false;
            	}

Dynamic Main_obj::__CreateEmpty() { return new Main_obj; }

void *Main_obj::_hx_vtable = 0;

Dynamic Main_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Main_obj > _hx_result = new Main_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Main_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x431bf104) {
		if (inClassId<=(int)0x07825a7d) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x07825a7d;
		} else {
			return inClassId==(int)0x431bf104;
		}
	} else {
		return inClassId==(int)0x7f8386d8;
	}
}

 ::lime::graphics::opengl::GLObject Main_obj::glCreateShader( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl,::String source,int type){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_40_glCreateShader)
HXLINE(  41)		 ::lime::graphics::opengl::GLObject shader = gl->createShader(type);
HXLINE(  42)		gl->shaderSource(shader,source);
HXLINE(  43)		gl->compileShader(shader);
HXLINE(  45)		if (::hx::IsEq( gl->getShaderParameter(shader,gl->COMPILE_STATUS),0 )) {
HXLINE(  47)			 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN(  47)			::String _hx_tmp1 = gl->getShaderInfoLog(shader);
HXDLIN(  47)			_hx_tmp(_hx_tmp1,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),47,HX_("Main",59,64,2f,33),HX_("glCreateShader",06,c9,79,c8)));
HXLINE(  48)			return null();
            		}
HXLINE(  51)		return shader;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Main_obj,glCreateShader,return )

 ::lime::graphics::opengl::GLObject Main_obj::glCreateProgram( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl,::String vertexSource,::String fragmentSource){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_62_glCreateProgram)
HXLINE(  63)		 ::lime::graphics::opengl::GLObject vs = this->glCreateShader(gl,vertexSource,gl->VERTEX_SHADER);
HXLINE(  64)		 ::lime::graphics::opengl::GLObject fs = this->glCreateShader(gl,fragmentSource,gl->FRAGMENT_SHADER);
HXLINE(  66)		bool _hx_tmp;
HXDLIN(  66)		if (::hx::IsNotNull( vs )) {
HXLINE(  66)			_hx_tmp = ::hx::IsNull( fs );
            		}
            		else {
HXLINE(  66)			_hx_tmp = true;
            		}
HXDLIN(  66)		if (_hx_tmp) {
HXLINE(  68)			return null();
            		}
HXLINE(  71)		 ::lime::graphics::opengl::GLObject program = gl->createProgram();
HXLINE(  72)		gl->attachShader(program,vs);
HXLINE(  73)		gl->attachShader(program,fs);
HXLINE(  75)		gl->deleteShader(vs);
HXLINE(  76)		gl->deleteShader(fs);
HXLINE(  78)		gl->linkProgram(program);
HXLINE(  80)		if (::hx::IsEq( gl->getProgramParameter(program,gl->LINK_STATUS),0 )) {
HXLINE(  82)			 ::Dynamic _hx_tmp1 = ::haxe::Log_obj::trace;
HXDLIN(  82)			::String _hx_tmp2 = gl->getProgramInfoLog(program);
HXDLIN(  82)			_hx_tmp1(_hx_tmp2,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),82,HX_("Main",59,64,2f,33),HX_("glCreateProgram",83,e5,88,36)));
HXLINE(  83)			 ::Dynamic _hx_tmp3 = ::haxe::Log_obj::trace;
HXDLIN(  83)			::String _hx_tmp4 = (HX_("VALIDATE_STATUS: ",61,4a,52,b0) + ::Std_obj::string(gl->getProgramParameter(program,gl->VALIDATE_STATUS)));
HXDLIN(  83)			_hx_tmp3(_hx_tmp4,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),83,HX_("Main",59,64,2f,33),HX_("glCreateProgram",83,e5,88,36)));
HXLINE(  84)			 ::Dynamic _hx_tmp5 = ::haxe::Log_obj::trace;
HXDLIN(  84)			::String _hx_tmp6 = (HX_("ERROR: ",4e,70,de,69) + gl->getError());
HXDLIN(  84)			_hx_tmp5(_hx_tmp6,::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),84,HX_("Main",59,64,2f,33),HX_("glCreateProgram",83,e5,88,36)));
HXLINE(  85)			return null();
            		}
HXLINE(  88)		return program;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Main_obj,glCreateProgram,return )

void Main_obj::initialize( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_91_initialize)
HXLINE(  93)		::String vs = HX_("#version 300 es\nlayout (location = 0) in vec3 aPos;\n\nvoid main()\n{\n\tgl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n}\n",0d,69,82,36);
HXLINE( 103)		::String fs = HX_("#version 300 es\nprecision mediump float;\n\nout vec4 FragColor;\n\nvoid main() \n{\n    FragColor = vec4(1.0, 0.5, 0.2, 1.0);\n}\n",d1,94,96,13);
HXLINE( 114)		this->program = this->glCreateProgram(gl,vs,fs);
HXLINE( 117)		::Array< Float > vertices = ::Array_obj< Float >::fromData( _hx_array_data_332f6459_4,9);
HXLINE( 120)		 ::Dynamic elements = null();
HXDLIN( 120)		 ::haxe::io::Bytes buffer = null();
HXDLIN( 120)		 ::lime::utils::ArrayBufferView view = null();
HXDLIN( 120)		 ::Dynamic len = null();
HXDLIN( 120)		 ::lime::utils::ArrayBufferView this1;
HXDLIN( 120)		if (::hx::IsNotNull( elements )) {
HXLINE( 120)			this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,8);
            		}
            		else {
HXLINE( 120)			if (::hx::IsNotNull( vertices )) {
HXLINE( 120)				 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN( 120)				_this->byteOffset = 0;
HXDLIN( 120)				_this->length = vertices->length;
HXDLIN( 120)				_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN( 120)				_this->buffer = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN( 120)				_this->copyFromArray(vertices,null());
HXDLIN( 120)				this1 = _this;
            			}
            			else {
HXLINE( 120)				if (::hx::IsNotNull( view )) {
HXLINE( 120)					 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN( 120)					 ::haxe::io::Bytes srcData = view->buffer;
HXDLIN( 120)					int srcLength = view->length;
HXDLIN( 120)					int srcByteOffset = view->byteOffset;
HXDLIN( 120)					int srcElementSize = view->bytesPerElement;
HXDLIN( 120)					int elementSize = _this1->bytesPerElement;
HXDLIN( 120)					if ((view->type == _this1->type)) {
HXLINE( 120)						int srcLength1 = srcData->length;
HXDLIN( 120)						int cloneLength = (srcLength1 - srcByteOffset);
HXDLIN( 120)						_this1->buffer = ::haxe::io::Bytes_obj::alloc(cloneLength);
HXDLIN( 120)						_this1->buffer->blit(0,srcData,srcByteOffset,cloneLength);
            					}
            					else {
HXLINE( 120)						HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            					}
HXDLIN( 120)					_this1->byteLength = (_this1->bytesPerElement * srcLength);
HXDLIN( 120)					_this1->byteOffset = 0;
HXDLIN( 120)					_this1->length = srcLength;
HXDLIN( 120)					this1 = _this1;
            				}
            				else {
HXLINE( 120)					if (::hx::IsNotNull( buffer )) {
HXLINE( 120)						 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN( 120)						int in_byteOffset = 0;
HXDLIN( 120)						if ((in_byteOffset < 0)) {
HXLINE( 120)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 120)						if ((::hx::Mod(in_byteOffset,_this2->bytesPerElement) != 0)) {
HXLINE( 120)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 120)						int bufferByteLength = buffer->length;
HXDLIN( 120)						int elementSize1 = _this2->bytesPerElement;
HXDLIN( 120)						int newByteLength = bufferByteLength;
HXDLIN( 120)						if (::hx::IsNull( len )) {
HXLINE( 120)							newByteLength = (bufferByteLength - in_byteOffset);
HXDLIN( 120)							if ((::hx::Mod(bufferByteLength,_this2->bytesPerElement) != 0)) {
HXLINE( 120)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 120)							if ((newByteLength < 0)) {
HXLINE( 120)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 120)							newByteLength = (( (int)(len) ) * _this2->bytesPerElement);
HXDLIN( 120)							int newRange = (in_byteOffset + newByteLength);
HXDLIN( 120)							if ((newRange > bufferByteLength)) {
HXLINE( 120)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 120)						_this2->buffer = buffer;
HXDLIN( 120)						_this2->byteOffset = in_byteOffset;
HXDLIN( 120)						_this2->byteLength = newByteLength;
HXDLIN( 120)						_this2->length = ::Std_obj::_hx_int((( (Float)(newByteLength) ) / ( (Float)(_this2->bytesPerElement) )));
HXDLIN( 120)						this1 = _this2;
            					}
            					else {
HXLINE( 120)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            					}
            				}
            			}
            		}
HXDLIN( 120)		 ::lime::utils::ArrayBufferView vertexData = this1;
HXLINE( 121)		this->vbo = gl->createBuffer();
HXLINE( 122)		gl->bindBuffer(gl->ARRAY_BUFFER,this->vbo);
HXLINE( 123)		::lime::graphics::_WebGL2RenderContext::WebGL2RenderContext_Impl__obj::bufferData(gl,gl->ARRAY_BUFFER,vertexData,gl->STATIC_DRAW,null(),null());
HXLINE( 124)		{
HXLINE( 124)			 ::lime::graphics::opengl::GLObject buffer1 = null();
HXDLIN( 124)			gl->bindBuffer(gl->ARRAY_BUFFER,buffer1);
            		}
HXLINE( 126)		this->initialized = true;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Main_obj,initialize,(void))

void Main_obj::render( ::lime::graphics::RenderContext context){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_131_render)
HXDLIN( 131)		::String _hx_switch_0 = context->type;
            		if (  (_hx_switch_0==HX_("opengl",6f,64,94,21)) ||  (_hx_switch_0==HX_("opengles",9d,f6,c9,fa)) ||  (_hx_switch_0==HX_("webgl",b9,4b,bc,c7)) ){
HXLINE( 135)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext gl = context->webgl2;
HXLINE( 137)			if (!(this->initialized)) {
HXLINE( 138)				this->initialize(gl);
            			}
HXLINE( 141)			gl->clearColor(((Float)0.75),( (Float)(1) ),( (Float)(0) ),( (Float)(1) ));
HXLINE( 142)			gl->clear(gl->COLOR_BUFFER_BIT);
HXLINE( 144)			gl->useProgram(this->program);
HXLINE( 147)			gl->bindBuffer(gl->ARRAY_BUFFER,this->vbo);
HXLINE( 148)			{
HXLINE( 148)				int type = gl->FLOAT;
HXDLIN( 148)				gl->vertexAttribPointer(0,3,type,false,12,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt(0));
            			}
HXLINE( 149)			gl->enableVertexAttribArray(0);
HXLINE( 151)			gl->drawArrays(gl->TRIANGLES,0,3);
HXLINE( 133)			goto _hx_goto_5;
            		}
            		/* default */{
            		}
            		_hx_goto_5:;
            	}



::hx::ObjectPtr< Main_obj > Main_obj::__new() {
	::hx::ObjectPtr< Main_obj > __this = new Main_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Main_obj > Main_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Main_obj *__this = (Main_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Main_obj), true, "Main"));
	*(void **)__this = Main_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Main_obj::Main_obj()
{
}

void Main_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Main);
	HX_MARK_MEMBER_NAME(vbo,"vbo");
	HX_MARK_MEMBER_NAME(program,"program");
	HX_MARK_MEMBER_NAME(initialized,"initialized");
	 ::lime::app::Application_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Main_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(vbo,"vbo");
	HX_VISIT_MEMBER_NAME(program,"program");
	HX_VISIT_MEMBER_NAME(initialized,"initialized");
	 ::lime::app::Application_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Main_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"vbo") ) { return ::hx::Val( vbo ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"program") ) { return ::hx::Val( program ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"initialize") ) { return ::hx::Val( initialize_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"initialized") ) { return ::hx::Val( initialized ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"glCreateShader") ) { return ::hx::Val( glCreateShader_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"glCreateProgram") ) { return ::hx::Val( glCreateProgram_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Main_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"vbo") ) { vbo=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"program") ) { program=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"initialized") ) { initialized=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Main_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("vbo",c3,df,59,00));
	outFields->push(HX_("program",84,4a,f9,f3));
	outFields->push(HX_("initialized",14,f5,0f,37));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Main_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,vbo),HX_("vbo",c3,df,59,00)},
	{::hx::fsObject /*  ::lime::graphics::opengl::GLObject */ ,(int)offsetof(Main_obj,program),HX_("program",84,4a,f9,f3)},
	{::hx::fsBool,(int)offsetof(Main_obj,initialized),HX_("initialized",14,f5,0f,37)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Main_obj_sStaticStorageInfo = 0;
#endif

static ::String Main_obj_sMemberFields[] = {
	HX_("vbo",c3,df,59,00),
	HX_("program",84,4a,f9,f3),
	HX_("initialized",14,f5,0f,37),
	HX_("glCreateShader",06,c9,79,c8),
	HX_("glCreateProgram",83,e5,88,36),
	HX_("initialize",50,31,bb,ec),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class Main_obj::__mClass;

void Main_obj::__register()
{
	Main_obj _hx_dummy;
	Main_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Main",59,64,2f,33);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Main_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Main_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Main_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Main_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

